<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3B82F6;
            --success-color: #10B981;
            --warning-color: #F59E0B;
            --danger-color: #e74c3c;
            --light-color: #f3f4f6;
            --dark-color: #1e293b;
            --supervisor-luthando: #F9E79F;
            --supervisor-apelele: #e6e6e6; /* Light grey for Apelele */
            --supervisor-siyabonga: #FADBD8;
            --supervisor-nosi: #D6EAF8;
            --supervisor-mvokwe: #D5F5E3;
            --production-color: #e74c3c; /* Red for production */
            --target-color: #10B981; /* Green for target */
            --current-indicator: #F59E0B; /* Yellow for current time indicator */
            --completed-variant: #D1E7DD; /* Light green for completed variants */
            --current-variant: #FFF3CD; /* Light yellow for current variant */
            --upcoming-variant: #F8D7DA; /* Light red for upcoming variants */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light-color);
            color: var(--primary-color);
            overflow: auto;
            transition: background-color 0.5s ease;
        }

        .dashboard-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 12px; /* Reduced padding */
            box-sizing: border-box;
            max-width: 1400px;
            margin: 0 auto;
            transition: background-color 0.5s ease;
        }

        .fullscreen-mode {
            display: grid;
            grid-template-rows: auto auto auto 1fr auto; /* Adjusted to give charts more space */
            padding: 8px !important; /* Further reduced padding */
            height: 100vh !important;
            width: 100vw !important;
            max-width: 100% !important;
            margin: 0 !important;
            overflow: hidden !important;
            box-sizing: border-box;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px; /* Reduced margin */
            padding-bottom: 5px; /* Reduced padding */
            border-bottom: 1px solid #e2e8f0;
            width: 100%;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 15px; /* Reduced gap */
            flex-wrap: wrap;
        }

        .title {
            font-size: clamp(1.3rem, 2.2vw, 2.2rem); /* Slightly reduced */
            font-weight: bold;
            color: var(--primary-color);
        }

        .subtitle {
            font-size: clamp(1rem, 1.5vw, 1.5rem); /* Slightly reduced */
            color: var(--secondary-color);
            font-weight: 500;
        }

        .date-time {
            text-align: right;
            font-size: clamp(0.9rem, 1.2vw, 1.2rem); /* Slightly reduced */
        }

        .date {
            font-weight: bold;
        }

        .time {
            font-size: clamp(1.1rem, 1.6vw, 1.6rem); /* Slightly reduced */
            margin-top: 3px; /* Reduced margin */
        }

        .content {
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
            flex: 1; /* Make sure content takes up available space */
        }

        /* New layout for info row - product info and variant details side by side */
        .info-row {
            display: flex;
            gap: 8px;
            margin-bottom: 5px;
            width: 100%;
        }
        
        .product-supervisor-info {
            flex: 1;
            background-color: var(--dark-color);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
        }
        
        .variant-details-box {
            flex: 1;
            background-color: var(--dark-color);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
        }

        .product-name {
            font-size: clamp(1.1rem, 1.6vw, 1.6rem);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .supervisor-name {
            font-size: clamp(0.9rem, 1.3vw, 1.3rem);
            font-style: italic;
            margin-bottom: 10px;
        }

        .variant-sequence-label {
            font-size: 0.9rem;
            margin-bottom: 3px;
        }
        
        .variant-sequence {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            flex-wrap: wrap;
            gap: 3px;
        }

        .variant-item {
            padding: 3px 8px;
            border-radius: 4px;
            white-space: nowrap;
            position: relative;
        }
        
        .variant-time {
            font-size: 0.8rem;
            display: block;
            text-align: center;
        }
        
        .variant-status {
            font-size: 0.7rem;
            display: block;
            text-align: center;
            font-weight: bold;
        }
        
        .variant-item.completed {
            background-color: var(--completed-variant);
            color: var(--dark-color);
        }
        
        .variant-item.current {
            background-color: var(--current-variant);
            color: var(--dark-color);
            font-weight: bold;
        }
        
        .variant-item.upcoming {
            background-color: var(--upcoming-variant);
            color: var(--dark-color);
        }
        
        .arrow-right {
            margin: 0 2px;
            color: white;
        }

        .current-variant-header {
            font-size: clamp(1.1rem, 1.6vw, 1.6rem);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .variant-period {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .variant-target {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .variant-progress {
            font-size: 0.9rem;
        }

        .totals-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            margin-bottom: 5px; /* Reduced margin */
            font-size: clamp(0.9rem, 1.1vw, 1.1rem); /* Reduced size */
            gap: 8px; /* Reduced gap */
            width: 100%;
            box-sizing: border-box;
            align-items: start; /* Align items at the top for consistent vertical alignment */
        }

        .total-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 10px; /* Reduced padding */
            width: 100%;
            margin-bottom: 10px; /* Added margin between total-items for better spacing */
        }

        .total-label {
            font-weight: bold;
            margin-bottom: 4px; /* Reduced margin */
            font-size: clamp(0.9rem, 1.3vw, 1.3rem); /* Reduced size */
            color: var(--dark-color);
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
            padding-bottom: 2px; /* Reduced bottom padding */
        }

        .total-percentage {
            color: var(--warning-color);
            font-size: 0.9em;
        }

        .total-value {
            font-size: clamp(1.3rem, 2.2vw, 2.2rem); /* Reduced size */
            font-weight: bold;
        }

        .total-subvalue {
            font-size: clamp(0.9rem, 1.1vw, 1.1rem); /* Reduced size */
            margin-top: 3px; /* Reduced margin */
        }

        .current-value {
            color: var(--production-color); /* Changed to red */
        }

        .target-value {
            color: var(--target-color); /* Remains green */
        }

        .total-hourly {
            color: var(--dark-color);
        }

        .chart-container {
            flex: 1; /* Takes all available space */
            background-color: white;
            border-radius: 8px;
            padding: 8px; /* Reduced padding */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            min-height: 0; /* Important for flex container */
            margin-top: 5px; /* Added small margin */
        }

        .charts-row {
            display: flex;
            gap: 8px; /* Reduced gap */
            flex: 1;
            min-height: 0; /* Important for flex container */
            height: calc(70vh - 200px); /* Set a minimum height based on viewport */
        }

        .chart {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            padding: 6px; /* Reduced padding */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0; /* Important for flex container */
        }

        .chart-header {
            display: flex;
            align-items: center;
            margin-bottom: 6px; /* Reduced margin */
            flex-wrap: nowrap;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 6px; /* Reduced padding */
        }

        .chart-title {
            font-size: clamp(1.1rem, 1.4vw, 1.4rem); /* Reduced size */
            font-weight: 600;
            margin-right: 15px; /* Reduced margin */
            color: var(--dark-color);
            white-space: nowrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .transition-marker {
            position: absolute;
            bottom: 0;
            width: 2px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            z-index: 1;
        }

        .variant-label {
            position: absolute;
            bottom: 5px;
            transform: translateX(-50%);
            font-size: 9px;
            color: var(--dark-color);
            white-space: nowrap;
        }

        .chart-title-select {
            background: none;
            border: none;
            color: var(--dark-color);
            font-weight: 600;
            font-size: clamp(1.1rem, 1.4vw, 1.4rem); /* Reduced size */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            display: inline-block;
        }

        .chart-title-select:focus {
            outline: none;
        }

        .chart-title-text {
            font-size: clamp(1.1rem, 1.4vw, 1.4rem); /* Reduced size */
            font-weight: 600;
            color: var(--dark-color);
            white-space: nowrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .hour-info {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px; /* Reduced gap */
            font-weight: 500;
            white-space: nowrap;
            margin-left: 10px;
        }

        .hour-countdown {
            font-size: 14px; /* Reduced size */
            color: var(--secondary-color);
            font-style: normal;
        }

        .hour-select-container {
            margin-left: auto;
        }

        .hour-select {
            padding: 4px 10px; /* Reduced padding */
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            font-family: inherit;
            background-color: white;
            height: 30px; /* Reduced height */
            font-size: 13px; /* Reduced size */
            font-weight: 500;
            color: var(--dark-color);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .chart-area {
            flex: 1;
            position: relative;
            height: 100%;
            min-height: 0;
        }

        .line-chart, .bar-chart {
            height: 100%;
            width: 100%;
            min-height: 0; /* Important for SVG content */
        }

        .legend {
            display: flex;
            justify-content: center;
            margin-top: 5px; /* Reduced margin */
            font-size: 0.9rem; /* Reduced size */
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 8px; /* Reduced margin */
        }

        .legend-color {
            width: 10px; /* Reduced size */
            height: 10px; /* Reduced size */
            margin-right: 4px; /* Reduced margin */
            border-radius: 2px;
        }

        .production-color {
            background-color: var(--production-color); /* Changed to red */
        }

        .target-color {
            background-color: var(--target-color); /* Remains green */
        }

        .transition-color {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .footer {
            margin-top: 5px; /* Reduced margin */
            text-align: center;
            font-size: clamp(0.9rem, 1.1vw, 1.1rem); /* Reduced size */
            color: var(--dark-color);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .current-time-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .current-time-dot {
            width: 10px;
            height: 10px;
            background-color: var(--warning-color);
            border-radius: 50%;
        }

        .progress-bar {
            height: 8px; /* Reduced height */
            background-color: var(--light-color);
            border-radius: 4px;
            margin-top: 3px; /* Reduced margin */
            overflow: hidden;
            width: 100%;
        }

        .progress {
            height: 100%;
            background-color: var(--secondary-color);
            transition: width 0.5s linear;
            width: 0%;
        }

        .update-info {
            font-size: 0.75rem; /* Reduced size */
            color: var(--dark-color);
            text-align: right;
            margin-top: 3px; /* Reduced margin */
        }

        .hourly-targets-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow: hidden;
            margin-top: 0; /* Removed margin to reduce deadspace */
        }

        .hourly-targets-svg {
            width: 100%;
            max-width: 800px; /* Further increased max-width */
            margin: 0 auto;
            overflow: visible;
            margin-top: -30px; /* Move SVG up more to reduce deadspace */
        }

        .hourly-circle {
            fill: white;
            stroke: #999;
            stroke-width: 4;
            r: 80; /* Further increased to ensure they match */
        }

        .time-label {
            font-size: clamp(0.9rem, 3.1vw, 3.2rem); /* Modified to match total-subvalue font size */
            text-anchor: middle;
            dominant-baseline: hanging;
            fill: #333;
            font-weight: 600; /* Increased weight for visibility */
        }
        
        .current-arrow {
            fill: var(--warning-color);
            transform: scale(6.0); /* Greatly increased scale to match larger circles */
        }

        .status-icon {
            stroke-width: 12; /* Significantly increased for prominence */
        }

        .status-success {
            stroke: var(--target-color);
        }

        .status-fail {
            stroke: var(--production-color);
        }

        .filter-section {
            display: flex;
            gap: 10px; /* Reduced gap */
            align-items: center;
        }

        .filter-select {
            padding: 6px 12px; /* Reduced padding */
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            font-size: clamp(0.85rem, 1vw, 1rem); /* Reduced size */
            font-family: inherit;
            min-width: 160px; /* Reduced width */
            background-color: white;
        }

        .loading {
            text-align: center;
            padding: 15px; /* Reduced padding */
            color: var(--dark-color);
        }

        .error {
            text-align: center;
            padding: 15px; /* Reduced padding */
            color: var(--danger-color);
            font-weight: bold;
        }

        .supervisor-aphele {
            color: #333; /* Dark text for Aphele's light background */
        }

        .dashboard-container.supervisor-luthando {
            background-color: var(--supervisor-luthando);
        }

        .dashboard-container.supervisor-aphele {
            background-color: var(--supervisor-aphele) !important;
        }
        
        .dashboard-container.supervisor-aphele.fullscreen-mode {
            background-color: #444444 !important; /* Light charcoal instead of light gray */
        }

        .dashboard-container.supervisor-siyabonga {
            background-color: var(--supervisor-siyabonga);
        }

        .dashboard-container.supervisor-nosi {
            background-color: var(--supervisor-nosi);
        }

        .dashboard-container.supervisor-mvokwe {
            background-color: var(--supervisor-mvokwe);
        }

        .dashboard-container.supervisor-apelele .chart-container,
        .dashboard-container.supervisor-apelele .chart,
        .dashboard-container.supervisor-apelele .filter-select,
        .dashboard-container.supervisor-apelele .hour-select {
            background-color: #f2f2f2; /* Lighter background for Apelele */
            color: #333;
            border-color: #ddd;
        }

        .dashboard-container.supervisor-apelele .chart-title,
        .dashboard-container.supervisor-apelele .hour-time,
        .dashboard-container.supervisor-apelele .total-label,
        .dashboard-container.supervisor-apelele .total-hourly,
        .dashboard-container.supervisor-apelele .legend {
            color: #333; /* Darker text for readability */
        }

        .debug-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 15px; /* Reduced padding */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            width: 600px;
        }

        .debug-popup.show {
            display: block;
        }

        .debug-popup-content {
            font-size: 0.85rem; /* Reduced size */
        }

        .debug-popup table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px; /* Reduced margin */
        }

        .debug-popup th, .debug-popup td {
            border: 1px solid #ddd;
            padding: 6px; /* Reduced padding */
            text-align: left;
        }

        .debug-popup th {
            background-color: var(--light-color);
            font-weight: bold;
        }

        .debug-popup .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px; /* Reduced padding */
            border: none;
            border-radius: 4px;
            background-color: var(--danger-color);
            color: white;
            cursor: pointer;
            font-size: 0.75rem; /* Reduced size */
        }

        .debug-popup .close-btn:hover {
            background-color: #c0392b;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 900;
        }

        .overlay.show {
            display: block;
        }

        /* Fullscreen mode adjustments to maximize chart space */
        .fullscreen-mode .chart-container {
            flex: 1;
            padding: 5px;
        }

        .fullscreen-mode .charts-row {
            height: calc(85vh - 180px); /* Even taller in fullscreen */
        }

        .fullscreen-mode .header,
        .fullscreen-mode .info-row,
        .fullscreen-mode .totals-display {
            margin-bottom: 3px;
        }
        
        /* Make hourly circles consistent on all screen sizes */
        @media (min-width: 768px) {
            .hourly-circle {
                r: 80; /* Same size as in base style */
            }
            
            .status-icon {
                stroke-width: 12; /* Same as in base style */
            }
            
            .current-arrow {
                transform: scale(6.0); /* Same as in base style */
            }
        }

        @media (max-width: 1200px) {
            .title-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .filter-section {
                margin-top: 8px;
            }
            .info-row {
                flex-direction: column;
            }
            .product-supervisor-info,
            .variant-details-box {
                width: 100%;
            }
        }

        @media (max-width: 1024px) {
            .charts-row {
                flex-direction: column;
                height: auto;
            }
            .chart {
                height: 40vh; /* Fixed height on smaller screens */
                min-height: 300px;
            }
            .dashboard-container {
                padding: 8px;
            }
            .debug-popup {
                width: 90%;
                max-width: 90%;
            }
            
            /* Maintain large circle size on smaller screens */
            .hourly-circle {
                r: 65; /* Slightly smaller on medium screens but still large */
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                text-align: center;
            }
            .title-section {
                flex-direction: column;
                align-items: center;
                width: 100%;
            }
            .filter-section {
                flex-direction: column;
                width: 100%;
            }
            .filter-select {
                width: 100%;
            }
            .date-time {
                text-align: center;
                margin-top: 8px;
            }
            .chart {
                height: 35vh;
                min-height: 250px;
            }
            .debug-popup {
                width: 95%;
                max-width: 95%;
            }
            .chart-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .hour-select-container {
                margin-left: 0;
                margin-top: 8px;
                width: 100%;
            }
            .hour-select {
                width: 100%;
            }
            
            /* Keep circles large on mobile */
            .hourly-circle {
                r: 50; /* Smaller on mobile but still large enough to be prominent */
            }
            
            /* Keep status icons visible on mobile */
            .status-icon {
                stroke-width: 10; /* Still thick enough to be visible on mobile */
            }
            .footer {
                flex-direction: column;
            }
            .current-time-indicator {
                margin-top: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <div class="title-section">
                <div>
                    <div class="title">Sinapi Secondary Production Dashboard</div>
                    <div class="subtitle">Medical Device Assembly</div>
                </div>
                <div class="filter-section">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
            </div>
            <div class="date-time">
                <div class="date" id="current-date">Loading...</div>
                <div class="time" id="current-time">Loading...</div>
                <div class="update-info" id="last-update">Last updated: Never</div>
                <button class="debug-button" onclick="showDebugPopup()">Show Debug Data</button>
                <button class="fullscreen-button" onclick="toggleFullscreen()">Fullscreen</button>
            </div>
        </div>

        <div class="content">
            <div class="info-row">
                <div class="product-supervisor-info">
                    <div class="product-name" id="product-name">Product: Loading...</div>
                    <div class="supervisor-name" id="supervisor-name">Line Supervisor: Loading...</div>
                    <div class="variant-sequence-label">VARIANT SEQUENCE:</div>
                    <div class="variant-sequence" id="variant-sequence">
                        <div class="loading">Loading variants...</div>
                    </div>
                </div>
                <div class="variant-details-box">
                    <div class="current-variant-header" id="current-variant-header">Current Variant: Loading...</div>
                    <div class="variant-period" id="variant-period">Time Period: --:-- to --:--</div>
                    <div class="variant-target" id="variant-target">Target: -- units (-- units/hour)</div>
                    <div class="variant-progress" id="variant-progress">Progress: --/-- (--%)
                    </div>
                </div>
            </div>

            <div class="totals-display" id="totals-display">
                <div class="loading">Loading data...</div>
            </div>

            <div class="chart-container">
                <div class="charts-row">
                    <div class="chart">
                        <div class="chart-title" id="cumulative-chart-title">Loading...</div>
                        <div class="chart-area">
                            <div class="line-chart" id="cumulative-chart"></div>
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-color production-color"></div>
                                    <div>Cumulative Production</div>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color target-color"></div>
                                    <div>Cumulative Target</div>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color transition-color"></div>
                                    <div>Variant Transition</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chart">
                        <div class="chart-header">
                            <div class="chart-title-text">
                                <select id="hour-range-select" class="chart-title-select">
                                    <!-- Time slots will be added dynamically -->
                                </select>
                                <span> Production Progress</span>
                            </div>
                            <div class="hour-info" id="hour-info">
                                <div class="hour-countdown"></div>
                            </div>
                        </div>
                        <div class="chart-area" style="margin-top: -15px;">
                            <div class="bar-chart" id="hourly-chart"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div class="update-info" id="last-update2">Last updated: Never</div>
            <div class="current-time-indicator">
                <div class="current-time-dot"></div>
                <span>Current time: <span id="current-time-display">--:--</span></span>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="debug-popup" id="debugPopup">
        <button class="close-btn" onclick="hideDebugPopup()">Close</button>
        <div class="debug-popup-content" id="debugPopupContent"></div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 60 * 1000;
        const CYCLE_INTERVAL = 20000;

        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        
        // New variables for product-supervisor grouping
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;

        function initDashboard() {
            updateDateTime();
            setInterval(updateDateTime, 1000);

            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            document.getElementById('hour-range-select').addEventListener('change', function() {
                selectedHour = this.value;
                updateHourlyChart();
            });

            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        // Function to check if a variant's end time has passed
        function isEndTimePassed(variant) {
            if (!variant || !variant.variantEndTime) return false;
            
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            const [endHour, endMinute] = variant.variantEndTime.split(':').map(Number);
            
            // Compare times
            if (currentHour > endHour || (currentHour === endHour && currentMinute > endMinute)) {
                return true; // End time has passed
            }
            
            return false; // End time hasn't passed yet
        }

        function toggleFullscreen() {
            const dashboard = document.querySelector('.dashboard-container');
            const fullscreenButton = document.querySelector('.fullscreen-button');

            if (!document.fullscreenElement && !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && !document.msFullscreenElement) {
                dashboard.classList.add('fullscreen-mode');
                isFullscreen = true;
                fullscreenButton.textContent = 'Exit Fullscreen';

                if (dashboard.requestFullscreen) dashboard.requestFullscreen();
                else if (dashboard.msRequestFullscreen) dashboard.msRequestFullscreen();
                else if (dashboard.mozRequestFullScreen) dashboard.mozRequestFullScreen();
                else if (dashboard.webkitRequestFullscreen) dashboard.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
            const dashboard = document.querySelector('.dashboard-container');
            const fullscreenButton = document.querySelector('.fullscreen-button');

            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                dashboard.classList.remove('fullscreen-mode');
                isFullscreen = false;
                fullscreenButton.textContent = 'Fullscreen';
            }

            // Redraw as needed
            setTimeout(updateDashboard, 100);
        }

        function applySupervisorStyling(supervisorName) {
            const dashboardContainer = document.querySelector('.dashboard-container');
            dashboardContainer.classList.remove('supervisor-luthando', 'supervisor-apelele', 'supervisor-siyabonga', 'supervisor-nosi', 'supervisor-mvokwe');
            if (supervisorName) {
                const supervisorClass = 'supervisor-' + supervisorName.toLowerCase();
                dashboardContainer.classList.add(supervisorClass);
            }
        }

        function updateHourDropdown() {
            const hourSelect = document.getElementById('hour-range-select');
            
            // Clear existing options
            while (hourSelect.options.length > 0) hourSelect.remove(0);
            
            // Get all production hours from all variants in the current group
            const productionHours = new Set();
            
            if (currentProductVariants.length > 0) {
                currentProductVariants.forEach(variant => {
                    // Get times from supervisor variant data
                    const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                    if (supervisor && supervisor.variants[variant.variant]) {
                        const variantData = supervisor.variants[variant.variant];
                        const hourlyData = variant.hourlyTargets || [];
                        
                        hourlyData.forEach(item => {
                            if (item.hour) productionHours.add(item.hour);
                        });
                    }
                });
            }
            
            // Use default hours if no production hours available
            if (productionHours.size === 0) {
                const defaultHours = ["08:30", "09:30", "10:30", "11:30", "12:30", "13:30", "14:30", "15:30", "16:30", "17:30", "18:30"];
                defaultHours.forEach(hour => productionHours.add(hour));
            }
            
            // Sort the hours
            const sortedHours = Array.from(productionHours).sort((a, b) => {
                const [ha, ma] = a.split(':').map(Number);
                const [hb, mb] = b.split(':').map(Number);
                return (ha * 60 + ma) - (hb * 60 + mb);
            });
            
            // Get current hour for "current" option
            const nextHour = getNextProductionHour(sortedHours);
            let currentHourOption = null;
            
            // Add time ranges as options
            sortedHours.forEach((hour, index) => {
                const [hourVal, minuteVal] = hour.split(':').map(Number);
                
                // Calculate previous hour (for start of range)
                let prevHour, prevMinute;
                
                if (index > 0) {
                    // If not the first hour, use the previous hour from our sorted list
                    const prevTimeStr = sortedHours[index - 1];
                    [prevHour, prevMinute] = prevTimeStr.split(':').map(Number);
                } else {
                    // For the first hour, calculate 1 hour before
                    prevHour = hourVal - 1;
                    prevMinute = minuteVal;
                    
                    // Handle the case when the first hour is before 1:00
                    if (prevHour < 0) {
                        prevHour = 23; // Wrap to previous day
                    }
                }
                
                // Format for option text
                const timeRange = `${prevHour.toString().padStart(2, '0')}:${prevMinute.toString().padStart(2, '0')}-${hourVal.toString().padStart(2, '0')}:${minuteVal.toString().padStart(2, '0')}`;
                
                const option = document.createElement('option');
                option.value = hour; // Store the end hour as value
                option.textContent = timeRange;
                
                // If this is the current hour range, save it for "current" option
                if (hour === nextHour) {
                    currentHourOption = { value: "current", text: timeRange };
                }
                
                hourSelect.appendChild(option);
            });
            
            // Add the "current" hour option at the top if it exists
            if (currentHourOption) {
                const currentOption = document.createElement('option');
                currentOption.value = currentHourOption.value;
                currentOption.textContent = currentHourOption.text;
                hourSelect.insertBefore(currentOption, hourSelect.firstChild);
            }
            
            // Set the selected hour in the dropdown
            if (selectedHour === "current" && currentHourOption) {
                hourSelect.value = "current";
            } else if (Array.from(hourSelect.options).some(opt => opt.value === selectedHour)) {
                hourSelect.value = selectedHour;
            } else if (hourSelect.options.length > 0) {
                selectedHour = hourSelect.options[0].value; // Default to first option
                hourSelect.value = selectedHour;
            }
        }

        function getNextProductionHour(productionHours) {
            const now = new Date();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            
            if (!productionHours || productionHours.length === 0) {
                productionHours = ["08:30", "09:30", "10:30", "11:30", "12:30", "13:30", "14:30", "15:30", "16:30", "17:30", "18:30"];
            }
            
            // Sort the production hours
            productionHours.sort((a, b) => {
                const [ha, ma] = a.split(':').map(Number);
                const [hb, mb] = b.split(':').map(Number);
                return (ha * 60 + ma) - (hb * 60 + mb);
            });
            
            // If current time is before the first production hour, return the first hour
            if (productionHours.length > 0) {
                const [firstHour, firstMinute] = productionHours[0].split(':').map(Number);
                const firstHourInMinutes = firstHour * 60 + firstMinute;
                
                if (currentTime < firstHourInMinutes) {
                    return productionHours[0];
                }
            }
            
            // Original logic for when we're within production hours
            for (const hourStr of productionHours) {
                const [hours, minutes] = hourStr.split(':').map(Number);
                const hourInMinutes = hours * 60 + minutes;
                if (hourInMinutes > currentTime) return hourStr;
            }
            
            // If current time is after all production hours, return the last hour
            return productionHours[productionHours.length - 1];
        }

        function calculateTimeToNextHour(hourStr) {
            const now = new Date();
            const [hours, minutes] = hourStr.split(':').map(Number);
            const targetTime = new Date(now);
            targetTime.setHours(hours, minutes, 0, 0);
            if (targetTime <= now) targetTime.setDate(targetTime.getDate() + 1);
            const diffMs = targetTime - now;
            const diffMinutes = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMinutes / 60);
            const remainingMinutes = diffMinutes % 60;
            return diffHours > 0 ? `Countdown Timer: ${diffHours}h ${remainingMinutes}m` : `Countdown Timer: ${remainingMinutes}m`;
        }

        function startCountdown(hourStr) {
            if (countdownInterval) clearInterval(countdownInterval);
            updateCountdown(hourStr);
            countdownInterval = setInterval(() => updateCountdown(hourStr), 60000);
        }

        function updateCountdown(hourStr) {
            document.querySelector('.hour-countdown').textContent = calculateTimeToNextHour(hourStr);
        }

        function calculateActualCycleTime(variants) {
            // For multiple variants, calculate a weighted average based on production
            let totalProduction = 0;
            let totalProductionTime = 0;
            
            variants.forEach(variant => {
                const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                if (supervisor && supervisor.variants[variant.variant]) {
                    const supervisorVariant = supervisor.variants[variant.variant];
                    
                    if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                        
                        if (startTimeStr && endTimeStr) {
                            const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                            const [endHours, endMinutes] = endTimeStr.split(':').map(Number);
                            
                            // Calculate time in minutes
                            let startMinutes = startHours * 60 + startMinutes;
                            let endMinutes = endHours * 60 + endMinutes;
                            
                            // Adjust if end is next day
                            if (endMinutes < startMinutes) {
                                endMinutes += 24 * 60;
                            }
                            
                            // Subtract breaks
                            const breakMinutes = calculateBreakMinutes(variant, startTimeStr, endTimeStr);
                            const workingMinutes = endMinutes - startMinutes - breakMinutes;
                            
                            // Add to totals
                            totalProduction += supervisorVariant.currentTotal;
                            totalProductionTime += workingMinutes * 60; // Convert to seconds
                        }
                    }
                }
            });
            
            if (totalProduction <= 0 || totalProductionTime <= 0) return "N/A";
            
            // Calculate overall cycle time
            return Math.round(totalProductionTime / totalProduction);
        }

        function calculateBreakMinutes(variant, startTimeStr, endTimeStr) {
            let totalBreakMinutes = 0;
            
            // Function to check if break is within working period
            const isBreakInWorkPeriod = (breakStartStr, breakEndStr) => {
                if (!breakStartStr || !breakEndStr) return false;
                
                const [workStartHour, workStartMinute] = startTimeStr.split(':').map(Number);
                const [workEndHour, workEndMinute] = endTimeStr.split(':').map(Number);
                const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
                const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
                
                const workStartMinutes = workStartHour * 60 + workStartMinute;
                const workEndMinutes = workEndHour * 60 + workEndMinute;
                const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
                const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
                
                // Check if break overlaps with work period
                return (breakStartMinutes >= workStartMinutes && breakStartMinutes < workEndMinutes) ||
                       (breakEndMinutes > workStartMinutes && breakEndMinutes <= workEndMinutes) ||
                       (breakStartMinutes <= workStartMinutes && breakEndMinutes >= workEndMinutes);
            };
            
            // Check each break
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"] &&
                isBreakInWorkPeriod(variant["Break Start (Lunch)"], variant["Break End (Lunch)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
            }
            
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"] &&
                isBreakInWorkPeriod(variant["Break Start (Tea)"], variant["Break End (Tea)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
            }
            
            if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-" &&
                isBreakInWorkPeriod(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
            }
            
            return totalBreakMinutes;
        }

        function getTimeDifferenceInMinutes(startTimeStr, endTimeStr) {
            const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
            const [endHours, endMinutes] = endTimeStr.split(':').map(Number);
            
            let startTotalMinutes = startHours * 60 + startMinutes;
            let endTotalMinutes = endHours * 60 + endMinutes;
            
            // Handle if break ends next day
            if (endTotalMinutes < startTotalMinutes) {
                endTotalMinutes += 24 * 60;
            }
            
            return endTotalMinutes - startTotalMinutes;
        }

        function extractProductFromVariant(variantName) {
            // Simple product extraction - assumes format "ProductName VariantName"
            const parts = variantName.split(' ');
            
            // Handle different formats
            if (parts.length === 1) return variantName; // No space, use as is
            if (parts.length === 2) return parts[0]; // Simple "Product Variant"
            
            // For more complex formats, try to find a pattern
            // Example: "LEVO XL1150SCi" -> "LEVO XL"
            const match = variantName.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            // Fallback: use first word
            return parts[0];
        }

        async function fetchProductionData() {
            try {
                console.log(`Attempting to fetch data from: ${DATA_URL}`);
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                console.log('Fetched data:', data);
                
                if (!data.variants || !Array.isArray(data.variants) || !data.supervisors || !Array.isArray(data.supervisors)) {
                    throw new Error('Invalid data structure in data.json');
                }
                
                if (!lastUpdateTime || lastUpdateTime !== data.timestamp) {
                    productionData = data;
                    lastUpdateTime = data.timestamp;
                    
                    // Update both last update displays
                    document.getElementById('last-update').textContent = 'Last updated: ' + data.timestamp;
                    document.getElementById('last-update2').textContent = 'Last updated: ' + data.timestamp;
                    
                    // Process product-supervisor groups from the new data
                    processProductSupervisorGroups();
                    
                    updateFilterValueDropdown();
                    updateDashboard();
                    updateHourDropdown();
                }
                
                isLoading = false;
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
                useLocalData();
            }
        }

        function processProductSupervisorGroups() {
            // Reset groups
            productSupervisorGroups = {};
            
            // First, create supervisor-product mapping
            productionData.supervisors.forEach(supervisor => {
                if (!supervisor.variants) return;
                
                // Create a temporary map of product -> variants
                const productVariants = {};
                
                // Process each variant
                Object.keys(supervisor.variants).forEach(variantKey => {
                    const product = extractProductFromVariant(variantKey);
                    
                    if (!productVariants[product]) {
                        productVariants[product] = [];
                    }
                    
                    // Find the variant in the variants array
                    const variantData = productionData.variants.find(v => v.variant === variantKey);
                    
                    if (variantData) {
                        productVariants[product].push({
                            variantKey,
                            variantData,
                            supervisorVariant: supervisor.variants[variantKey]
                        });
                    }
                });
                
                // Sort variants by start time and add to groups
                Object.keys(productVariants).forEach(product => {
                    const group = `${supervisor.name}:${product}`;
                    
                    // Sort variants by start time
                    const sortedVariants = productVariants[product].sort((a, b) => {
                        const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                        const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                        
                        const [hoursA, minutesA] = timeA.split(':').map(Number);
                        const [hoursB, minutesB] = timeB.split(':').map(Number);
                        
                        const totalMinutesA = hoursA * 60 + minutesA;
                        const totalMinutesB = hoursB * 60 + minutesB;
                        
                        return totalMinutesA - totalMinutesB;
                    });
                    
                    // Store in groups
                    productSupervisorGroups[group] = {
                        supervisor: supervisor.name,
                        product,
                        variants: sortedVariants.map(v => v.variantData),
                        supervisorData: supervisor
                    };
                });
            });
            
            console.log('Product-Supervisor Groups:', productSupervisorGroups);
        }

        function useLocalData() {
            if (document.querySelector('#local-data')) {
                const localData = JSON.parse(document.querySelector('#local-data').textContent);
                productionData = localData;
                lastUpdateTime = localData.timestamp;
                document.getElementById('last-update').textContent = 'Last updated: ' + localData.timestamp;
                document.getElementById('last-update2').textContent = 'Last updated: ' + localData.timestamp;
                processProductSupervisorGroups();
                updateFilterValueDropdown();
                updateDashboard();
            }
        }

        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear existing options (except 'all')
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.supervisors?.length > 0) {
                // Add all supervisors
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                // Add all unique products
                const uniqueProducts = new Set();
                
                // Extract products from all variants
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.product);
                });
                
                // Add options
                uniqueProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'variant' && productionData.variants?.length > 0) {
                // Add all unique variants
                const uniqueVariants = new Set(productionData.variants.map(v => v.variant));
                uniqueVariants.forEach(variantName => {
                    const option = document.createElement('option');
                    option.value = variantName;
                    option.textContent = variantName;
                    filterValueSelect.appendChild(option);
                });
            }
            
            // Restore previous selection if available, otherwise use 'all'
            filterValueSelect.value = Array.from(filterValueSelect.options).some(opt => opt.value === currentValue) 
                ? currentValue 
                : 'all';
                
            selectedFilterValue = filterValueSelect.value;
        }

        function updateDashboard() {
            // Filter groups based on selection
            let filteredGroups = {};
            
            if (selectedFilterValue === 'all') {
                filteredGroups = productSupervisorGroups;
            } else if (selectedFilterType === 'supervisor') {
                // Filter by supervisor
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].supervisor === selectedFilterValue) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'product') {
                // Filter by product
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].product === selectedFilterValue) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'variant') {
                // Filter by variant
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    if (group.variants.some(v => v.variant === selectedFilterValue)) {
                        filteredGroups[key] = group;
                    }
                });
            }
            
            // If no groups after filtering, show error
            if (Object.keys(filteredGroups).length === 0) {
                showLoadingOrError('No data available for this filter.');
                return;
            }
            
            // Select first group to display
            const firstGroupKey = Object.keys(filteredGroups)[0];
            const selectedGroup = filteredGroups[firstGroupKey];
            
            // Set current product and supervisor
            currentProduct = selectedGroup.product;
            currentSupervisor = selectedGroup.supervisor;
            currentProductVariants = selectedGroup.variants;
            
            // Find current variant
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Sort variants by start time
            const sortedVariants = [...currentProductVariants].sort((a, b) => {
                const supervisorA = selectedGroup.supervisorData.variants[a.variant];
                const supervisorB = selectedGroup.supervisorData.variants[b.variant];
                
                const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                
                const [hoursA, minutesA] = timeA.split(':').map(Number);
                const [hoursB, minutesB] = timeB.split(':').map(Number);
                
                return (hoursA * 60 + minutesA) - (hoursB * 60 + minutesB);
            });
            
            // Find the current active variant
            let currentVariantIndex = -1;
            
            for (let i = 0; i < sortedVariants.length; i++) {
                const variant = sortedVariants[i];
                const supervisorVariant = selectedGroup.supervisorData.variants[variant.variant];
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) continue;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Check if current time is within this variant's window
                if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                    currentVariantIndex = i;
                    break;
                }
            }
            
            // If no current variant found, use last variant
            if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                currentVariantIndex = sortedVariants.length - 1;
            }
            
            // Set current variant
            currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
            
            // Apply styling based on supervisor
            applySupervisorStyling(currentSupervisor);
            
            // Update UI
            updateProductSupervisorInfo(selectedGroup);
            updateCurrentVariantDetails(
                currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex] : null,
                selectedGroup.supervisorData
            );
            updateTotalsDisplay(selectedGroup);
            renderCumulativeChart(selectedGroup);
            updateHourlyChart();
            updateHourDropdown();
        }

        function updateProductSupervisorInfo(group) {
            document.getElementById('product-name').textContent = `Product: ${group.product}`;
            document.getElementById('supervisor-name').textContent = `Line Supervisor: ${group.supervisor}`;
            
            // Update variant sequence
            const sequenceContainer = document.getElementById('variant-sequence');
            sequenceContainer.innerHTML = '';
            
            if (group.variants.length === 0) {
                sequenceContainer.innerHTML = '<div>No variants available</div>';
                return;
            }
            
            // Get current time to determine variant status
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Add each variant to the sequence
            group.variants.forEach((variant, index) => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Determine variant status
                let status = '';
                if (currentTimeMinutes < startTimeMinutes) {
                    status = 'upcoming';
                } else if (currentTimeMinutes > endTimeMinutes) {
                    status = 'completed';
                } else {
                    status = 'current';
                }
                
                // Extract variant name from full variant string
                let displayName = variant.variant;
                
                // Try to extract just the variant part
                if (variant.variant.startsWith(group.product + ' ')) {
                    displayName = variant.variant.substring(group.product.length + 1);
                }
                
                // Create variant element
                const variantElement = document.createElement('div');
                variantElement.className = `variant-item ${status}`;
                variantElement.innerHTML = `
                    <span>${displayName}</span>
                    <span class="variant-time">${startTimeStr}-${endTimeStr}</span>
                    <span class="variant-status">${status.toUpperCase()}</span>
                `;
                
                sequenceContainer.appendChild(variantElement);
                
                // Add arrow if not the last variant
                if (index < group.variants.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-right';
                    arrow.textContent = '→';
                    sequenceContainer.appendChild(arrow);
                }
            });
        }

        function updateCurrentVariantDetails(variant, supervisorData) {
            const headerElement = document.getElementById('current-variant-header');
            const periodElement = document.getElementById('variant-period');
            const targetElement = document.getElementById('variant-target');
            const progressElement = document.getElementById('variant-progress');
            
            if (!variant || !supervisorData.variants[variant.variant]) {
                headerElement.textContent = 'No Current Variant';
                periodElement.textContent = 'Time Period: --:-- to --:--';
                targetElement.textContent = 'Target: -- units (-- units/hour)';
                progressElement.textContent = 'Progress: --/-- (--%)'
                return;
            }
            
            const supervisorVariant = supervisorData.variants[variant.variant];
            
            // Get variant details
            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
            const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
            const actualWorkHours = supervisorVariant.actualWorkHours || 
                                   (variant.totalavailableWorkHours || 8);
            
            const dailyTarget = supervisorVariant.dailyTarget || variant.dailyTarget || 0;
            const currentTotal = supervisorVariant.currentTotal || 0;
            const progressPercentage = supervisorVariant.progressPercentage || 0;
            
            // Calculate hourly rate
            const hourlyRate = actualWorkHours > 0 ? Math.round(dailyTarget / actualWorkHours) : 0;
            
            // Update UI
            headerElement.textContent = `Current Variant: ${variant.variant}`;
            periodElement.textContent = `Time Period: ${startTimeStr} to ${endTimeStr} (${actualWorkHours.toFixed(1)} hrs)`;
            targetElement.textContent = `Target: ${dailyTarget} units (${hourlyRate} units/hour)`;
            progressElement.textContent = `Progress: ${currentTotal}/${dailyTarget} (${progressPercentage}%)`;
        }

        function updateTotalsDisplay(group) {
            // Initialize aggregated values
            let totalTarget = 0;
            let totalProduction = 0;
            let totalBoxTarget = 0;
            let totalBoxProduction = 0;
            let weightedCycleTime = 0;
            let totalCycleTimeWeight = 0;
            
            // Calculate aggregated values
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                    totalProduction += (supervisorVariant.currentTotal || 0);
                    
                    // Add cycle time weighted by target
                    const cycleTime = variant.cycleTime || 0;
                    const target = supervisorVariant.dailyTarget || 0;
                    
                    if (cycleTime > 0 && target > 0) {
                        weightedCycleTime += cycleTime * target;
                        totalCycleTimeWeight += target;
                    }
                }
                
                // Box targets may not be in supervisor data, use variant data
                totalBoxTarget += (variant.dailyBoxTarget || 0);
                totalBoxProduction += (variant.currentBoxTotal || 0);
            });
            
            // Calculate overall progress percentage
            const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            // Calculate average cycle time
            const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
            
            // Calculate actual cycle time across all variants
            const actualCycleTime = calculateActualCycleTime(group.variants);
            
            // Update totals display
            const totalsDisplay = document.getElementById('totals-display');
            totalsDisplay.innerHTML = '';
            
            // Progress display with percentage
            totalsDisplay.innerHTML += `
                <div class="total-item">
                    <div class="total-label">
                        Progress <span class="total-percentage">${progressPercentage}%</span>
                    </div>
                    <div class="total-value">
                        <span class="current-value">${totalProduction}</span>/<span class="target-value">${totalTarget}</span>
                    </div>
                    <div class="total-subvalue">
                        <span class="current-value">${totalBoxProduction}</span>/<span class="target-value">${totalBoxTarget}</span> boxes
                    </div>
                </div>
            `;
            
            // Cycle Time display
            totalsDisplay.innerHTML += `
                <div class="total-item">
                    <div class="total-label">Cycle Time</div>
                    <div class="total-value">
                        <span class="current-value">${actualCycleTime}</span>/<span class="target-value">${avgCycleTime}</span>
                    </div>
                    <div class="total-subvalue">sec/unit</div>
                </div>
            `;
            
            // Hourly targets visual display
            const hourlyTargetsContainer = document.createElement('div');
            hourlyTargetsContainer.className = 'total-item';
            hourlyTargetsContainer.style.height = 'auto';
            hourlyTargetsContainer.style.paddingTop = '0';
            hourlyTargetsContainer.innerHTML = `<div class="total-label">Hourly Targets</div>`;
            
            // Create SVG for hourly targets
            const hourlyTargetsContent = renderHourlyTargetsVisual(group);
            hourlyTargetsContainer.appendChild(hourlyTargetsContent);
            
            totalsDisplay.appendChild(hourlyTargetsContainer);
        }

        function renderHourlyTargetsVisual(group) {
            // Create container
            const container = document.createElement('div');
            container.className = 'hourly-targets-container';
            container.style.marginTop = '-25px';
            
            // Get all hourly targets and production for this product group
            const hourlyTargetsMap = new Map();
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentTimeMinutes = currentHour * 60 + currentMinute;
            
            // Combine hourly data from all variants
            group.variants.forEach(variant => {
                // Get variant time window
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Process hourly targets
                if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                    variant.hourlyTargets.forEach(item => {
                        if (!item.hour) return;
                        
                        // Check if this hour is within this variant's time window
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            hourlyTargetsMap.set(item.hour, {
                                hour: item.hour,
                                target: item.target || 0,
                                production: 0,
                                metTarget: false,
                                variant: variant.variant
                            });
                        }
                    });
                }
                
                // Process hourly production
                if (variant.hourlyProduction && Array.isArray(variant.hourlyProduction)) {
                    variant.hourlyProduction.forEach(item => {
                        if (!item.hour) return;
                        
                        // Check if this hour is within this variant's time window
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            if (hourlyTargetsMap.has(item.hour)) {
                                const hourData = hourlyTargetsMap.get(item.hour);
                                hourData.production = item.production || 0;
                                hourData.metTarget = hourData.production >= hourData.target;
                            } else {
                                hourlyTargetsMap.set(item.hour, {
                                    hour: item.hour,
                                    target: 0,
                                    production: item.production || 0,
                                    metTarget: true,
                                    variant: variant.variant
                                });
                            }
                        }
                    });
                }
            });
            
            // Sort hours
            const hours = Array.from(hourlyTargetsMap.keys()).sort((a, b) => {
                const [hourA, minuteA] = a.split(':').map(Number);
                const [hourB, minuteB] = b.split(':').map(Number);
                return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
            });
            
            // Find which hour is current
            let currentHourIndex = -1;
            for (let i = 0; i < hours.length; i++) {
                const [hour, minute] = hours[i].split(':').map(Number);
                const hourMinutes = hour * 60 + minute;
                
                const prevHourMinutes = i > 0 ? 
                    hours[i-1].split(':').map(Number).reduce((h, m) => h * 60 + m, 0) :
                    0;
                
                if (currentTimeMinutes >= prevHourMinutes && currentTimeMinutes < hourMinutes) {
                    currentHourIndex = i;
                    break;
                }
            }
            
            // If not found but time is after last hour, use last hour
            if (currentHourIndex === -1 && hours.length > 0) {
                const lastHourTime = hours[hours.length - 1].split(':').map(Number);
                const lastHourMinutes = lastHourTime[0] * 60 + lastHourTime[1];
                if (currentTimeMinutes >= lastHourMinutes) {
                    currentHourIndex = hours.length - 1;
                }
            }
            
            // Create SVG for visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'hourly-targets-svg');
            svg.setAttribute('height', '180');
            svg.setAttribute('viewBox', `0 0 ${Math.max(hours.length * 180, 400)} 180`);
            
            // Calculate spacing
            const circleRadius = 80;
            const spacing = 160;
            const yPosition = 60;
            
            // Draw each hour circle
            hours.forEach((hour, index) => {
                const hourData = hourlyTargetsMap.get(hour);
                const xPosition = index * spacing + 80;
                
                // Circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'hourly-circle');
                circle.setAttribute('cx', xPosition);
                circle.setAttribute('cy', yPosition);
                circle.setAttribute('r', circleRadius);
                svg.appendChild(circle);
                
                // Time label
                const timeLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                timeLabel.setAttribute('class', 'time-label');
                timeLabel.setAttribute('x', xPosition);
                timeLabel.setAttribute('y', yPosition + circleRadius + 25);
                timeLabel.setAttribute('font-size', '1.9');
                timeLabel.textContent = hour;
                svg.appendChild(timeLabel);
                
                // Status indicator
                if (hourData) {
                    if (hourData.metTarget) {
                        // Check mark
                        const checkmark = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        checkmark.setAttribute('class', 'status-icon status-success');
                        checkmark.setAttribute('d', `M${xPosition - 35},${yPosition} L${xPosition - 10},${yPosition + 25} L${xPosition + 35},${yPosition - 25}`);
                        checkmark.setAttribute('fill', 'none');
                        svg.appendChild(checkmark);
                    } else {
                        // X mark
                        const xMark1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        xMark1.setAttribute('class', 'status-icon status-fail');
                        xMark1.setAttribute('x1', xPosition - 35);
                        xMark1.setAttribute('y1', yPosition - 35);
                        xMark1.setAttribute('x2', xPosition + 35);
                        xMark1.setAttribute('y2', yPosition + 35);
                        xMark1.setAttribute('stroke-linecap', 'round');
                        svg.appendChild(xMark1);
                        
                        const xMark2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        xMark2.setAttribute('class', 'status-icon status-fail');
                        xMark2.setAttribute('x1', xPosition - 35);
                        xMark2.setAttribute('y1', yPosition + 35);
                        xMark2.setAttribute('x2', xPosition + 35);
                        xMark2.setAttribute('y2', yPosition - 35);
                        xMark2.setAttribute('stroke-linecap', 'round');
                        svg.appendChild(xMark2);
                    }
                }
                
                // Current hour indicator
                if (index === currentHourIndex) {
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    arrow.setAttribute('class', 'current-arrow');
                    arrow.setAttribute('d', `M${xPosition - 35},${yPosition - 85} L${xPosition},${yPosition - 50} L${xPosition + 35},${yPosition - 85} Z`);
                    svg.appendChild(arrow);
                }
            });
            
            container.appendChild(svg);
            return container;
        }

        function renderCumulativeChart(group) {
            const chartContainer = document.getElementById('cumulative-chart');
            const chartTitle = document.getElementById('cumulative-chart-title');
            chartContainer.innerHTML = '';
            
            const currentDay = new Date().toLocaleDateString('en-US', { weekday: 'long' });
            chartTitle.textContent = `${currentDay}'s Production Progress`;
            
            // Collect all variants' production and target data
            const allCumulativeData = [];
            const variantTransitions = [];
            
            // Collect all hours across all variants
            const allHoursSet = new Set();
            
            // Get variant time windows
            const variantTimeWindows = [];
            
            // Process each variant
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (!supervisorVariant) return;
                
                // Get variant time window
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Add to variant time windows
                variantTimeWindows.push({
                    variant: variant.variant,
                    startTimeStr,
                    endTimeStr,
                    startTimeMinutes,
                    endTimeMinutes
                });
                
                // Add variant transition markers
                if (variantTimeWindows.length > 1) {
                    variantTransitions.push(startTimeStr);
                }
                
                // Get cumulative data for this variant
                if (variant.cumulativeTargets) {
                    variant.cumulativeTargets.forEach(item => {
                        if (!item.hour) return;
                        
                        // Check if this hour is within this variant's time window
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            allHoursSet.add(item.hour);
                            
                            allCumulativeData.push({
                                hour: item.hour,
                                target: item.target || 0,
                                production: 0,
                                variant: variant.variant,
                                timeMinutes: itemTimeMinutes
                            });
                        }
                    });
                }
                
                if (variant.cumulativeProduction) {
                    variant.cumulativeProduction.forEach(item => {
                        if (!item.hour) return;
                        
                        // Check if this hour is within this variant's time window
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            allHoursSet.add(item.hour);
                            
                            // Find matching target entry
                            const targetEntry = allCumulativeData.find(d => 
                                d.hour === item.hour && d.variant === variant.variant);
                            
                            if (targetEntry) {
                                targetEntry.production = item.production || 0;
                            } else {
                                allCumulativeData.push({
                                    hour: item.hour,
                                    target: 0,
                                    production: item.production || 0,
                                    variant: variant.variant,
                                    timeMinutes: itemTimeMinutes
                                });
                            }
                        }
                    });
                }
            });
            
            // Sort all data by time
            allCumulativeData.sort((a, b) => a.timeMinutes - b.timeMinutes);
            
            if (allCumulativeData.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
                return;
            }
            
            // Filter data to only show up to current time plus buffer
            const now = new Date();
            const currentMinuteOfDay = now.getHours() * 60 + now.getMinutes();
            const currentTimePlusBuffer = currentMinuteOfDay + 30;
            
            const filteredData = allCumulativeData.filter(item => item.timeMinutes <= currentTimePlusBuffer);
            
            if (filteredData.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available for current time period</div>';
                return;
            }
            
            // Find max value for chart scaling
            const maxValue = Math.max(
                ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
            ) * 1.1;
            
            // Set up chart dimensions
            const svgWidth = chartContainer.clientWidth || 600;
            const svgHeight = chartContainer.clientHeight || 370;
            const padding = commonChartPadding;
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            chartContainer.appendChild(svg);
            
            // Add grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            
            // Add y-axis title
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 45);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 45}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            gridGroup.appendChild(yAxisTitle);
            
            // Add y-axis line
            const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            startLine.setAttribute('x1', padding.left);
            startLine.setAttribute('y1', padding.top);
            startLine.setAttribute('x2', padding.left);
            startLine.setAttribute('y2', svgHeight - padding.bottom);
            startLine.setAttribute('stroke', '#666');
            startLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(startLine);
            
            // Add x-axis line
            const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine.setAttribute('x1', padding.left);
            xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
            xAxisLine.setAttribute('x2', svgWidth - padding.right);
            xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
            xAxisLine.setAttribute('stroke', '#666');
            xAxisLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxisLine);
            svg.appendChild(gridGroup);
            
            // Add x-axis labels with variant info
            const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const uniqueHours = [...new Set(filteredData.map(item => item.hour))].sort((a, b) => {
                const [hourA, minuteA] = a.split(':').map(Number);
                const [hourB, minuteB] = b.split(':').map(Number);
                return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
            });
            
            uniqueHours.forEach((hour, index) => {
                const x = padding.left + (chartWidth * index / (uniqueHours.length - 1 || 1));
                const y = svgHeight - padding.bottom + 20;
                
                // Add tick mark
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', svgHeight - padding.bottom);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', svgHeight - padding.bottom + 5);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                xLabelsGroup.appendChild(tick);
                
                // Add hour label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#666');
                text.textContent = hour;
                xLabelsGroup.appendChild(text);
                
                // Add variant transition markers
                if (variantTransitions.includes(hour)) {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    marker.setAttribute('class', 'transition-marker');
                    marker.setAttribute('x1', x);
                    marker.setAttribute('y1', padding.top);
                    marker.setAttribute('x2', x);
                    marker.setAttribute('y2', svgHeight - padding.bottom);
                    marker.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)');
                    marker.setAttribute('stroke-width', '2');
                    marker.setAttribute('stroke-dasharray', '5,3');
                    xLabelsGroup.appendChild(marker);
                }
                
                // Add variant label below the hour
                const variantItem = filteredData.find(item => item.hour === hour);
                if (variantItem) {
                    const variantLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    variantLabel.setAttribute('class', 'variant-label');
                    variantLabel.setAttribute('x', x);
                    variantLabel.setAttribute('y', y + 15);
                    variantLabel.setAttribute('text-anchor', 'middle');
                    variantLabel.setAttribute('font-size', '10');
                    variantLabel.setAttribute('fill', '#666');
                    
                    // Extract variant name from full string
                    let displayName = variantItem.variant;
                    if (variantItem.variant.startsWith(currentProduct + ' ')) {
                        displayName = variantItem.variant.substring(currentProduct.length + 1);
                    }
                    // Extract variant name from full string
                    let displayName = variantItem.variant;
                    if (variantItem.variant.startsWith(currentProduct + ' ')) {
                        displayName = variantItem.variant.substring(currentProduct.length + 1);
                    }
                    
                    variantLabel.textContent = displayName;
                    xLabelsGroup.appendChild(variantLabel);
                }
            });
            svg.appendChild(xLabelsGroup);
            
            // Draw production line
            const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            let productionPathD = '';
            const productionPoints = [];
            
            uniqueHours.forEach((hour, index) => {
                // Get combined production for this hour
                const production = filteredData
                    .filter(item => item.hour === hour)
                    .reduce((sum, item) => sum + (item.production || 0), 0);
                
                const x = padding.left + (chartWidth * index / (uniqueHours.length - 1 || 1));
                const y = padding.top + chartHeight - (chartHeight * (production / maxValue));
                
                productionPoints.push({ x, y, production });
                productionPathD += index === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
            });
            
            // Add production line
            const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            productionPath.setAttribute('d', productionPathD);
            productionPath.setAttribute('stroke', 'var(--production-color)');
            productionPath.setAttribute('stroke-width', '3');
            productionPath.setAttribute('fill', 'none');
            productionLineGroup.appendChild(productionPath);
            
            // Add production points and labels
            productionPoints.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', 'var(--production-color)');
                productionLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 10);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', 'var(--production-color)');
                text.textContent = point.production;
                productionLineGroup.appendChild(text);
            });
            svg.appendChild(productionLineGroup);
            
            // Draw target line
            const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            let targetPathD = '';
            const targetPoints = [];
            
            uniqueHours.forEach((hour, index) => {
                // Get combined target for this hour
                const target = filteredData
                    .filter(item => item.hour === hour)
                    .reduce((sum, item) => sum + (item.target || 0), 0);
                
                const x = padding.left + (chartWidth * index / (uniqueHours.length - 1 || 1));
                const y = padding.top + chartHeight - (chartHeight * (target / maxValue));
                
                targetPoints.push({ x, y, target });
                targetPathD += index === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
            });
            
            // Add target line
            const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            targetPath.setAttribute('d', targetPathD);
            targetPath.setAttribute('stroke', 'var(--target-color)');
            targetPath.setAttribute('stroke-width', '3');
            targetPath.setAttribute('fill', 'none');
            targetLineGroup.appendChild(targetPath);
            
            // Add target points and labels
            targetPoints.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', 'var(--target-color)');
                targetLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 10);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', 'var(--target-color)');
                text.textContent = point.target;
                targetLineGroup.appendChild(text);
            });
            svg.appendChild(targetLineGroup);
            
            // Add variant transition markers
            variantTransitions.forEach(transitionHour => {
                const index = uniqueHours.indexOf(transitionHour);
                if (index >= 0) {
                    const x = padding.left + (chartWidth * index / (uniqueHours.length - 1 || 1));
                    
                    const transitionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    transitionLine.setAttribute('x1', x);
                    transitionLine.setAttribute('y1', padding.top);
                    transitionLine.setAttribute('x2', x);
                    transitionLine.setAttribute('y2', svgHeight - padding.bottom);
                    transitionLine.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)');
                    transitionLine.setAttribute('stroke-width', '2');
                    transitionLine.setAttribute('stroke-dasharray', '5,3');
                    svg.appendChild(transitionLine);
                }
            });
        }

        function updateHourlyChart() {
            const chartContainer = document.getElementById('hourly-chart');
            chartContainer.innerHTML = '';
            
            if (!currentProductVariants || currentProductVariants.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
                return;
            }
            
            // Determine which hour to display
            let displayHour;
            if (selectedHour === 'current') {
                // For current hour option, get next production hour
                const allHours = new Set();
                currentProductVariants.forEach(variant => {
                    if (variant.hourlyTargets) {
                        variant.hourlyTargets.forEach(item => {
                            if (item.hour) allHours.add(item.hour);
                        });
                    }
                });
                
                displayHour = getNextProductionHour(Array.from(allHours));
            } else {
                // For specific hour selection
                displayHour = selectedHour;
            }
            
            // Find all variants active during this hour
            const activeVariants = [];
            const hourlyData = { target: 0, production: 0 };
            
            // Get the hour's time in minutes
            const [hourVal, minuteVal] = displayHour.split(':').map(Number);
            const hourTimeMinutes = hourVal * 60 + minuteVal;
            
            // Show countdown for current hour if appropriate
            if (selectedHour === 'current') {
                startCountdown(displayHour);
            } else {
                if (countdownInterval) clearInterval(countdownInterval);
                document.querySelector('.hour-countdown').textContent = '';
            }
            
            // Process all variants to find those active during this hour
            currentProductVariants.forEach(variant => {
                const supervisorVariant = currentSupervisor ? 
                    productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Check if this hour falls within this variant's window
                if (hourTimeMinutes >= startTimeMinutes && hourTimeMinutes <= endTimeMinutes) {
                    activeVariants.push(variant);
                    
                    // Add target and production data
                    if (variant.hourlyTargets) {
                        const targetData = variant.hourlyTargets.find(item => item.hour === displayHour);
                        if (targetData) {
                            hourlyData.target += targetData.target || 0;
                        }
                    }
                    
                    if (variant.hourlyProduction) {
                        const productionData = variant.hourlyProduction.find(item => item.hour === displayHour);
                        if (productionData) {
                            hourlyData.production += productionData.production || 0;
                        }
                    }
                }
            });
            
            // If no variants are active during this hour, show message
            if (activeVariants.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No variants active during this hour</div>';
                return;
            }
            
            // Draw hourly chart
            const svgWidth = chartContainer.clientWidth || 600;
            const svgHeight = chartContainer.clientHeight || 370;
            const padding = commonChartPadding;
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            chartContainer.appendChild(svg);
            
            const maxValue = Math.max(hourlyData.production, hourlyData.target, 1) * 1.2;
            
            // Add grid
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            
            // Add y-axis title
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 45);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 45}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            gridGroup.appendChild(yAxisTitle);
            
            // Add axes
            const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vLine.setAttribute('x1', padding.left);
            vLine.setAttribute('y1', padding.top);
            vLine.setAttribute('x2', padding.left);
            vLine.setAttribute('y2', svgHeight - padding.bottom);
            vLine.setAttribute('stroke', '#666');
            vLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(vLine);
            
            const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine.setAttribute('x1', padding.left);
            xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
            xAxisLine.setAttribute('x2', svgWidth - padding.right);
            xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
            xAxisLine.setAttribute('stroke', '#666');
            xAxisLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxisLine);
            svg.appendChild(gridGroup);
            
            // Draw bars
            const barWidth = 60;
            const barSpacing = 40;
            const startX = svgWidth / 2 - barWidth - barSpacing / 2;
            
            // Production bar
            const productionBarHeight = (hourlyData.production / maxValue) * chartHeight;
            const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            productionBar.setAttribute('x', startX);
            productionBar.setAttribute('y', padding.top + chartHeight - productionBarHeight);
            productionBar.setAttribute('width', barWidth);
            productionBar.setAttribute('height', productionBarHeight);
            productionBar.setAttribute('fill', 'var(--production-color)');
            productionBar.setAttribute('rx', '4');
            svg.appendChild(productionBar);
            
            // Target bar
            const targetBarHeight = (hourlyData.target / maxValue) * chartHeight;
            const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetBar.setAttribute('x', startX + barWidth + barSpacing);
            targetBar.setAttribute('y', padding.top + chartHeight - targetBarHeight);
            targetBar.setAttribute('width', barWidth);
            targetBar.setAttribute('height', targetBarHeight);
            targetBar.setAttribute('fill', 'var(--target-color)');
            targetBar.setAttribute('rx', '4');
            svg.appendChild(targetBar);
            
            // Add production value text
            const productionValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            productionValueText.setAttribute('x', startX + barWidth / 2);
            productionValueText.setAttribute('y', padding.top + chartHeight - productionBarHeight - 10);
            productionValueText.setAttribute('text-anchor', 'middle');
            productionValueText.setAttribute('font-size', '15');
            productionValueText.setAttribute('font-weight', '600');
            productionValueText.setAttribute('fill', 'var(--production-color)');
            productionValueText.textContent = hourlyData.production;
            svg.appendChild(productionValueText);
            
            // Add target value text
            const targetValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetValueText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
            targetValueText.setAttribute('y', padding.top + chartHeight - targetBarHeight - 10);
            targetValueText.setAttribute('text-anchor', 'middle');
            targetValueText.setAttribute('font-size', '15');
            targetValueText.setAttribute('font-weight', '600');
            targetValueText.setAttribute('fill', 'var(--target-color)');
            targetValueText.textContent = hourlyData.target;
            svg.appendChild(targetValueText);
            
            // Add labels
            const productionLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            productionLabelText.setAttribute('x', startX + barWidth / 2);
            productionLabelText.setAttribute('y', svgHeight - padding.bottom + 25);
            productionLabelText.setAttribute('text-anchor', 'middle');
            productionLabelText.setAttribute('font-size', '13');
            productionLabelText.setAttribute('font-weight', '500');
            productionLabelText.setAttribute('fill', 'var(--production-color)');
            productionLabelText.textContent = 'Production';
            svg.appendChild(productionLabelText);
            
            const targetLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLabelText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
            targetLabelText.setAttribute('y', svgHeight - padding.bottom + 25);
            targetLabelText.setAttribute('text-anchor', 'middle');
            targetLabelText.setAttribute('font-size', '13');
            targetLabelText.setAttribute('font-weight', '500');
            targetLabelText.setAttribute('fill', 'var(--target-color)');
            targetLabelText.textContent = 'Target';
            svg.appendChild(targetLabelText);
            
            // X axis line
            const xAxisLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine2.setAttribute('x1', padding.left);
            xAxisLine2.setAttribute('y1', padding.top + chartHeight);
            xAxisLine2.setAttribute('x2', svgWidth - padding.right);
            xAxisLine2.setAttribute('y2', padding.top + chartHeight);
            xAxisLine2.setAttribute('stroke', '#666');
            xAxisLine2.setAttribute('stroke-width', '1.5');
            svg.appendChild(xAxisLine2);
            
            // Update hour select dropdown
            const select = document.getElementById('hour-range-select');
            select.value = selectedHour === 'current' ? 'current' : displayHour;
            
            // Add active variants list
            if (activeVariants.length > 1) {
                const activeVariantsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                activeVariantsText.setAttribute('x', svgWidth / 2);
                activeVariantsText.setAttribute('y', padding.top + chartHeight + 35);
                activeVariantsText.setAttribute('text-anchor', 'middle');
                activeVariantsText.setAttribute('font-size', '12');
                activeVariantsText.setAttribute('fill', '#666');
                
                const variantNames = activeVariants.map(v => {
                    // Extract variant name from full string
                    let displayName = v.variant;
                    if (v.variant.startsWith(currentProduct + ' ')) {
                        displayName = v.variant.substring(currentProduct.length + 1);
                    }
                    return displayName;
                });
                
                activeVariantsText.textContent = `Active variants: ${variantNames.join(', ')}`;
                svg.appendChild(activeVariantsText);
            }
        }

        function updateDateTime() {
            const now = new Date();
            document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', {
                month: 'long', day: 'numeric', year: 'numeric'
            });
            
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            document.getElementById('current-time-display').textContent = timeString.substring(0, 5);
            
            // Check if we need to update dashboard based on time changes (variant transitions)
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                // Check if we crossed a variant boundary
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if we just crossed this boundary
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }

        function showLoadingOrError(message) {
            const totalsDisplay = document.getElementById('totals-display');
            totalsDisplay.innerHTML = `<div class="${isLoading ? 'loading' : 'error'}">${message}</div>`;
            
            document.getElementById('product-name').textContent = 'Product: Loading...';
            document.getElementById('supervisor-name').textContent = 'Line Supervisor: Loading...';
            document.getElementById('variant-sequence').innerHTML = '<div class="loading">Loading variants...</div>';
            document.getElementById('current-variant-header').textContent = 'Current Variant: Loading...';
            document.getElementById('variant-period').textContent = 'Time Period: --:-- to --:--';
            document.getElementById('variant-target').textContent = 'Target: -- units (-- units/hour)';
            document.getElementById('variant-progress').textContent = 'Progress: --/-- (--%)'
            
            document.querySelectorAll('.line-chart, .bar-chart').forEach(chart => {
                chart.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
            });
        }

        function showDebugPopup() {
            const popupContent = document.getElementById('debugPopupContent');
            
            // Get current group data
            const currentGroup = currentProduct && currentSupervisor ? 
                productSupervisorGroups[`${currentSupervisor}:${currentProduct}`] : null;
            
            if (!currentGroup) {
                popupContent.innerHTML = '<h3>No data available for debugging</h3>';
                document.getElementById('debugPopup').classList.add('show');
                document.getElementById('overlay').classList.add('show');
                return;
            }
            
            // Build debug info
            let debugHtml = `
                <h3>Product-Supervisor Group: ${currentSupervisor} - ${currentProduct}</h3>
                <h4>Variants in Sequence:</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Variant</th>
                            <th>Start Time</th>
                            <th>End Time</th>
                            <th>Work Hours</th>
                            <th>Target</th>
                            <th>Production</th>
                            <th>Progress</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add variant data
            currentGroup.variants.forEach(variant => {
                const supervisorVariant = currentGroup.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    const startTime = supervisorVariant.variantStartTime || variant["Start Time"] || "N/A";
                    const endTime = supervisorVariant.variantEndTime || variant["End Time"] || "N/A";
                    const workHours = supervisorVariant.actualWorkHours || variant.totalavailableWorkHours || "N/A";
                    const target = supervisorVariant.dailyTarget || variant.dailyTarget || 0;
                    const production = supervisorVariant.currentTotal || 0;
                    const progress = supervisorVariant.progressPercentage || 0;
                    
                    debugHtml += `
                        <tr>
                            <td>${variant.variant}</td>
                            <td>${startTime}</td>
                            <td>${endTime}</td>
                            <td>${typeof workHours === 'number' ? workHours.toFixed(1) : workHours}</td>
                            <td>${target}</td>
                            <td>${production}</td>
                            <td>${progress}%</td>
                        </tr>
                    `;
                }
            });
            
            debugHtml += `
                    </tbody>
                </table>
            `;
            
            // Add aggregate data
            let totalTarget = 0;
            let totalProduction = 0;
            
            currentGroup.variants.forEach(variant => {
                const supervisorVariant = currentGroup.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                    totalProduction += (supervisorVariant.currentTotal || 0);
                }
            });
            
            const overallProgress = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            debugHtml += `
                <h4>Aggregated Data:</h4>
                <table>
                    <tr><th>Total Target</th><td>${totalTarget}</td></tr>
                    <tr><th>Total Production</th><td>${totalProduction}</td></tr>
                    <tr><th>Overall Progress</th><td>${overallProgress}%</td></tr>
                </table>
            `;
            
            // Add current time info
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            debugHtml += `
                <h4>Current Time Info:</h4>
                <table>
                    <tr><th>Current Time</th><td>${now.toLocaleTimeString('en-US', { hour12: false })}</td></tr>
                    <tr><th>Current Minutes</th><td>${currentTimeMinutes}</td></tr>
                    <tr><th>Current Hour Slot</th><td>${getNextProductionHour()}</td></tr>
                </table>
            `;
            
            // Set content and show popup
            popupContent.innerHTML = debugHtml;
            document.getElementById('debugPopup').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function hideDebugPopup() {
            document.getElementById('debugPopup').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        window.onload = initDashboard;
        window.addEventListener('resize', function() {
            if (currentProduct && currentSupervisor) {
                const group = productSupervisorGroups[`${currentSupervisor}:${currentProduct}`];
                if (group) {
                    renderCumulativeChart(group);
                    updateHourlyChart();
                }
            }
        });
    </script>
</body>
</html>
