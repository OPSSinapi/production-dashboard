<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
       :root {
    --primary-color: #2c3e50;
    --secondary-color: #3B82F6;
    --success-color: #10B981;
    --warning-color: #F59E0B;
    --danger-color: #e74c3c;
    --light-color: #f3f4f6;
    --dark-color: #1e293b;
    --supervisor-luthando: #F9E79F;
    --supervisor-apelele: #e6e6e6; /* Light grey for Apelele */
    --supervisor-siyabonga: #FADBD8;
    --supervisor-nosi: #D6EAF8;
    --supervisor-mvokwe: #D5F5E3;
    --production-color: #e74c3c; /* Red for production */
    --target-color: #10B981; /* Green for target */
    --current-indicator: #F59E0B; /* Yellow for current time indicator */
    --completed-variant: #D1E7DD; /* Light green for completed variants */
    --current-variant: #FFF3CD; /* Light yellow for current variant */
    --upcoming-variant: #F8D7DA; /* Light red for upcoming variants */
    --legend-bg: #f8fafc; /* Background color for legend section */
    --status-met: #D1E7DD; /* Status indicator - met target */
    --status-missed: #FECDD3; /* Status indicator - missed target */
    --status-current: #FEF9C3; /* Status indicator - current hour */
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--light-color);
    color: var(--primary-color);
    overflow: auto;
    transition: background-color 0.5s ease;
}

.dashboard-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    padding: 12px; /* Reduced padding */
    box-sizing: border-box;
    max-width: 1600px;
    margin: 0 auto;
    transition: background-color 0.5s ease;
}

.fullscreen-mode {
    display: grid;
    grid-template-rows: auto auto auto 1fr auto;
    padding: 8px !important;
    height: 100vh !important;
    width: 100vw !important;
    max-width: 100% !important;
    margin: 0 !important;
    overflow: hidden !important;
    box-sizing: border-box;
    background-color: var(--light-color) !important; /* Add this line */
}

/* Color banner at top */
.supervisor-color-banner {
    width: 100%;
    height: 20px;
    border-radius: 3px;
    margin-bottom: 5px;
}

/* Header styles */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    width: 100%;
}

.title-section {
    display: flex;
    align-items: center;
    gap: 15px;
}

.title {
    font-size: clamp(1.8rem, 2.4vw, 2.4rem);
    font-weight: bold;
    color: var(--primary-color);
}

.controls-section {
    display: flex;
    align-items: center;
    gap: 20px;
}

.filter-container {
    display: flex;
    gap: 10px;
}

.filter-select {
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-size: clamp(1rem, 1.2vw, 1.2rem);
    min-width: 180px;
    background-color: white;
}

.buttons-container {
    display: flex;
    gap: 10px;
}

.supervisor-select-btn {
    background-color: var(--secondary-color);
    color: white;
    padding: 8px 15px;
    font-size: clamp(1rem, 1.2vw, 1.2rem);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    font-family: inherit;
    min-width: 140px;
}

.fullscreen-button {
    background-color: #e2e8f0;
    color: var(--dark-color);
    padding: 8px 15px;
    font-size: clamp(1rem, 1.2vw, 1.2rem);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    font-family: inherit;
}

.date-time {
    text-align: right;
    font-size: clamp(1.2rem, 1.4vw, 1.4rem);
}

.time {
    font-size: clamp(1.4rem, 1.8vw, 1.8rem);
    font-weight: bold;
}

/* Legend section */
.legend-section {
    width: 100%;
    background-color: var(--legend-bg);
    padding: 15px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
}

.legend-item {
    display: flex;
    align-items: center;
    margin-right: 50px;
}

.legend-color {
    width: 30px;
    height: 30px;
    margin-right: 10px;
    border-radius: 5px;
}

.legend-label {
    font-size: clamp(1.2rem, 1.4vw, 1.4rem);
    font-weight: 500;
}

.current-hour-info {
    font-size: clamp(1.2rem, 1.4vw, 1.4rem);
    color: var(--secondary-color);
    font-weight: 500;
}

/* Top row with supervisor and metrics */
.top-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    width: 100%;
}

        /* Supervisor info panel */
.supervisor-panel {
    flex: 0 0 450px;
    background-color: var(--supervisor-mvokwe);
    border-radius: 12px;
    padding: 20px;
    box-sizing: border-box;
}

.supervisor-name {
    font-size: clamp(1.4rem, 1.8vw, 1.8rem);
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--dark-color);
}

.product-name {
    font-size: clamp(1.2rem, 1.6vw, 1.6rem);
    color: var(--dark-color);
    margin-bottom: 20px;
}

.variant-sequence {
    display: flex;
    align-items: center;
    font-size: clamp(1rem, 1.2vw, 1.2rem);
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
}

.variant-item {
    padding: 10px 15px;
    border-radius: 8px;
    white-space: nowrap;
    position: relative;
    text-align: center;
    min-width: 100px;
}

.variant-item.completed {
    background-color: var(--completed-variant);
    color: var(--dark-color);
}

.variant-item.current {
    background-color: var(--current-variant);
    color: var(--dark-color);
    font-weight: bold;
}

.variant-item.upcoming {
    background-color: var(--upcoming-variant);
    color: var(--dark-color);
}

.arrow-right {
    margin: 0 5px;
    font-size: clamp(1.2rem, 1.6vw, 1.6rem);
    color: var(--dark-color);
}

/* Metrics cards */
.metrics-container {
    flex: 1;
    display: flex;
    gap: 20px;
}

.metric-card {
    flex: 1;
    background-color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
}

.metric-title {
    font-size: clamp(1.3rem, 1.6vw, 1.6rem);
    font-weight: bold;
    margin-bottom: 15px;
    color: var(--primary-color);
    text-align: center;
}

.metric-value {
    font-size: clamp(2rem, 3vw, 3rem);
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.metric-subvalue {
    font-size: clamp(1rem, 1.4vw, 1.4rem);
    text-align: center;
}

.current-value {
    color: var(--production-color);
}

.target-value {
    color: var(--target-color);
}

/* Charts section */
.charts-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    width: 100%;
    height: 360px;
}

.chart {
    flex: 1;
    background-color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
}

.chart-title {
    font-size: clamp(1.4rem, 1.8vw, 1.8rem);
    font-weight: 600;
    margin-bottom: 20px;
    color: var(--primary-color);
}

.chart-area {
    flex: 1;
    position: relative;
    min-height: 0;
}

.line-chart, .bar-chart {
    height: 100%;
    width: 100%;
}

/* Hourly targets section */
.hourly-targets-section {
    width: 100%;
    background-color: white;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.hourly-targets-title {
    font-size: clamp(1.4rem, 1.8vw, 1.8rem);
    font-weight: bold;
    margin-bottom: 20px;
    color: var(--primary-color);
}

.hourly-targets-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

.hourly-target-item {
    width: 80px;
    height: 60px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
}

.hourly-target-time {
    font-weight: bold;
    font-size: clamp(0.9rem, 1.1vw, 1.1rem);
}

.hourly-target-status {
    font-size: clamp(1rem, 1.2vw, 1.2rem);
    margin-top: 5px;
}

.status-met {
    background-color: var(--status-met);
    border: 3px solid #0d9488;
}

.status-missed {
    background-color: var(--status-missed);
    border: 3px solid #e11d48;
}

.status-current {
    background-color: var(--status-current);
    border: 4px solid #ca8a04;
}

.status-upcoming {
    background-color: white;
    border: 2px solid #94a3b8;
}

/* Footer */
.footer {
    margin-top: 10px;
    font-size: clamp(0.9rem, 1.1vw, 1.1rem);
    color: var(--dark-color);
    width: 100%;
}

.update-info {
    text-align: left;
}

        /* Supervisor Selection Modal */
.supervisor-select-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
    animation-name: fadeIn;
    animation-duration: 0.3s;
}

@keyframes fadeIn {
    from {opacity: 0}
    to {opacity: 1}
}

.supervisor-select-content {
    position: relative;
    background-color: #fefefe;
    margin: 10% auto;
    padding: 0;
    border-radius: 8px;
    width: 80%;
    max-width: 600px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    animation-name: slideIn;
    animation-duration: 0.3s;
}

@keyframes slideIn {
    from {top: -300px; opacity: 0}
    to {top: 0; opacity: 1}
}

.supervisor-select-header {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.supervisor-select-header h3 {
    margin: 0;
    font-size: 1.5rem;
    color: var(--dark-color);
}

.supervisor-select-close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.supervisor-select-close:hover {
    color: var(--dark-color);
}

.supervisor-select-body {
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

.supervisor-checkboxes {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.supervisor-checkbox-item {
    display: flex;
    align-items: center;
    padding: 10px;
    border-radius: 6px;
    transition: background-color 0.2s;
}

.supervisor-checkbox-item:hover {
    background-color: #f8fafc;
}

.supervisor-checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 15px;
    cursor: pointer;
}

.supervisor-checkbox-item label {
    font-size: 1.2rem;
    font-weight: 500;
    cursor: pointer;
    flex: 1;
}

.supervisor-select-footer {
    padding: 15px 20px;
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

/* Responsive design */
@media (max-width: 1400px) {
    .top-row {
        flex-direction: column;
    }
    
    .supervisor-panel {
        flex: 0 0 auto;
        width: 100%;
        margin-bottom: 20px;
    }
    
    .metrics-container {
        width: 100%;
    }
}

@media (max-width: 1200px) {
    .charts-row {
        flex-direction: column;
        height: auto;
    }
    
    .chart {
        height: 350px;
        margin-bottom: 20px;
    }
    
    .hourly-targets-grid {
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .header {
        flex-direction: column;
        text-align: center;
    }
    
    .title-section {
        margin-bottom: 15px;
    }
    
    .controls-section {
        flex-direction: column;
        width: 100%;
    }
    
    .filter-container {
        width: 100%;
        margin-bottom: 10px;
    }
    
    .filter-select {
        flex: 1;
    }
    
    .buttons-container {
        width: 100%;
    }
    
    .supervisor-select-btn, 
    .fullscreen-button {
        flex: 1;
    }
    
    .metrics-container {
        flex-direction: column;
    }
    
    .metric-card {
        margin-bottom: 15px;
    }
    
    .hourly-targets-grid {
        gap: 10px;
    }
    
    .hourly-target-item {
        width: 70px;
        height: 50px;
    }
}
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Supervisor color banner -->
        <div class="supervisor-color-banner"></div>
        
        <!-- Header Section -->
        <div class="header">
            <div class="title-section">
                <div class="title">Sinapi Secondary Production Dashboard</div>
            </div>
            
            <div class="controls-section">
                <div class="filter-container">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                
                <div class="buttons-container">
                    <button id="supervisor-select-btn" class="supervisor-select-btn">
                        Select Supervisors
                    </button>
                    <button class="fullscreen-button" onclick="toggleFullscreen()">Fullscreen</button>
                </div>
            </div>
            
            <div class="date-time">
                <div class="time" id="current-time">Loading...</div>
            </div>
        </div>
        
        <!-- Legend Section -->
        <div class="legend-section">
            <div style="display: flex;">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--production-color);"></div>
                    <div class="legend-label">PRODUCTION</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--target-color);"></div>
                    <div class="legend-label">TARGET</div>
                </div>
            </div>
            <div class="current-hour-info" id="current-hour-info">CURRENT HOUR: --:-- (-- MIN LEFT)</div>
        </div>

        <!-- Top Row: Supervisor + Metrics -->
        <div class="top-row">
            <!-- Supervisor Panel -->
            <div class="supervisor-panel">
                <div class="supervisor-name" id="supervisor-name">SUPERVISOR: Loading...</div>
                <div class="product-name" id="product-name">PRODUCT: Loading...</div>
                
                <div class="variant-sequence" id="variant-sequence">
                    <div class="loading">Loading variants...</div>
                </div>
            </div>
            
            <!-- Metrics Container -->
            <div class="metrics-container">
                <!-- Units (renamed from Progress) -->
                <div class="metric-card">
                    <div class="metric-title">UNITS</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-units">0</span>/<span class="target-value" id="target-units">0</span>
                    </div>
                    <div class="metric-subvalue" id="progress-percentage">0%</div>
                </div>
                
                <!-- Boxes - NEXT TO UNITS -->
                <div class="metric-card">
                    <div class="metric-title">BOXES</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-boxes">0</span>/<span class="target-value" id="target-boxes">0</span>
                    </div>
                    <div class="metric-subvalue">completed</div>
                </div>
                
                <!-- Cycle Time -->
                <div class="metric-card">
                    <div class="metric-title">CYCLE TIME</div>
                    <div class="metric-value">
                        <span class="current-value" id="actual-cycle-time">0</span>/<span class="target-value" id="target-cycle-time">0</span>
                    </div>
                    <div class="metric-subvalue">seconds</div>
                </div>
            </div>
        </div>
        
        <!-- Charts Row -->
        <div class="charts-row">
            <!-- Cumulative Chart -->
            <div class="chart">
                <div class="chart-title" id="cumulative-chart-title">TODAY'S PRODUCTION PROGRESS</div>
                <div class="chart-area">
                    <div class="line-chart" id="cumulative-chart"></div>
                </div>
            </div>
            
            <!-- Current Hour Chart -->
            <div class="chart">
                <div class="chart-title" id="hourly-chart-title">12:30 HOUR PRODUCTION</div>
                <div class="chart-area">
                    <div class="bar-chart" id="hourly-chart"></div>
                </div>
            </div>
        </div>
        
        <!-- Hourly Targets Section - REDESIGNED -->
        <div class="hourly-targets-section">
            <div class="hourly-targets-title">HOURLY TARGETS</div>
            <div class="hourly-targets-grid" id="hourly-targets-grid">
                <!-- Will be populated dynamically -->
            </div>
        </div>
        
        <!-- Footer -->
        <div class="footer">
            <div class="update-info" id="last-update">Last updated: Never</div>
        </div>
        
        <!-- Supervisor Selection Modal -->
        <div id="supervisor-select-modal" class="supervisor-select-modal">
            <div class="supervisor-select-content">
                <div class="supervisor-select-header">
                    <h3>Select Supervisors to Display</h3>
                    <span class="supervisor-select-close">&times;</span>
                </div>
                <div class="supervisor-select-body">
                    <div id="supervisor-checkboxes" class="supervisor-checkboxes">
                        <!-- Checkboxes will be added dynamically -->
                    </div>
                </div>
                <div class="supervisor-select-footer">
                    <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                    <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                    <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 30 * 1000; // 30 seconds update interval
        const CYCLE_INTERVAL = 20000; // 20 seconds cycle interval

        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        
        // Variables for product-supervisor grouping
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;
        let selectedSupervisors = []; // Array to hold selected supervisors    
        let supervisorFilterActive = false; // Track if supervisor filter is active
        
        // Cycling variables
        let cycleInterval = null;
        let cycleIndex = 0;

        // Initialize dashboard
        function initDashboard() {
            updateDateTime();
            setInterval(updateDateTime, 1000);

            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            // Initialize supervisor selection
            initSupervisorSelection();
            
            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function toggleFullscreen() {
            const dashboard = document.querySelector('.dashboard-container');
            const fullscreenButton = document.querySelector('.fullscreen-button');

            if (!document.fullscreenElement && !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && !document.msFullscreenElement) {
                dashboard.classList.add('fullscreen-mode');
                isFullscreen = true;
                fullscreenButton.textContent = 'Exit Fullscreen';

                if (dashboard.requestFullscreen) dashboard.requestFullscreen();
                else if (dashboard.msRequestFullscreen) dashboard.msRequestFullscreen();
                else if (dashboard.mozRequestFullScreen) dashboard.mozRequestFullScreen();
                else if (dashboard.webkitRequestFullscreen) dashboard.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
            const dashboard = document.querySelector('.dashboard-container');
            const fullscreenButton = document.querySelector('.fullscreen-button');

            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                dashboard.classList.remove('fullscreen-mode');
                isFullscreen = false;
                fullscreenButton.textContent = 'Fullscreen';
            }

            // Redraw as needed
            setTimeout(updateDashboard, 100);
        }

        // Function to initialize the supervisor selection UI
        function initSupervisorSelection() {
            const selectBtn = document.getElementById('supervisor-select-btn');
            const modal = document.getElementById('supervisor-select-modal');
            const closeBtn = document.querySelector('.supervisor-select-close');
            const applyBtn = document.getElementById('apply-supervisor-selection');
            const selectAllBtn = document.getElementById('select-all-supervisors');
            const deselectAllBtn = document.getElementById('deselect-all-supervisors');
            
            // Open modal when button is clicked
            selectBtn.addEventListener('click', function() {
                updateSupervisorCheckboxes();
                modal.style.display = 'block';
            });
            
            // Close modal when X is clicked
            closeBtn.addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            // Close modal when clicking outside of it
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // Apply selection and close modal
            applyBtn.addEventListener('click', function() {
                applySupervisorSelection();
                modal.style.display = 'none';
            });
            
            // Select all supervisors
            selectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            });
            
            // Deselect all supervisors
            deselectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            });
            
            // Initialize with all supervisors selected
            if (productionData && productionData.supervisors) {
                selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
            }
        }

        // Function to update the supervisor checkboxes
        function updateSupervisorCheckboxes() {
            const checkboxContainer = document.getElementById('supervisor-checkboxes');
            checkboxContainer.innerHTML = '';
            
            if (!productionData || !productionData.supervisors || productionData.supervisors.length === 0) {
                checkboxContainer.innerHTML = '<p>No supervisors available</p>';
                return;
            }
            
            // Create a checkbox for each supervisor
            productionData.supervisors.forEach(supervisor => {
                const item = document.createElement('div');
                item.className = 'supervisor-checkbox-item';
                
                // Add supervisor color indicator
                const colorDiv = document.createElement('div');
                colorDiv.className = 'supervisor-color-indicator';
                colorDiv.style.backgroundColor = getSupervisorColor(supervisor.name);
                item.appendChild(colorDiv);
                
                // Create checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'supervisor-checkbox';
                checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
                checkbox.value = supervisor.name;
                checkbox.checked = selectedSupervisors.includes(supervisor.name);
                
                // Create label
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = supervisor.name;
                
                // Add badge for active supervisor (currently displayed)
                if (currentSupervisor === supervisor.name) {
                    const badge = document.createElement('span');
                    badge.className = 'supervisor-active-badge';
                    badge.textContent = 'Current';
                    item.appendChild(badge);
                }
                
                item.appendChild(checkbox);
                item.appendChild(label);
                checkboxContainer.appendChild(item);
            });
        }

        // Function to apply supervisor selection
        function applySupervisorSelection() {
            const checkboxes = document.querySelectorAll('.supervisor-checkbox');
            selectedSupervisors = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedSupervisors.push(checkbox.value);
                }
            });
            
            // Store selection in localStorage for persistence
            localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
            
            // Update the selection button style based on whether filtering is active
            supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (supervisorFilterActive) {
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                selectBtn.classList.add('filtered');
            } else {
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
            }
            
            // Update the dashboard with the new selection
            updateDashboard();
        }

        // Function to get the supervisor color
        function getSupervisorColor(supervisorName) {
            const colorMap = {
                'Luthando': 'var(--supervisor-luthando)',
                'Apelele': 'var(--supervisor-apelele)',
                'Siyabonga': 'var(--supervisor-siyabonga)',
                'Nosi': 'var(--supervisor-nosi)',
                'Mvokwe': 'var(--supervisor-mvokwe)',
                'Michaela': 'var(--supervisor-luthando)' // Reusing Luthando's color for Michaela
            };
            
            return colorMap[supervisorName] || '#e2e8f0'; // Default color if not found
        }

        // Function to load selected supervisors from localStorage
        function loadSelectedSupervisors() {
            const stored = localStorage.getItem('selectedSupervisors');
            if (stored) {
                try {
                    selectedSupervisors = JSON.parse(stored);
                    
                    // Validate against current supervisors
                    if (productionData && productionData.supervisors) {
                        const validSupervisors = productionData.supervisors.map(s => s.name);
                        selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                        
                        // If none valid, select all
                        if (selectedSupervisors.length === 0) {
                            selectedSupervisors = validSupervisors;
                        }
                    }
                    
                    // Update UI
                    supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
                    const selectBtn = document.getElementById('supervisor-select-btn');
                    
                    if (supervisorFilterActive) {
                        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                        selectBtn.classList.add('filtered');
                    }
                } catch (e) {
                    console.error('Error parsing stored supervisors:', e);
                    if (productionData && productionData.supervisors) {
                        selectedSupervisors = productionData.supervisors.map(s => s.name);
                    }
                }
            }
        }

        // Function to fetch production data
        async function fetchProductionData() {
            try {
                console.log(`Attempting to fetch data from: ${DATA_URL}`);
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                // Check if data has the expected structure
                if (!data) {
                    throw new Error('Empty data received from data.json');
                }
                
                // Transform data regardless of structure
                const transformedData = transformDataFormat(data);
                
                // Validate transformed data has the required structure for the dashboard
                if (!transformedData.variants || !Array.isArray(transformedData.variants) || 
                    !transformedData.supervisors || !Array.isArray(transformedData.supervisors)) {
                    throw new Error('Failed to transform data into the required format');
                }
                
                if (!lastUpdateTime || lastUpdateTime !== transformedData.timestamp) {
                    productionData = transformedData;
                    lastUpdateTime = transformedData.timestamp;
                    
                    // Update only the footer timestamp
                    document.getElementById('last-update').textContent = 'Last updated: ' + transformedData.timestamp;
                    
                    // Process product-supervisor groups from the transformed data
                    processProductSupervisorGroups();
                    
                    // Load saved supervisor selections or initialize all selected
                    if (selectedSupervisors.length === 0) {
                        selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
                        loadSelectedSupervisors(); // Load any saved preferences
                    }
                    
                    updateFilterValueDropdown();
                    updateDashboard();
                }
                
                isLoading = false;
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
            }
        }

        // Function to transform data format
        function transformDataFormat(newData) {
            // This is the existing function, no changes needed
            const transformedData = {
                variants: [],
                supervisors: [],
                timestamp: newData.metadata.timestamp || new Date().toISOString()
            };
            
            // Check which structure we're working with and handle accordingly
            if (newData.production && Array.isArray(newData.production)) {
                // New structure with production array and summary
                
                // Transform production items to variants
                newData.production.forEach(item => {
                    const transformedVariant = {
                        variant: item.id,
                        "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                        cycleTime: item.variant.cycleTime,
                        actualCycleTime: item.variant.actualCycleTime,
                        "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                        "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                        dailyBoxTarget: item.targets.boxes,
                        currentBoxTotal: item.actual.boxes,
                        hourlyTargets: [],
                        hourlyProduction: []
                    };
                    
                    // Add hourly targets and production data
                    if (item.timeline && Array.isArray(item.timeline)) {
                        item.timeline.forEach(hour => {
                            // Add hourly target
                            transformedVariant.hourlyTargets.push({
                                hour: hour.hour,
                                target: hour.target
                            });
                            
                            // Add hourly production
                            transformedVariant.hourlyProduction.push({
                                hour: hour.hour,
                                production: hour.actual
                            });
                        });
                    }
                    
                    transformedData.variants.push(transformedVariant);
                });
                
                // Process supervisors from the summary section
                if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                    newData.summary.supervisors.forEach(supervisor => {
                        const transformedSupervisor = {
                            name: supervisor.name,
                            variants: {}
                        };
                        
                        // Find all production items assigned to this supervisor
                        if (supervisor.variants && Array.isArray(supervisor.variants)) {
                            supervisor.variants.forEach(variantId => {
                                // Find the production item for this variant
                                const prodItem = newData.production.find(p => p.id === variantId);
                                
                                if (prodItem) {
                                    // Find the supervisor assignment within the production item
                                    const assignment = prodItem.supervisors.find(s => s.id === supervisor.id);
                                    
                                    if (assignment) {
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: assignment.startTime,
                                            variantEndTime: assignment.endTime,
                                            dailyTarget: assignment.target,
                                            currentTotal: assignment.production,
                                            variance: assignment.production - assignment.target,
                                            percentage: assignment.progress
                                        };
                                    } else {
                                        // Fallback to using summary data if detailed assignment not found
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: prodItem.supervisors[0]?.startTime || "07:30",
                                            variantEndTime: prodItem.supervisors[0]?.endTime || "18:30",
                                            dailyTarget: prodItem.targets.daily,
                                            currentTotal: prodItem.actual.total,
                                            variance: prodItem.actual.total - prodItem.targets.daily,
                                            percentage: prodItem.actual.progress
                                        };
                                    }
                                }
                            });
                        }
                        
                        transformedData.supervisors.push(transformedSupervisor);
                    });
                }
            } else if (newData.variants && Array.isArray(newData.variants)) {
                // Previous structure with variants array
                // Handle this as before
                // (code omitted for brevity, as it remains unchanged)
            }
            
            return transformedData;
        }
        
        // Function to process product-supervisor groups
        function processProductSupervisorGroups() {
            // Reset groups
            productSupervisorGroups = {};
            
            // First, create supervisor-product mapping
            productionData.supervisors.forEach(supervisor => {
                if (!supervisor.variants) return;
                
                // Create a temporary map of product -> variants
                const productVariants = {};
                
                // Process each variant
                Object.keys(supervisor.variants).forEach(variantKey => {
                    const product = extractProductFromVariant(variantKey);
                    
                    if (!productVariants[product]) {
                        productVariants[product] = [];
                    }
                    
                    // Find the variant in the variants array
                    const variantData = productionData.variants.find(v => v.variant === variantKey);
                    
                    if (variantData) {
                        productVariants[product].push({
                            variantKey,
                            variantData,
                            supervisorVariant: supervisor.variants[variantKey]
                        });
                    }
                });
                
                // Sort variants by start time and add to groups
                Object.keys(productVariants).forEach(product => {
                    const group = `${supervisor.name}:${product}`;
                    
                    // Sort variants by start time
                    const sortedVariants = productVariants[product].sort((a, b) => {
                        const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                        const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                        
                        const [hoursA, minutesA] = timeA.split(':').map(Number);
                        const [hoursB, minutesB] = timeB.split(':').map(Number);
                        
                        const totalMinutesA = hoursA * 60 + minutesA;
                        const totalMinutesB = hoursB * 60 + minutesB;
                        
                        return totalMinutesA - totalMinutesB;
                    });
                    
                    // Store in groups
                    productSupervisorGroups[group] = {
                        supervisor: supervisor.name,
                        product,
                        variants: sortedVariants.map(v => v.variantData),
                        supervisorData: supervisor
                    };
                });
            });
        }

        // Helper function to extract product from variant ID
        function extractProductFromVariant(variantId) {
            // For the new structure format with product-variant IDs like "Scalpel-Assembly-PARC11NS"
            if (variantId.includes('-')) {
                // Try splitting by dash and look for known product patterns
                const parts = variantId.split('-');
                
                // Handle case where product name contains a dash (like Scalpel-Assembly)
                if (parts.length > 2) {
                    // If we have more than one dash, the product likely contains a dash
                    // Extract everything except the last part (which is the variant)
                    return parts.slice(0, -1).join('-');
                } else if (parts.length === 2) {
                    // Simple product-variant format
                    return parts[0];
                }
            }

            // Fallback to original method for older formats
            const parts = variantId.split(' ');
            
            // Handle different formats
            if (parts.length === 1) return variantId; // No space, use as is
            if (parts.length === 2) return parts[0]; // Simple "Product Variant"
            
            // For more complex formats, try to find a pattern
            // Example: "LEVO XL1150SCi" -> "LEVO XL"
            const match = variantId.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            // Fallback: use first word
            return parts[0];
        }

        // Function to update filter value dropdown
        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear existing options (except 'all')
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.supervisors?.length > 0) {
                // Add all supervisors
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                // Add all unique products
                const uniqueProducts = new Set();
                
                // Extract products from all variants
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.product);
                });
                
                // Add options
                uniqueProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'variant' && productionData.variants?.length > 0) {
                // Add all unique variants
                const uniqueVariants = new Set(productionData.variants.map(v => v.variant));
                uniqueVariants.forEach(variantName => {
                    const option = document.createElement('option');
                    option.value = variantName;
                    option.textContent = variantName;
                    filterValueSelect.appendChild(option);
                });
            }
            
            // Restore previous selection if available, otherwise use 'all'
            filterValueSelect.value = Array.from(filterValueSelect.options).some(opt => opt.value === currentValue) 
                ? currentValue 
                : 'all';
                
            selectedFilterValue = filterValueSelect.value;
        }


        // Function to show loading or error message
        function showLoadingOrError(message) {
            const supervisorName = document.getElementById('supervisor-name');
            const productName = document.getElementById('product-name');
            const variantSequence = document.getElementById('variant-sequence');
            
            supervisorName.textContent = 'SUPERVISOR: Loading...';
            productName.textContent = 'PRODUCT: Loading...';
            variantSequence.innerHTML = '<div class="loading">Loading variants...</div>';
            
            // Clear the metrics
            document.getElementById('current-units').textContent = '0';
            document.getElementById('target-units').textContent = '0';
            document.getElementById('progress-percentage').textContent = '0%';
            document.getElementById('current-boxes').textContent = '0';
            document.getElementById('target-boxes').textContent = '0';
            document.getElementById('actual-cycle-time').textContent = '0';
            document.getElementById('target-cycle-time').textContent = '0';
            
            // Clear the charts
            document.getElementById('cumulative-chart').innerHTML = 
                `<div style="text-align:center;padding:20px;height:100%;display:flex;align-items:center;justify-content:center;">${message}</div>`;
            document.getElementById('hourly-chart').innerHTML = 
                `<div style="text-align:center;padding:20px;height:100%;display:flex;align-items:center;justify-content:center;">${message}</div>`;
        }

        // Function to update date and time
        function updateDateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            
            // Update current hour info in the legend
            updateCurrentHourInfo();
            
            // Check if we need to update dashboard based on time changes (variant transitions)
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                // Check if we crossed a variant boundary
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if we just crossed this boundary
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }

        // Function to update the current hour info in the legend
        function updateCurrentHourInfo() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Find next hour boundary (formatted as "HH:30")
            const nextHourMinute = 30;
            const nextHour = currentMinute < nextHourMinute ? currentHour : currentHour + 1;
            const nextHourStr = `${nextHour.toString().padStart(2, '0')}:${nextHourMinute.toString().padStart(2, '0')}`;
            
            // Calculate minutes remaining
            let minutesRemaining;
            if (currentMinute < nextHourMinute) {
                minutesRemaining = nextHourMinute - currentMinute;
            } else {
                minutesRemaining = (60 - currentMinute) + nextHourMinute;
            }
            
            // Format the current hour string
            const hourStr = currentMinute < 30 ? 
                `${currentHour.toString().padStart(2, '0')}:30` : 
                `${(currentHour + 1).toString().padStart(2, '0')}:30`;
            
            document.getElementById('current-hour-info').textContent = 
                `CURRENT HOUR: ${hourStr} (${minutesRemaining} MIN LEFT)`;
        }

        // Function to update the dashboard
        function updateDashboard() {
            // Filter groups based on selection and selected supervisors
            let filteredGroups = {};
            
            // Start with selected filter type/value
            if (selectedFilterValue === 'all') {
                // When "all" is selected, still respect supervisor selection
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'supervisor') {
                // When filtering by specific supervisor, also check if it's in selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].supervisor === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'product') {
                // Filter by product but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].product === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'variant') {
                // Filter by variant but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    if (group.variants.some(v => v.variant === selectedFilterValue) &&
                        selectedSupervisors.includes(group.supervisor)) {
                        filteredGroups[key] = group;
                    }
                });
            }
            
            // If no groups after filtering, show error and return
            if (Object.keys(filteredGroups).length === 0) {
                showLoadingOrError('No data available for this filter or selected supervisors.');
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
                return;
            }
            
            // Multiple groups - setup cycling
            const groupKeys = Object.keys(filteredGroups);
            if (groupKeys.length > 1) {
                // Clear existing interval
                if (cycleInterval) clearInterval(cycleInterval);
                
                // Set cycling logic
                cycleIndex = 0;
                cycleInterval = setInterval(() => {
                    cycleIndex = (cycleIndex + 1) % groupKeys.length;
                    displayGroup(filteredGroups[groupKeys[cycleIndex]]);
                }, CYCLE_INTERVAL);
            } else {
                // Single group - clear cycling
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
            }
            
            // Display the first group initially
            displayGroup(filteredGroups[groupKeys[0]]);
        }

        // Function to display a group
        function displayGroup(group) {
            // Set current product and supervisor
            currentProduct = group.product;
            currentSupervisor = group.supervisor;
            currentProductVariants = group.variants;
            
            // Find current variant
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Sort variants by start time
            const sortedVariants = [...currentProductVariants].sort((a, b) => {
                const supervisorA = group.supervisorData.variants[a.variant];
                const supervisorB = group.supervisorData.variants[b.variant];
                
                const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                
                const [hoursA, minutesA] = timeA.split(':').map(Number);
                const [hoursB, minutesB] = timeB.split(':').map(Number);
                
                return (hoursA * 60 + minutesA) - (hoursB * 60 + minutesB);
            });
            
            // Find the current active variant
            let currentVariantIndex = -1;
            
            for (let i = 0; i < sortedVariants.length; i++) {
                const variant = sortedVariants[i];
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) continue;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Check if current time is within this variant's window
                if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                    currentVariantIndex = i;
                    break;
                }
            }
            
            // If no current variant found, use last variant
            if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                currentVariantIndex = sortedVariants.length - 1;
            }
            
            // Set current variant
            currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
            
            // Apply styling based on supervisor
            applySupervisorStyling(currentSupervisor);
            
            // Update UI
            updateSupervisorInfo(group);
            updateMetrics(group);
            renderCumulativeChart(group);
            renderHourlyChart(group);
            renderHourlyTargets(group);
        }

        // Function to apply supervisor styling
        function applySupervisorStyling(supervisorName) {
            const dashboardContainer = document.querySelector('.dashboard-container');
            const supervisorColorBanner = document.querySelector('.supervisor-color-banner');
            const supervisorPanel = document.querySelector('.supervisor-panel');
            
            // Clear existing classes
            dashboardContainer.classList.remove('supervisor-luthando', 'supervisor-apelele', 'supervisor-siyabonga', 'supervisor-nosi', 'supervisor-mvokwe');
            
            // Apply supervisor-specific color
            if (supervisorName) {
                const supervisorClass = 'supervisor-' + supervisorName.toLowerCase();
                dashboardContainer.classList.add(supervisorClass);
                
                // Also apply color directly
                const color = getSupervisorColor(supervisorName);
                supervisorColorBanner.style.backgroundColor = color;
                supervisorPanel.style.backgroundColor = color;
            }
        }

        // Function to update supervisor info
        function updateSupervisorInfo(group) {
            document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${group.supervisor}`;
            document.getElementById('product-name').textContent = `PRODUCT: ${group.product}`;
            
            // Update variant sequence
            const sequenceContainer = document.getElementById('variant-sequence');
            sequenceContainer.innerHTML = '';
            
            if (group.variants.length === 0) {
                sequenceContainer.innerHTML = '<div>No variants available</div>';
                return;
            }
            
            // Get current time to determine variant status
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Add each variant to the sequence
            group.variants.forEach((variant, index) => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Determine variant status
                let status = '';
                if (currentTimeMinutes < startTimeMinutes) {
                    status = 'upcoming';
                } else if (currentTimeMinutes > endTimeMinutes) {
                    status = 'completed';
                } else {
                    status = 'current';
                }
                
                // Extract variant name from full variant string
                let displayName = variant.variant;
                
                // Try to extract just the variant part
                if (variant.variant.includes('-')) {
                    displayName = variant.variant.split('-').pop();
                } else if (variant.variant.startsWith(group.product + ' ')) {
                    displayName = variant.variant.substring(group.product.length + 1);
                }
                
                // Create variant element
                const variantElement = document.createElement('div');
                variantElement.className = `variant-item ${status}`;
                variantElement.textContent = displayName;
                
                sequenceContainer.appendChild(variantElement);
                
                // Add arrow if not the last variant
                if (index < group.variants.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-right';
                    arrow.textContent = '';
                    sequenceContainer.appendChild(arrow);
                }
            });
        }

        // Function to update metrics
        function updateMetrics(group) {
            // Initialize aggregated values
            let totalTarget = 0;
            let totalProduction = 0;
            let totalBoxTarget = 0;
            let totalBoxProduction = 0;
            let weightedCycleTime = 0;
            let totalCycleTimeWeight = 0;
            
            // Calculate aggregated values
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                    totalProduction += (supervisorVariant.currentTotal || 0);
                    
                    // Add box totals consistently for all variants
                    totalBoxTarget += (variant.dailyBoxTarget || 0);
                    totalBoxProduction += (variant.currentBoxTotal || 0);
                    
                    // Add cycle time weighted by target
                    const cycleTime = variant.cycleTime || 0;
                    const target = supervisorVariant.dailyTarget || 0;
                    
                    if (cycleTime > 0 && target > 0) {
                        weightedCycleTime += cycleTime * target;
                        totalCycleTimeWeight += target;
                    }
                }
            });
            
            // Calculate overall progress percentage
            const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            // Calculate average cycle time
            const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
            
            // Calculate actual cycle time across all variants
            const actualCycleTime = calculateActualCycleTime(group.variants);
            
            // Update metrics display
            document.getElementById('current-units').textContent = totalProduction;
            document.getElementById('target-units').textContent = totalTarget;
            document.getElementById('progress-percentage').textContent = `${progressPercentage}%`;
            
            document.getElementById('current-boxes').textContent = totalBoxProduction;
            document.getElementById('target-boxes').textContent = totalBoxTarget;
            
            document.getElementById('actual-cycle-time').textContent = actualCycleTime === "N/A" ? "N/A" : actualCycleTime;
            document.getElementById('target-cycle-time').textContent = avgCycleTime;
        }

       // Function to calculate actual cycle time
function calculateActualCycleTime(variants) {
    // Check if any variant has actualCycleTime - if so, use weighted average of those values
    const variantsWithActualCycleTime = variants.filter(v => v.actualCycleTime !== undefined && v.actualCycleTime !== null);
    
    if (variantsWithActualCycleTime.length > 0) {
        // Calculate weighted average of actualCycleTime if multiple variants
        if (variantsWithActualCycleTime.length > 1) {
            let totalWeight = 0;
            let weightedSum = 0;
            
            // Weight by production quantities
            variantsWithActualCycleTime.forEach(variant => {
                const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                if (supervisor && supervisor.variants[variant.variant]) {
                    const supervisorVariant = supervisor.variants[variant.variant];
                    if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                        totalWeight += supervisorVariant.currentTotal;
                        weightedSum += variant.actualCycleTime * supervisorVariant.currentTotal;
                    }
                }
            });
            
            if (totalWeight > 0) {
                return Math.round(weightedSum / totalWeight);
            } else {
                // If no weights, use simple average
                const sum = variantsWithActualCycleTime.reduce((acc, v) => acc + v.actualCycleTime, 0);
                return Math.round(sum / variantsWithActualCycleTime.length);
            }
        } else {
            // If only one variant, just return its actualCycleTime
            return variantsWithActualCycleTime[0].actualCycleTime;
        }
    }
    
    // Fall back to original calculation if no actualCycleTime is available
    // Get current time to calculate elapsed time
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTimeMinutes = currentHour * 60 + currentMinute;
    
    let totalProduction = 0;
    let totalElapsedWorkingTime = 0;
    
    variants.forEach(variant => {
        const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
        if (supervisor && supervisor.variants[variant.variant]) {
            const supervisorVariant = supervisor.variants[variant.variant];
            
            if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                
                if (startTimeStr) {
                    const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                    const startTotalMinutes = startHours * 60 + startMinutes;
                    
                    // Calculate elapsed time in minutes (from start until now)
                    let elapsedMinutes = currentTimeMinutes - startTotalMinutes;
                    if (elapsedMinutes < 0) {
                        elapsedMinutes += 24 * 60; // Handle case where start was yesterday
                    }
                    
                    // Calculate elapsed break time
                    const elapsedBreakMinutes = calculateElapsedBreakMinutes(variant, startTimeStr, now);
                    
                    // Calculate actual working time
                    const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                    
                    // Add to totals
                    totalProduction += supervisorVariant.currentTotal;
                    totalElapsedWorkingTime += workingMinutes * 60; // Convert to seconds
                }
            }
        }
    });
    
    if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
    
    // Calculate overall cycle time
    return Math.round(totalElapsedWorkingTime / totalProduction);
}

// Helper function to calculate elapsed break minutes
function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
    let totalElapsedBreakMinutes = 0;
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    // Function to check if a break has already occurred or is occurring
    const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
        if (!breakStartStr || !breakEndStr) return 0;
        if (breakStartStr === "-" || breakEndStr === "-") return 0;
        
        const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
        const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
        
        const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
        const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
        
        // If break hasn't started yet, return 0
        if (currentTime < breakStartMinutes) return 0;
        
        // If break is in progress, return elapsed portion
        if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
        
        // If break is complete, return full duration
        return breakEndMinutes - breakStartMinutes;
    };
    
    // Check each break
    if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
    }
    
    if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
    }
    
    if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
        variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
    }
    
    return totalElapsedBreakMinutes;
}

       // Function to render the cumulative chart
function renderCumulativeChart(group) {
    const chartContainer = document.getElementById('cumulative-chart');
    chartContainer.innerHTML = '';
    
    const currentDay = new Date().toLocaleDateString('en-US', { weekday: 'long' });
    document.getElementById('cumulative-chart-title').textContent = `TODAY'S PRODUCTION PROGRESS`;
    
    // Collect all hours across all variants
    const allHoursSet = new Set();
    const hourlyProductionMap = new Map(); // Map to store production by hour
    const hourlyTargetMap = new Map();     // Map to store targets by hour
    
    // Process each variant and collect unique hours
    group.variants.forEach(variant => {
        // Get variant time window
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Collect hourly production data
        if (variant.hourlyProduction) {
            variant.hourlyProduction.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly production map
                    if (!hourlyProductionMap.has(item.hour)) {
                        hourlyProductionMap.set(item.hour, 0);
                    }
                    hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
        
        // Collect hourly target data
        if (variant.hourlyTargets) {
            variant.hourlyTargets.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly target map
                    if (!hourlyTargetMap.has(item.hour)) {
                        hourlyTargetMap.set(item.hour, 0);
                    }
                    hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
    });
    
    // Convert to sorted array of hours
    const sortedHours = Array.from(allHoursSet).sort((a, b) => {
        const [hourA, minuteA] = a.split(':').map(Number);
        const [hourB, minuteB] = b.split(':').map(Number);
        return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
    });
    
    if (sortedHours.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
        return;
    }
    
    // Build cumulative data arrays - modified to maintain continuity across variants
    const cumulativeData = [];
    let runningProductionTotal = 0;
    let runningTargetTotal = 0;
    
    // Generate time-based data points - this is where the continuity between variants is maintained
    sortedHours.forEach(hour => {
        const hourProduction = hourlyProductionMap.get(hour) || 0;
        const hourTarget = hourlyTargetMap.get(hour) || 0;
        
        // Add to running totals - this ensures continuity across variant changes
        runningProductionTotal += hourProduction;
        runningTargetTotal += hourTarget;
        
        const [hourVal, minuteVal] = hour.split(':').map(Number);
        const timeMinutes = hourVal * 60 + minuteVal;
        
        cumulativeData.push({
            hour: hour,
            production: runningProductionTotal,
            target: runningTargetTotal,
            timeMinutes: timeMinutes
        });
    });
    
    // Filter data to only show up to current time plus buffer
    const now = new Date();
    const currentMinuteOfDay = now.getHours() * 60 + now.getMinutes();
    const currentTimePlusBuffer = currentMinuteOfDay + 30;
    
    const filteredData = cumulativeData.filter(item => item.timeMinutes <= currentTimePlusBuffer);
    
    if (filteredData.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available for current time period</div>';
        return;
    }
    
    // Find max value for chart scaling
    const maxValue = Math.max(
        ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
    ) * 1.1;
    
    // Set up chart dimensions
    const svgWidth = chartContainer.clientWidth || 600;
    const svgHeight = chartContainer.clientHeight || 370;
    const padding = commonChartPadding;
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.style.display = 'block';
    svg.style.margin = '0 auto';
    chartContainer.appendChild(svg);
    
    // Add grid lines with enlarged fonts
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 15);
        text.setAttribute('y', y + 6);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title with enlarged font
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 50);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', '18');
    yAxisTitle.setAttribute('class', 'chart-axis-label');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 50}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add y-axis line
    const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    startLine.setAttribute('x1', padding.left);
    startLine.setAttribute('y1', padding.top);
    startLine.setAttribute('x2', padding.left);
    startLine.setAttribute('y2', svgHeight - padding.bottom);
    startLine.setAttribute('stroke', '#666');
    startLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(startLine);
    
    // Add x-axis line
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', padding.left);
    xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
    xAxisLine.setAttribute('x2', svgWidth - padding.right);
    xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
    xAxisLine.setAttribute('stroke', '#666');
    xAxisLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxisLine);
    svg.appendChild(gridGroup);
    
    // Add x-axis labels
    const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    // Find earliest start time and latest end time across all variants
    let earliestStartMinutes = 24 * 60; // Initialize to end of day
    let latestEndMinutes = 0;

    group.variants.forEach(variant => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (supervisorVariant) {
            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
            const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
            
            if (startTimeStr && endTimeStr) {
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const startTimeMinutes = startHour * 60 + startMinute;
                
                if (startTimeMinutes < earliestStartMinutes) {
                    earliestStartMinutes = startTimeMinutes;
                }
                
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (endTimeMinutes > latestEndMinutes) {
                    latestEndMinutes = endTimeMinutes;
                }
            }
        }
    });

    // Format the start time for display (first tick)
    const startTimeHour = Math.floor(earliestStartMinutes / 60);
    const startTimeMinute = earliestStartMinutes % 60;
    const startTimeFormatted = `${startTimeHour.toString().padStart(2, '0')}:${startTimeMinute.toString().padStart(2, '0')}`;

    // Generate hourly intervals from start time to current time
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    const endTimeMinutes = Math.min(latestEndMinutes, currentTimeMinutes + 60); // Show up to 1 hour ahead

    // Create hourly ticks (standard hour endings after start time)
    const allHours = [];
    
    // Add the start time as the first tick
    allHours.push(startTimeFormatted);
    
    // Calculate the first full hour after start time
    const firstFullHourMinutes = Math.ceil(earliestStartMinutes / 60) * 60 + 30;
    
    // Then add standard hour markers (8:30, 9:30, etc.)
    for (let minutes = firstFullHourMinutes; minutes <= endTimeMinutes; minutes += 60) {
        const hour = Math.floor(minutes / 60);
        const formattedHour = `${hour.toString().padStart(2, '0')}:30`;
        allHours.push(formattedHour);
    }

    // Draw X-axis ticks and labels with larger fonts
    allHours.forEach((hour, index) => {
        const x = padding.left + (chartWidth * index / (allHours.length - 1 || 1));
        const y = svgHeight - padding.bottom + 25;
        
        // Add tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', x);
        tick.setAttribute('y1', svgHeight - padding.bottom);
        tick.setAttribute('x2', x);
        tick.setAttribute('y2', svgHeight - padding.bottom + 8);
        tick.setAttribute('stroke', '#666');
        tick.setAttribute('stroke-width', '1.5');
        xLabelsGroup.appendChild(tick);
        
        // Add hour label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = hour;
        xLabelsGroup.appendChild(text);
    });
    
    svg.appendChild(xLabelsGroup);
    
    // Draw production line - starting from the first tick (start time) with zero production
    const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let productionPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const productionPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        production: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for production line with proper cumulative totals
    filteredData.forEach((dataPoint, index) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
        
        productionPoints.push({ 
            x, 
            y, 
            production: dataPoint.production, 
            hour: dataPoint.hour 
        });
        productionPathD += ` L ${x} ${y}`;
    });
    
    // Add production line
    const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    productionPath.setAttribute('d', productionPathD);
    productionPath.setAttribute('stroke', 'var(--production-color)');
    productionPath.setAttribute('stroke-width', '3');
    productionPath.setAttribute('fill', 'none');
    productionLineGroup.appendChild(productionPath);
    
    // Add production points and labels with larger fonts
    productionPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '6');
        circle.setAttribute('fill', 'var(--production-color)');
        productionLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 12);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '18');
        text.setAttribute('class', 'chart-data-label');
        text.setAttribute('fill', 'var(--production-color)');
        text.textContent = point.production;
        productionLineGroup.appendChild(text);
    });
    svg.appendChild(productionLineGroup);
    
    // Draw target line - starting from the first tick (start time) with zero target
    const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let targetPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const targetPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        target: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for target line with proper cumulative totals
    filteredData.forEach((dataPoint, index) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
        
        targetPoints.push({ 
            x, 
            y, 
            target: dataPoint.target, 
            hour: dataPoint.hour 
        });
        targetPathD += ` L ${x} ${y}`;
    });
    
    // Add target line
    const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    targetPath.setAttribute('d', targetPathD);
    targetPath.setAttribute('stroke', 'var(--target-color)');
    targetPath.setAttribute('stroke-width', '3');
    targetPath.setAttribute('fill', 'none');
    targetLineGroup.appendChild(targetPath);
    
    // Add target points and labels with larger fonts
    targetPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '6');
        circle.setAttribute('fill', 'var(--target-color)');
        targetLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 12);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '18');
        text.setAttribute('class', 'chart-data-label');
        text.setAttribute('fill', 'var(--target-color)');
        text.textContent = point.target;
        targetLineGroup.appendChild(text);
    });
    svg.appendChild(targetLineGroup);
}

        // Function to render the hourly chart
function renderHourlyChart(group) {
    const chartContainer = document.getElementById('hourly-chart');
    chartContainer.innerHTML = '';
    
    if (!currentProductVariants || currentProductVariants.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
        return;
    }
    
    // Get current hour
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const hourStr = currentMinute < 30 ? 
        `${currentHour.toString().padStart(2, '0')}:30` : 
        `${(currentHour + 1).toString().padStart(2, '0')}:30`;
    
    document.getElementById('hourly-chart-title').textContent = `${hourStr} HOUR PRODUCTION`;
    
    // Find all variants active during this hour
    const activeVariants = [];
    const hourlyData = { target: 0, production: 0 };
    
    // Get the hour's time in minutes
    const [hourVal, minuteVal] = hourStr.split(':').map(Number);
    const hourTimeMinutes = hourVal * 60 + minuteVal;
    
    // Process all variants to find those active during this hour
    currentProductVariants.forEach(variant => {
        const supervisorVariant = currentSupervisor ? 
            productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
        
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Check if this hour falls within this variant's window
        // For the current hour's targets and production, we need to look for the appropriate data
        // The key is that we need to find data for the current hour, not just any hour
        if (variant.hourlyTargets && variant.hourlyProduction) {
            const targetItem = variant.hourlyTargets.find(item => item.hour === hourStr);
            const productionItem = variant.hourlyProduction.find(item => item.hour === hourStr);
            
            if (targetItem || productionItem) {
                activeVariants.push(variant);
                
                // Add target and production data
                if (targetItem) {
                    hourlyData.target += targetItem.target || 0;
                }
                
                if (productionItem) {
                    hourlyData.production += productionItem.production || 0;
                }
            }
        }
    });
    
    // If no variants are active during this hour, show message
    if (activeVariants.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No variants active during this hour</div>';
        return;
    }
    
    // Draw hourly chart
    const svgWidth = chartContainer.clientWidth || 600;
    const svgHeight = chartContainer.clientHeight || 370;
    const padding = commonChartPadding;
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.style.display = 'block';
    svg.style.margin = '0 auto';
    chartContainer.appendChild(svg);
    
    const maxValue = Math.max(hourlyData.production, hourlyData.target, 1) * 1.2;
    
    // Add grid with larger fonts
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 15);
        text.setAttribute('y', y + 6);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title with larger font
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 50);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', '18');
    yAxisTitle.setAttribute('class', 'chart-axis-label');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 50}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add axes
    const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    vLine.setAttribute('x1', padding.left);
    vLine.setAttribute('y1', padding.top);
    vLine.setAttribute('x2', padding.left);
    vLine.setAttribute('y2', svgHeight - padding.bottom);
    vLine.setAttribute('stroke', '#666');
    vLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(vLine);
    
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', padding.left);
    xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
    xAxisLine.setAttribute('x2', svgWidth - padding.right);
    xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
    xAxisLine.setAttribute('stroke', '#666');
    xAxisLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxisLine);
    svg.appendChild(gridGroup);
    
    // Draw bars
    const barWidth = 80;
    const barSpacing = 60;
    const startX = svgWidth / 2 - barWidth - barSpacing / 2;
    
    // Production bar
    const productionBarHeight = (hourlyData.production / maxValue) * chartHeight;
    const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    productionBar.setAttribute('x', startX);
    productionBar.setAttribute('y', padding.top + chartHeight - productionBarHeight);
    productionBar.setAttribute('width', barWidth);
    productionBar.setAttribute('height', productionBarHeight);
    productionBar.setAttribute('fill', 'var(--production-color)');
    productionBar.setAttribute('rx', '5');
    svg.appendChild(productionBar);
    
    // Target bar
    const targetBarHeight = (hourlyData.target / maxValue) * chartHeight;
    const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    targetBar.setAttribute('x', startX + barWidth + barSpacing);
    targetBar.setAttribute('y', padding.top + chartHeight - targetBarHeight);
    targetBar.setAttribute('width', barWidth);
    targetBar.setAttribute('height', targetBarHeight);
    targetBar.setAttribute('fill', 'var(--target-color)');
    targetBar.setAttribute('rx', '5');
    svg.appendChild(targetBar);
    
    // Add production value text with larger font
    const productionValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    productionValueText.setAttribute('x', startX + barWidth / 2);
    productionValueText.setAttribute('y', padding.top + chartHeight - productionBarHeight - 20);
    productionValueText.setAttribute('text-anchor', 'middle');
    productionValueText.setAttribute('font-size', '22');
    productionValueText.setAttribute('class', 'chart-data-label');
    productionValueText.setAttribute('font-weight', '600');
    productionValueText.setAttribute('fill', 'var(--production-color)');
    productionValueText.textContent = hourlyData.production;
    svg.appendChild(productionValueText);
    
    // Add target value text with larger font
    const targetValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetValueText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
    targetValueText.setAttribute('y', padding.top + chartHeight - targetBarHeight - 20);
    targetValueText.setAttribute('text-anchor', 'middle');
    targetValueText.setAttribute('font-size', '22');
    targetValueText.setAttribute('class', 'chart-data-label');
    targetValueText.setAttribute('font-weight', '600');
    targetValueText.setAttribute('fill', 'var(--target-color)');
    targetValueText.textContent = hourlyData.target;
    svg.appendChild(targetValueText);
    
    // Add labels with larger font
    const productionLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    productionLabelText.setAttribute('x', startX + barWidth / 2);
    productionLabelText.setAttribute('y', svgHeight - padding.bottom + 35);
    productionLabelText.setAttribute('text-anchor', 'middle');
    productionLabelText.setAttribute('font-size', '18');
    productionLabelText.setAttribute('font-weight', '500');
    productionLabelText.setAttribute('fill', 'var(--production-color)');
    productionLabelText.textContent = 'ACTUAL';
    svg.appendChild(productionLabelText);
    
    const targetLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetLabelText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
    targetLabelText.setAttribute('y', svgHeight - padding.bottom + 35);
    targetLabelText.setAttribute('text-anchor', 'middle');
    targetLabelText.setAttribute('font-size', '18');
    targetLabelText.setAttribute('font-weight', '500');
    targetLabelText.setAttribute('fill', 'var(--target-color)');
    targetLabelText.textContent = 'TARGET';
    svg.appendChild(targetLabelText);
    
    // X axis line
    const xAxisLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine2.setAttribute('x1', padding.left);
    xAxisLine2.setAttribute('y1', padding.top + chartHeight);
    xAxisLine2.setAttribute('x2', svgWidth - padding.right);
    xAxisLine2.setAttribute('y2', padding.top + chartHeight);
    xAxisLine2.setAttribute('stroke', '#666');
    xAxisLine2.setAttribute('stroke-width', '1.5');
    svg.appendChild(xAxisLine2);
    
    // Add active variants list with larger font
    if (activeVariants.length > 1) {
        const activeVariantsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        activeVariantsText.setAttribute('x', svgWidth / 2);
        activeVariantsText.setAttribute('y', padding.top + chartHeight + 60);
        activeVariantsText.setAttribute('text-anchor', 'middle');
        activeVariantsText.setAttribute('font-size', '16');
        activeVariantsText.setAttribute('fill', '#666');
        
        const variantNames = activeVariants.map(v => {
            // Extract variant name from full string
            let displayName = v.variant;
            if (v.variant.includes('-')) {
                displayName = v.variant.split('-').pop();
            } else if (v.variant.startsWith(currentProduct + ' ')) {
                displayName = v.variant.substring(currentProduct.length + 1);
            }
            return displayName;
        });
        
        if (variantNames.length <= 2) {
            activeVariantsText.textContent = `Active variants: ${variantNames.join(', ')}`;
        } else {
            activeVariantsText.textContent = `${variantNames.length} active variants`;
        }
        svg.appendChild(activeVariantsText);
    }
}

        // Function to render hourly targets
        function renderHourlyTargets(group) {
            const container = document.getElementById('hourly-targets-grid');
            container.innerHTML = '';
            
            // Get all hourly targets and production for this product group
            const hourlyData = new Map();
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Combine hourly data from all variants
            group.variants.forEach(variant => {
                // Get variant time window
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                // Process hourly targets and production
                if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets) &&
                    variant.hourlyProduction && Array.isArray(variant.hourlyProduction)) {
                    
                    // Create a map of hour -> {target, production}
                    const hours = new Set([
                        ...variant.hourlyTargets.map(h => h.hour),
                        ...variant.hourlyProduction.map(h => h.hour)
                    ]);
                    
                    hours.forEach(hour => {
                        const target = variant.hourlyTargets.find(h => h.hour === hour)?.target || 0;
                        const production = variant.hourlyProduction.find(h => h.hour === hour)?.production || 0;
                        
                        if (!hourlyData.has(hour)) {
                            hourlyData.set(hour, { target, production });
                        } else {
                            const existing = hourlyData.get(hour);
                            hourlyData.set(hour, {
                                target: existing.target + target,
                                production: existing.production + production
                            });
                        }
                    });
                }
            });
            
            // Sort hours
            const sortedHours = Array.from(hourlyData.keys()).sort((a, b) => {
                const [hourA, minuteA] = a.split(':').map(Number);
                const [hourB, minuteB] = b.split(':').map(Number);
                return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
            });
            
            // Create hourly target items
            sortedHours.forEach(hour => {
                const data = hourlyData.get(hour);
                const [hourVal, minuteVal] = hour.split(':').map(Number);
                const hourMinutes = hourVal * 60 + minuteVal;
                
                // Determine status
                let status;
                let statusSymbol;
                
                if (currentTimeMinutes < hourMinutes - 30) {
                    // Upcoming hour
                    status = 'status-upcoming';
                    statusSymbol = '';
                } else if (currentTimeMinutes >= hourMinutes + 30) {
                    // Past hour - check if target was met
                    if (data.production >= data.target) {
                        status = 'status-met';
                        statusSymbol = '';
                    } else {
                        status = 'status-missed';
                        statusSymbol = '';
                    }
                } else {
                    // Current hour
                    status = 'status-current';
                    statusSymbol = 'NOW';
                }
                
                // Create hourly target item
                const item = document.createElement('div');
                item.className = `hourly-target-item ${status}`;
                
                const timeElement = document.createElement('div');
                timeElement.className = 'hourly-target-time';
                timeElement.textContent = hour;
                
                const statusElement = document.createElement('div');
                statusElement.className = 'hourly-target-status';
                statusElement.textContent = statusSymbol;
                
                item.appendChild(timeElement);
                item.appendChild(statusElement);
                container.appendChild(item);
            });
        }

        // Initialize the dashboard when the window loads
        window.onload = initDashboard;
    </script>
</body>
</html>

