function renderCumulativeChart(variant) {
            const chartContainer = document.getElementById('cumulative-chart');
            chartContainer.innerHTML = '';

            // Prepare data by mapping cumulativeProduction and cumulativeTargets into a table
            const hours = [
                "08:30", "09:30", "10:30", "11:30", "12:30", "13:30", 
                "14:30", "15:30", "16:30", "17:30", "18:30"
            ];
            const dataMap = new Map();

            // Map cumulative targets to include all hours
            if (variant.cumulativeTargets && Array.isArray(variant.cumulativeTargets)) {
                variant.cumulativeTargets.forEach(item => {
                    dataMap.set(item.hour, { hour: item.hour, target: item.target || 0, production: 0 });
                });
            }

            // Map cumulative production to include all hours
            if (variant.cumulativeProduction && Array.isArray(variant.cumulativeProduction)) {
                variant.cumulativeProduction.forEach(item => {
                    if (dataMap.has(item.hour)) {
                        dataMap.get(item.hour).production = item.production || 0;
                    } else {
                        dataMap.set(item.hour, { hour: item.hour, target: 0, production: item.production || 0 });
                    }
                });
            }

            // Fill in missing hours with zeros
            hours.forEach(hour => {
                if (!dataMap.has(hour)) {
                    dataMap.set(hour, { hour, target: 0, production: 0 });
                }
            });

            // Sort the data by hour
            const sortedData = Array.from(dataMap.values()).sort((a, b) => {
                const timeA = a.hour.split(':').map(Number);
                const timeB = b.hour.split(':').map(Number);
                if (timeA[0] !== timeB[0]) return timeA[0] - timeB[0];
                return timeA[1] - timeB[1];
            });

            if (sortedData.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
                return;
            }

            // Find max value for scaling
            let maxValue = 0;
            sortedData.forEach(item => {
                maxValue = Math.max(maxValue, item.target || 0, item.production || 0);
            });
            maxValue = maxValue * 1.1; // Add some headroom

            // Create container with positioning for absolute elements
            const chartWrapper = document.createElement('div');
            chartWrapper.style.position = 'relative';
            chartWrapper.style.width = '100%';
            chartWrapper.style.height = '100%';

            // Create grid and labels
            const gridEl = document.createElement('div');
            gridEl.className = 'line-chart-grid';
            gridEl.style.position = 'absolute';
            gridEl.style.top = '0';
            gridEl.style.left = '0';
            gridEl.style.width = '100%';
            gridEl.style.height = '100%';
            chartWrapper.appendChild(gridEl);

            const labels = document.createElement('div');
            labels.className = 'line-chart-labels';
            labels.style.position = 'absolute';
            labels.style.bottom = '0';
            labels.style.left = '0';
            labels.style.width = '100%';
            labels.style.display = 'flex';
            labels.style.justifyContent = 'space-between';
            sortedData.forEach((item, index) => {
                const label = document.createElement('div');
                label.textContent = item.hour;
                label.style.flex = '1';
                label.style.textAlign = 'center';
                labels.appendChild(label);
            });
            chartWrapper.appendChild(labels);

            // Function to create line with points
            function createLine(dataType, color) {
                const lineContainer = document.createElement('div');
                lineContainer.style.position = 'absolute';
                lineContainer.style.top = '0';
                lineContainer.style.left = '0';
                lineContainer.style.width = '100%';
                lineContainer.style.height = '100%';

                // Create line path
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';

                const path = document.createElementNS(svgNS, 'path');
                path.style.fill = 'none';
                path.style.stroke = color;
                path.style.strokeWidth = '2';

                const points = sortedData.map((item, index) => {
                    const value = item[dataType];
                    const percentage = (value / maxValue) * 100;
                    return {
                        x: (index / (sortedData.length - 1)) * 100,
                        y: 100 - percentage
                    };
                });

                let pathData = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    pathData += ` L ${points[i].x} ${points[i].y}`;
                }
                path.setAttribute('d', pathData);
                svg.appendChild(path);
                lineContainer.appendChild(svg);

                // Create points
                points.forEach((point, index) => {
                    const pointEl = document.createElement('div');
                    pointEl.style.position = 'absolute';
                    pointEl.style.width = '6px';
                    pointEl.style.height = '6px';
                    pointEl.style.borderRadius = '50%';
                    pointEl.style.backgroundColor = color;
                    pointEl.style.left = `${point.x}%`;
                    pointEl.style.top = `${point.y}%`;
                    pointEl.style.transform = 'translate(-50%, -50%)';
                    lineContainer.appendChild(pointEl);
                });

                return lineContainer;
            }

            // Create and add lines
            const productionLine = createLine('production', 'var(--secondary-color)');
            const targetLine = createLine('target', 'var(--success-color)');

            chartWrapper.appendChild(productionLine);
            chartWrapper.appendChild(targetLine);

            chartContainer.appendChild(chartWrapper);
            chartContainer.style.position = 'relative';
            chartContainer.style.width = '100%';
            chartContainer.style.height = '100%';
        }
