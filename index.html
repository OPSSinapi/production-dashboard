<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Dashboard</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://unpkg.com/recharts/umd/Recharts.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const { 
            LineChart, 
            Line, 
            BarChart, 
            Bar, 
            XAxis, 
            YAxis, 
            CartesianGrid, 
            Tooltip, 
            Legend, 
            ResponsiveContainer 
        } = Recharts;

        const ProductionDashboard = () => {
            const [productionData, setProductionData] = useState(null);
            const [currentVariantIndex, setCurrentVariantIndex] = useState(0);
            const [isAutocycling, setIsAutocycling] = useState(true);
            const [currentTime, setCurrentTime] = useState(new Date());
            const [lastUpdated, setLastUpdated] = useState("Never");
            const [loadFallback, setLoadFallback] = useState(false);
            const [selectedSupervisor, setSelectedSupervisor] = useState('all');

            // Fetch production data
            useEffect(() => {
                const fetchProductionData = async () => {
                    try {
                        // Use raw github URL to fetch the data
                        const response = await fetch('https://raw.githubusercontent.com/OPSSinapi/production-dashboard/main/data.json', {
                            cache: 'no-store',
                            headers: {
                                'Cache-Control': 'no-cache'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }

                        const data = await response.json();
                        console.log("Fetched data successfully");
                        setProductionData(data);
                        setLastUpdated(new Date(data.timestamp).toLocaleString());
                    } catch (error) {
                        console.error('Error fetching production data:', error);
                        if (loadFallback) {
                            useFallbackData();
                        }
                    }
                };

                fetchProductionData();
                
                // Set a timeout to load fallback data if fetch fails
                const fallbackTimeout = setTimeout(() => {
                    if (!productionData) {
                        setLoadFallback(true);
                    }
                }, 5000);
                
                // Refresh data every minute
                const dataInterval = setInterval(fetchProductionData, 60000);

                return () => {
                    clearInterval(dataInterval);
                    clearTimeout(fallbackTimeout);
                };
            }, [loadFallback]);

            // Auto-cycling and time update logic
            useEffect(() => {
                // Update current time every minute
                const timeInterval = setInterval(() => {
                    setCurrentTime(new Date());
                }, 60000);

                // If we don't have data yet or auto-cycling is off, don't set up cycling
                if (!productionData || !isAutocycling) {
                    return () => clearInterval(timeInterval);
                }

                // Set up auto-cycling between variants
                const cycleInterval = setInterval(() => {
                    setCurrentVariantIndex((prev) => {
                        const filteredVariants = filterVariantsBySupervisor(productionData, selectedSupervisor);
                        return (prev + 1) % filteredVariants.length;
                    });
                }, 10000);

                return () => {
                    clearInterval(timeInterval);
                    clearInterval(cycleInterval);
                };
            }, [productionData, isAutocycling, selectedSupervisor]);

            // Filter variants by supervisor
            const filterVariantsBySupervisor = (data, supervisorName) => {
                if (!data || !data.variants) return [];
                
                if (supervisorName === 'all') {
                    return data.variants;
                }
                
                const supervisor = data.supervisors.find(s => s.name === supervisorName);
                if (!supervisor || !supervisor.variants) return [];
                
                const supervisorVariantNames = Object.keys(supervisor.variants);
                return data.variants.filter(variant => 
                    supervisorVariantNames.includes(variant.variant));
            };

            // Fallback data if fetch fails
            const useFallbackData = () => {
                const fallbackData = {
                    timestamp: new Date().toISOString(),
                    variants: [{
                        variant: "TEST Product XYZ",
                        cycleTime: 45,
                        hourlyTarget: 80,
                        dailyTarget: 320,
                        currentTotal: 318,
                        progressPercentage: 99,
                        cumulativeTargets: [
                            { hour: "07:30", target: 80 },
                            { hour: "08:30", target: 160 },
                            { hour: "09:30", target: 240 },
                            { hour: "10:30", target: 320 }
                        ],
                        cumulativeProduction: [
                            { hour: "07:30", production: 65 },
                            { hour: "08:30", production: 143 },
                            { hour: "09:30", production: 235 },
                            { hour: "10:30", production: 318 }
                        ],
                        hourlyTargets: [
                            { hour: "07:30", target: 80 },
                            { hour: "08:30", target: 80 },
                            { hour: "09:30", target: 80 },
                            { hour: "10:30", target: 80 }
                        ],
                        hourlyProduction: [65, 78, 92, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                    }],
                    supervisors: [{
                        name: "TEST Supervisor",
                        variants: {
                            "TEST Product XYZ": {
                                variant: "TEST Product XYZ",
                                currentTotal: 318,
                                dailyTarget: 320,
                                progressPercentage: 99
                            }
                        },
                        totalProduction: 318,
                        totalTarget: 320,
                        progressPercentage: 99
                    }]
                };
                
                setProductionData(fallbackData);
                setLastUpdated("Using fallback data");
            };

            // If data is not loaded yet
            if (!productionData) {
                return (
                    <div className="flex items-center justify-center min-h-screen text-2xl">
                        <div className="text-center">
                            <p>Loading production data...</p>
                            <p className="text-sm text-gray-500 mt-2">
                                If this takes too long, fallback data will be used.
                            </p>
                        </div>
                    </div>
                );
            }

            // Get filtered variants based on selected supervisor
            const filteredVariants = filterVariantsBySupervisor(productionData, selectedSupervisor);
            
            // If no variants match the filter, show error message
            if (filteredVariants.length === 0) {
                return (
                    <div className="flex items-center justify-center min-h-screen text-2xl">
                        <div className="text-center">
                            <p>No variants found for selected supervisor</p>
                            <button 
                                onClick={() => setSelectedSupervisor('all')}
                                className="px-4 py-2 mt-4 rounded bg-blue-500 text-white"
                            >
                                Show All Variants
                            </button>
                        </div>
                    </div>
                );
            }

            // Make sure currentVariantIndex is valid
            if (currentVariantIndex >= filteredVariants.length) {
                setCurrentVariantIndex(0);
            }

            // Extract current variant
            const currentVariant = filteredVariants[currentVariantIndex];

            // Prepare data for line chart
            const prepareLineChartData = (variant) => {
                // Create a map to hold data for each hour
                const dataMap = new Map();
                
                // Add all target hours to the map
                if (variant.cumulativeTargets && variant.cumulativeTargets.length > 0) {
                    variant.cumulativeTargets.forEach(item => {
                        if (!dataMap.has(item.hour)) {
                            dataMap.set(item.hour, { name: item.hour, target: item.target, production: 0 });
                        } else {
                            dataMap.get(item.hour).target = item.target;
                        }
                    });
                }
                
                // Add all production hours to the map
                if (variant.cumulativeProduction && variant.cumulativeProduction.length > 0) {
                    variant.cumulativeProduction.forEach(item => {
                        if (!dataMap.has(item.hour)) {
                            dataMap.set(item.hour, { name: item.hour, target: 0, production: item.production });
                        } else {
                            dataMap.get(item.hour).production = item.production;
                        }
                    });
                }
                
                // Convert map to array and sort by hour
                const chartData = Array.from(dataMap.values()).sort((a, b) => {
                    // Convert times to comparable values (assuming HH:MM format)
                    const timeA = a.name.split(':').map(Number);
                    const timeB = b.name.split(':').map(Number);
                    
                    if (timeA[0] !== timeB[0]) {
                        return timeA[0] - timeB[0];
                    }
                    return timeA[1] - timeB[1];
                });
                
                return chartData;
            };

            // Prepare data for bar chart
            const prepareBarChartData = (variant) => {
                const now = new Date();
                const hour = now.getHours();
                
                // Find the closest hourly target (they're in HH:30 format)
                const hourStr = `${hour.toString().padStart(2, '0')}:30`;
                const targetEntry = variant.hourlyTargets && variant.hourlyTargets.find(t => t.hour === hourStr);
                const target = targetEntry ? targetEntry.target : variant.hourlyTarget;
                
                // Get hourly production (if available) for current hour
                const production = variant.hourlyProduction && variant.hourlyProduction[hour] || 0;
                
                return [{
                    name: hourStr,
                    Production: production,
                    Target: target
                }];
            };

            // Get latest cumulative production
            const getLatestCumulativeProduction = (variant) => {
                if (!variant.cumulativeProduction || variant.cumulativeProduction.length === 0) {
                    return variant.currentTotal || 0;
                }
                
                // Return the latest cumulative production
                const sortedProduction = [...variant.cumulativeProduction].sort((a, b) => {
                    const timeA = a.hour.split(':').map(Number);
                    const timeB = b.hour.split(':').map(Number);
                    
                    if (timeA[0] !== timeB[0]) {
                        return timeB[0] - timeA[0]; // Sort in descending order
                    }
                    return timeB[1] - timeA[1];
                });
                
                return sortedProduction[0].production;
            };

            const lineChartData = prepareLineChartData(currentVariant);
            const barChartData = prepareBarChartData(currentVariant);
            const latestProduction = getLatestCumulativeProduction(currentVariant);

            return (
                <div className="bg-gray-100 min-h-screen p-4">
                    {/* Header */}
                    <div className="text-center mb-4">
                        <h1 className="text-4xl font-bold text-gray-800">Production Dashboard</h1>
                        <p className="text-2xl text-gray-600">Medical Device Assembly Plant</p>
                    </div>

                    {/* Supervisor Filter */}
                    <div className="mb-4 flex justify-end">
                        <select 
                            className="px-4 py-2 border rounded shadow"
                            value={selectedSupervisor}
                            onChange={(e) => {
                                setSelectedSupervisor(e.target.value);
                                setCurrentVariantIndex(0);
                            }}
                        >
                            <option value="all">All Supervisors</option>
                            {productionData.supervisors && productionData.supervisors.map(supervisor => (
                                <option key={supervisor.name} value={supervisor.name}>
                                    {supervisor.name}
                                </option>
                            ))}
                        </select>
                    </div>

                    {/* Main content */}
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                        {/* Variant header with auto-cycle button */}
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-3xl font-semibold text-gray-700">
                                Variant: {currentVariant.variant}
                            </h2>
                            <div className="flex items-center gap-4">
                                <div className="text-gray-500 text-lg">
                                    Cycle Time: <span className="font-bold">{currentVariant.cycleTime} sec</span>
                                </div>
                                <button 
                                    onClick={() => setIsAutocycling(!isAutocycling)}
                                    className={`px-4 py-2 rounded text-white ${isAutocycling ? 'bg-red-500' : 'bg-green-500'}`}
                                >
                                    {isAutocycling ? 'Stop Auto-Cycle' : 'Start Auto-Cycle'}
                                </button>
                            </div>
                        </div>

                        {/* Key Metrics Section */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                <span className="font-medium">Current Total:</span>
                                <span className="font-bold text-2xl">{currentVariant.currentTotal}</span>
                            </div>
                            <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                <span className="font-medium">Daily Target:</span>
                                <span className="font-bold text-2xl">{currentVariant.dailyTarget}</span>
                            </div>
                            <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                <span className="font-medium">Hourly Target:</span>
                                <span className="font-bold text-2xl">{currentVariant.hourlyTarget}</span>
                            </div>
                            <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                <span className="font-medium">Progress:</span>
                                <span className={`font-bold text-2xl ${
                                    currentVariant.progressPercentage >= 90 ? 'text-green-600' : 
                                    currentVariant.progressPercentage >= 70 ? 'text-blue-600' : 'text-red-600'
                                }`}>
                                    {currentVariant.progressPercentage}%
                                </span>
                            </div>
                            {currentVariant.dailyBoxTarget > 0 && (
                                <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                    <span className="font-medium">Boxes:</span>
                                    <span className="font-bold text-2xl">
                                        {currentVariant.currentBoxTotal} / {currentVariant.dailyBoxTarget}
                                    </span>
                                </div>
                            )}
                            <div className="flex justify-between p-4 bg-gray-50 rounded shadow">
                                <span className="font-medium">Latest Cumulative:</span>
                                <span className="font-bold text-2xl">{latestProduction}</span>
                            </div>
                        </div>

                        {/* Charts */}
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                            <div className="bg-gray-50 p-4 rounded-lg">
                                <h3 className="text-xl font-semibold mb-2">Cumulative Daily Production Progress</h3>
                                <ResponsiveContainer width="100%" height={300}>
                                    <LineChart data={lineChartData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Legend />
                                        <Line 
                                            type="monotone" 
                                            dataKey="production" 
                                            name="Cumulative Production" 
                                            stroke="#3B82F6" 
                                            strokeWidth={2}
                                            dot={{ r: 5 }}
                                            activeDot={{ r: 8 }}
                                        />
                                        <Line 
                                            type="monotone" 
                                            dataKey="target" 
                                            name="Cumulative Target" 
                                            stroke="#10B981" 
                                            strokeWidth={2}
                                            dot={{ r: 5 }}
                                            activeDot={{ r: 8 }}
                                        />
                                    </LineChart>
                                </ResponsiveContainer>
                            </div>

                            <div className="bg-gray-50 p-4 rounded-lg">
                                <h3 className="text-xl font-semibold mb-2">Hourly Production Progress</h3>
                                <ResponsiveContainer width="100%" height={300}>
                                    <BarChart data={barChartData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Legend />
                                        <Bar 
                                            dataKey="Production" 
                                            fill="#3B82F6"
                                            label={{ position: 'top' }}
                                        />
                                        <Bar 
                                            dataKey="Target" 
                                            fill="#10B981"
                                            label={{ position: 'top' }}
                                        />
                                    </BarChart>
                                </ResponsiveContainer>
                            </div>
                        </div>

                        {/* Batch Information */}
                        {currentVariant.batches && Object.keys(currentVariant.batches).length > 0 && (
                            <div className="bg-gray-50 p-4 rounded-lg">
                                <h3 className="text-xl font-semibold mb-4">Batch Information</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {Object.entries(currentVariant.batches).map(([batchId, batchData]) => (
                                        <div key={batchId} className="p-3 bg-white rounded shadow">
                                            <div className="font-medium">Batch: {batchId}</div>
                                            <div className="flex justify-between mt-1">
                                                <span>Total:</span>
                                                <span className="font-bold">{batchData.total}</span>
                                            </div>
                                            <div className="flex justify-between">
                                                <span>Boxes:</span>
                                                <span className="font-bold">{batchData.boxes}</span>
                                            </div>
                                        </div>
