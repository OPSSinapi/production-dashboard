<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <link rel="icon" href="data:,">
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        :root {
    --primary-color: #2c3e50;
    --secondary-color: #3B82F6;
    --success-color: #10B981;
    --warning-color: #F59E0B;
    --danger-color: #e74c3c;
    --light-color: #f3f4f6;
    --dark-color: #1e293b;
    --supervisor-luthando: #F9E79F;
    --supervisor-apelele: #e6e6e6; /* Light grey for Apelele */
    --supervisor-siyabonga: #FADBD8;
    --supervisor-nosi: #D6EAF8;
    --supervisor-mvokwe: #D5F5E3;
    --supervisor-michaela: #F9E79F; /* Same as Luthando for Michaela */
    --production-color: #e74c3c; /* Red for production */
    --target-color: #10B981; /* Green for target */
    --current-indicator: #F59E0B; /* Yellow for current time indicator */
    --completed-variant: #D1E7DD; /* Light green for completed variants */
    --current-variant: #FFF3CD; /* Light yellow for current variant */
    --upcoming-variant: #F8D7DA; /* Light red for upcoming variants */
    --legend-bg: #f8fafc; /* Background color for legend section */
    --status-met: #D1E7DD; /* Status indicator - met target */
    --status-missed: #FECDD3; /* Status indicator - missed target */
    --status-current: #FEF9C3; /* Status indicator - current hour */
}

/* CSS Reset for more consistent rendering */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
}

body {
    font-family: Arial, Helvetica, sans-serif; /* More readable font for distance viewing */
    background-color: var(--light-color);
    color: var(--primary-color);
    transition: background-color 0.3s ease;
}

.dashboard-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    padding: clamp(0.5rem, 1vw, 1rem);
    transition: all 0.3s ease;
}

/* ===== IMPROVED FULLSCREEN MODE CSS ===== */
.dashboard-container.fullscreen-mode {
    padding: clamp(0.25rem, 0.5vw, 0.5rem);
}

/* ===== HEADER STYLES ===== */
.supervisor-color-banner {
    width: 100%;
    height: clamp(0.5rem, 1vh, 1.25rem);
    border-radius: 3px;
    margin-bottom: clamp(0.15rem, 0.3vh, 0.3rem);
    transition: height 0.3s ease;
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    padding-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    min-height: fit-content;
    flex-shrink: 0;
}

.title-section {
    display: flex;
    align-items: center;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.title {
    font-size: clamp(1.4rem, 2.2vw, 2.8rem); /* Increased font size */
    font-weight: bold;
    color: var(--primary-color);
    white-space: nowrap;
}

.controls-section {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.filter-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.filter-select {
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    min-width: clamp(120px, 10vw, 180px);
    background-color: white;
}

.buttons-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.supervisor-select-btn {
    background-color: var(--secondary-color);
    color: white;
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    min-width: clamp(100px, 8vw, 140px);
    white-space: nowrap;
    transition: all 0.2s ease;
}

.supervisor-select-btn:hover {
    background-color: #2563eb;
}

.fullscreen-button {
    background-color: #e2e8f0;
    color: var(--dark-color);
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s ease;
}

.fullscreen-button:hover {
    background-color: #cbd5e1;
}

.date-time {
    text-align: right;
    white-space: nowrap;
}

.time {
    font-size: clamp(1.2rem, 1.8vw, 2.2rem); /* Increased font size */
    font-weight: bold;
}

/* ===== LEGEND SECTION ===== */
.legend-section {
    width: 100%;
    background-color: var(--legend-bg);
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.75rem, 1.25vw, 1.25rem);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    border-radius: 0.5rem;
    flex-shrink: 0;
}

.legend-container {
    display: flex;
    flex-wrap: wrap;
    gap: clamp(1rem, 3vw, 3rem);
}

.legend-item {
    display: flex;
    align-items: center;
}

.legend-color {
    width: clamp(1.5rem, 2.2vw, 2.5rem); /* Increased size */
    height: clamp(1.5rem, 2.2vw, 2.5rem); /* Increased size */
    margin-right: clamp(0.25rem, 0.5vw, 0.5rem);
    border-radius: 5px;
}

.legend-label {
    font-size: clamp(1rem, 1.4vw, 1.6rem); /* Increased font size */
    font-weight: 700; /* Made bolder */
    white-space: nowrap;
}

.current-hour-info {
    font-size: clamp(1rem, 1.4vw, 1.6rem); /* Increased font size */
    color: var(--secondary-color);
    font-weight: 700; /* Made bolder */
    white-space: nowrap;
    text-align: right;
}

/* ===== CONTENT CONTAINER ===== */
.content {
    display: flex;
    flex-direction: column; /* Changed to column layout */
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

/* Add a new charts-row class */
.charts-row {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.main-content {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex-shrink: 0; /* Don't shrink the top content */
    overflow: visible;
}

/* ===== TOP ROW WITH SUPERVISOR AND METRICS ===== */
.top-row {
    display: flex;
    gap: clamp(0.5rem, 1vw, 1rem);
    width: 100%;
    flex-shrink: 0;
    overflow: visible;
}

/* ===== SUPERVISOR INFO PANEL ===== */
.supervisor-panel {
    flex: 0 0 clamp(250px, 25vw, 450px);
    background-color: var(--supervisor-mvokwe);
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    display: flex;
    flex-direction: column;
}

.supervisor-name {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    color: var(--dark-color);
}

.product-name {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem); /* Increased font size */
    color: var(--dark-color);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
}

.variant-sequence {
    display: flex;
    align-items: center;
    font-size: clamp(0.9rem, 1.2vw, 1.4rem); /* Increased font size */
    flex-wrap: wrap;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    margin-top: auto;
}

.variant-item {
    padding: clamp(0.35rem, 0.75vh, 0.75rem) clamp(0.5rem, 1vw, 1rem);
    border-radius: 8px;
    white-space: nowrap;
    position: relative;
    text-align: center;
    min-width: clamp(60px, 7vw, 100px);
}

.variant-item.completed {
    background-color: var(--completed-variant);
    color: var(--dark-color);
}

.variant-item.current {
    background-color: var(--current-variant);
    color: var(--dark-color);
    font-weight: bold;
}

.variant-item.upcoming {
    background-color: var(--upcoming-variant);
    color: var(--dark-color);
}

.arrow-right {
    margin: 0 clamp(0.1rem, 0.25vw, 0.25rem);
    font-size: clamp(1.1rem, 1.45vw, 1.7rem); /* Increased font size */
    color: var(--dark-color);
}

/* ===== METRICS CARDS ===== */
.metrics-container {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.metric-card {
    flex: 1 1 clamp(150px, 15vw, 300px);
    min-width: clamp(120px, 15vw, 200px);
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.metric-title {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    color: var(--primary-color);
    text-align: center;
}

.metric-value {
    font-size: clamp(1.8rem, 2.8vw, 3.4rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    text-align: center;
}

.metric-subvalue {
    font-size: clamp(0.9rem, 1.3vw, 1.6rem); /* Increased font size */
    text-align: center;
}

.current-value {
    color: var(--production-color);
}

.target-value {
    color: var(--target-color);
}

/* ===== CHARTS SECTION ===== */
.charts-container {
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    position: relative;
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
}

.chart-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Increased font size */
    font-weight: 600;
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    color: var(--primary-color);
    flex-shrink: 0;
    text-align: center;
}

.chart-area {
    flex: 1;
    position: relative;
    min-height: 0;
    overflow: hidden;
}

.chart {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 1;
    transition: opacity 0.5s ease;
}

.chart.hidden {
    opacity: 0;
    pointer-events: none;
}

.chart-nav {
    display: flex;
    justify-content: center;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-top: clamp(0.5rem, 1vh, 1rem);
}

.chart-nav-dot {
    width: clamp(0.8rem, 1.3vw, 1.2rem); /* Increased size */
    height: clamp(0.8rem, 1.3vw, 1.2rem); /* Increased size */
    border-radius: 50%;
    background-color: #cbd5e1;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
}

.chart-nav-dot.active {
    background-color: var(--secondary-color);
    transform: scale(1.2);
}

/* ===== BATCH INFO SECTION (NEW) ===== */
.batch-info-section {
    flex: 0 0 clamp(375px, 32vw, 650px); /* Increased width for better display of content */
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    max-height: 100%;
}

.batch-info-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Large font size */
    font-weight: bold;
    margin-bottom: clamp(0.75rem, 1.5vh, 1.5rem);
    color: var(--primary-color);
    text-align: center;
}

.batch-info-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
}

.batch-info-table th {
    background-color: var(--primary-color);
    color: white;
    font-size: clamp(0.9rem, 1.3vw, 1.6rem); /* Increased font size */
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.25rem, 0.5vw, 0.5rem);
    text-align: left;
    position: sticky;
    top: 0;
}

.batch-info-table td {
    font-size: clamp(0.85rem, 1.2vw, 1.5rem); /* Increased font size */
    padding: clamp(0.4rem, 0.8vh, 0.8rem) clamp(0.25rem, 0.5vw, 0.5rem);
    border-bottom: 1px solid #e2e8f0;
}

.batch-info-table tr:nth-child(even) {
    background-color: #f8fafc;
}

.batch-info-table tr:hover {
    background-color: #e9f5fd;
}

.batch-info-table tr.current {
    background-color: var(--current-variant);
}

.batch-number {
    font-weight: bold;
}

/* ===== FOOTER ===== */
.footer {
    margin-top: clamp(0.25rem, 0.5vh, 0.5rem);
    font-size: clamp(0.85rem, 1.1vw, 1.3rem); /* Increased font size */
    color: var(--dark-color);
    width: 100%;
    flex-shrink: 0;
}

.update-info {
    text-align: left;
}

/* ===== SUPERVISOR SELECTION MODAL ===== */
.supervisor-select-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(2px);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from {opacity: 0}
    to {opacity: 1}
}

.supervisor-select-content {
    position: relative;
    background-color: #fefefe;
    margin: 10vh auto;
    padding: 0;
    border-radius: 8px;
    width: clamp(300px, 80vw, 600px);
    max-height: 80vh;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    animation: slideIn 0.3s ease;
    display: flex;
    flex-direction: column;
}

@keyframes slideIn {
    from {transform: translateY(-50px); opacity: 0}
    to {transform: translateY(0); opacity: 1}
}

.supervisor-select-header {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.supervisor-select-header h3 {
    margin: 0;
    font-size: clamp(1.3rem, 1.7vw, 1.9rem); /* Increased font size */
    color: var(--dark-color);
}

.supervisor-select-close {
    color: #aaa;
    font-size: clamp(1.8rem, 2.5vw, 2.8rem); /* Increased font size */
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
}

.supervisor-select-close:hover {
    color: var(--dark-color);
}

.supervisor-select-body {
    padding: clamp(1rem, 2vw, 2rem);
    overflow-y: auto;
    flex: 1;
}

.supervisor-checkboxes {
    display: flex;
    flex-direction: column;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.supervisor-checkbox-item {
    display: flex;
    align-items: center;
    padding: clamp(0.5rem, 1vh, 1rem);
    border-radius: 6px;
    transition: background-color 0.2s;
}

.supervisor-checkbox-item:hover {
    background-color: #f8fafc;
}

.supervisor-checkbox-item input[type="checkbox"] {
    width: clamp(18px, 1.7vw, 22px); /* Increased size */
    height: clamp(18px, 1.7vw, 22px); /* Increased size */
    margin-right: clamp(0.5rem, 1vw, 1rem);
    cursor: pointer;
}

.supervisor-checkbox-item label {
    font-size: clamp(1.1rem, 1.4vw, 1.6rem); /* Increased font size */
    font-weight: 500;
    cursor: pointer;
    flex: 1;
}

.supervisor-select-footer {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: flex-end;
    gap: clamp(0.5rem, 1vw, 1rem);
    flex-shrink: 0;
}

/* ===== RESPONSIVE DESIGN - ADDITIONAL SCREEN SIZE OPTIMIZATIONS ===== */
/* Special optimization for very large screens (TVs) */
@media screen and (min-width: 2000px) {
    .chart-title {
        font-size: clamp(1.4rem, 2vw, 2.4rem);
    }
    
    .legend-label {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
    
    .current-hour-info {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
}

/* For smaller screens */
@media screen and (max-width: 1200px) {
    .charts-row {
        flex-direction: column; /* Stack charts and batch info on smaller screens */
    }
    
    .top-row {
        flex-direction: column;
    }
    
    .supervisor-panel {
        flex: 0 0 auto;
        width: 100%;
    }
    
    .metrics-container {
        width: 100%;
    }
    
    .batch-info-section {
        flex: 0 0 auto;
        width: 100%;
        max-height: 300px; /* Limit height on smaller screens */
    }
}

@media screen and (max-width: 768px) {
    .header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .controls-section {
        width: 100%;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .filter-container {
        width: 100%;
    }
    
    .filter-select {
        flex: 1;
    }
    
    .buttons-container {
        width: 100%;
    }
    
    .date-time {
        align-self: flex-end;
        margin-top: clamp(0.5rem, 1vh, 1rem);
    }
}

/* Special handling for landscape orientation on tablets and phones */
@media screen and (max-height: 768px) and (orientation: landscape) {
    .dashboard-container {
        padding: clamp(0.25rem, 0.5vw, 0.5rem);
    }
    
    .header {
        padding-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    }
    
    .legend-section {
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 1vw, 1rem);
    }
}
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Supervisor color banner -->
        <div class="supervisor-color-banner"></div>
        
        <!-- Header Section -->
        <div class="header">
            <div class="title-section">
                <div class="title">Sinapi Secondary Production Dashboard</div>
            </div>
            
            <div class="controls-section">
                <div class="filter-container">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                
                <div class="buttons-container">
                    <button id="supervisor-select-btn" class="supervisor-select-btn">
                        Select Supervisors
                    </button>
                    <button id="fullscreen-button" class="fullscreen-button">Fullscreen</button>
                </div>
            </div>
            
            <div class="date-time">
                <div class="time" id="current-time">Loading...</div>
            </div>
        </div>
        
        <!-- Legend Section -->
        <div class="legend-section">
            <div class="legend-container">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--production-color);"></div>
                    <div class="legend-label">PRODUCTION</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--target-color);"></div>
                    <div class="legend-label">TARGET</div>
                </div>
            </div>
            <div class="current-hour-info" id="current-hour-info">CURRENT HOUR: --:-- (-- MIN LEFT)</div>
        </div>
        
        <!-- Content wrapper for main and batch info -->
<div class="content">
    <!-- Main content area (top row section only) -->
    <div class="main-content">
        <!-- Top Row: Supervisor + Metrics -->
        <div class="top-row">
            <!-- Supervisor Panel -->
            <div class="supervisor-panel">
                <div class="supervisor-name" id="supervisor-name">SUPERVISOR: Loading...</div>
                <div class="product-name" id="product-name">PRODUCT: Loading...</div>
                
                <div class="variant-sequence" id="variant-sequence">
                    <div class="loading">Loading variants...</div>
                </div>
            </div>
            
            <!-- Metrics Container -->
            <div class="metrics-container">
                <!-- Units (renamed from Progress) -->
                <div class="metric-card">
                    <div class="metric-title">UNITS</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-units">0</span>/<span class="target-value" id="target-units">0</span>
                    </div>
                    <div class="metric-subvalue" id="progress-percentage">0%</div>
                </div>
                
                <!-- Boxes - NEXT TO UNITS -->
                <div class="metric-card">
                    <div class="metric-title">BOXES</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-boxes">0</span>/<span class="target-value" id="target-boxes">0</span>
                    </div>
                    <div class="metric-subvalue">completed</div>
                </div>
                
                <!-- Cycle Time -->
                <div class="metric-card">
                    <div class="metric-title">CYCLE TIME</div>
                    <div class="metric-value">
                        <span class="current-value" id="actual-cycle-time">0</span>/<span class="target-value" id="target-cycle-time">0</span>
                    </div>
                    <div class="metric-subvalue">seconds</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Charts Row: Charts + Batch Info -->
    <div class="charts-row">
        <!-- Charts Container - Now moved outside main-content -->
        <div class="charts-container">
            <div class="chart-title" id="chart-title">Production Progress</div>
            <div class="chart-area">
                <div class="chart" id="cumulative-chart"></div>
                <div class="chart hidden" id="hourly-chart"></div>
            </div>
            <div class="chart-nav">
                <div class="chart-nav-dot active" data-chart="cumulative"></div>
                <div class="chart-nav-dot" data-chart="hourly"></div>
            </div>
        </div>
        
        <!-- Batch Information Panel - Now in the charts row -->
        <div class="batch-info-section">
    <div class="batch-info-title">BATCH INFORMATION</div>
    <table class="batch-info-table" id="batch-info-table">
        <thead id="batch-info-thead">
            <!-- Table headers will be dynamically generated -->
        </thead>
        <tbody id="batch-info-tbody">
            <!-- Batch information will be populated dynamically -->
            <tr>
                <td colspan="5">Loading batch information...</td>
            </tr>
        </tbody>
    </table>
</div>
    </div>
</div>
        
        <!-- Footer -->
        <div class="footer">
            <div class="update-info" id="last-update">Last updated: Never</div>
        </div>
        
        <!-- Supervisor Selection Modal -->
        <div id="supervisor-select-modal" class="supervisor-select-modal">
            <div class="supervisor-select-content">
                <div class="supervisor-select-header">
                    <h3>Select Supervisors to Display</h3>
                    <span class="supervisor-select-close">&times;</span>
                </div>
                <div class="supervisor-select-body">
                    <div id="supervisor-checkboxes" class="supervisor-checkboxes">
                        <!-- Checkboxes will be added dynamically -->
                    </div>
                </div>
                <div class="supervisor-select-footer">
                    <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                    <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                    <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 30 * 1000; // 30 seconds update interval
        const CYCLE_INTERVAL = 20000; // 20 seconds cycle interval

        // State variables
        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        let cycleInterval = null; // For cycling between supervisors
        let cycleIndex = 0; // To track the current supervisor index
        
        // Variables for product-supervisor grouping
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;
        let selectedSupervisors = []; // Array to hold selected supervisors    
        let supervisorFilterActive = false; // Track if supervisor filter is active
        
        // Chart rotation variables
        let chartRotationInterval = null;
        let currentChartIndex = 0;
        const CHART_ROTATION_INTERVAL = 10000; // 10 seconds rotation interval

        // Responsive dimensions
        let viewportWidth, viewportHeight, chartWidth, chartHeight;

        // Dashboard element references
        let dashboardContainer, supervisorPanel, chartsRow;
        let fullscreenButton;

        // Initialize dashboard
        function initDashboard() {
            // Cache DOM references for better performance
            dashboardContainer = document.querySelector('.dashboard-container');
            supervisorPanel = document.querySelector('.supervisor-panel');
            fullscreenButton = document.getElementById('fullscreen-button');

            // Set up initial state
            updateDateTime();
            updateViewportDimensions();
            setInterval(updateDateTime, 1000);

            // Event listeners
            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            // Initialize supervisor selection
            initSupervisorSelection();
            
            // Chart rotation navigation setup
            setupChartNavigation();
            
            // Initialize data
            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            // Fullscreen event listeners
            fullscreenButton.addEventListener('click', toggleFullscreen);
            window.addEventListener('resize', handleResize);
            
            // Fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }
        
        // Setup chart navigation
        function setupChartNavigation() {
            const navDots = document.querySelectorAll('.chart-nav-dot');
            navDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    const chartType = this.getAttribute('data-chart');
                    showChart(chartType);
                    
                    // Reset rotation interval when manually clicked
                    if (chartRotationInterval) {
                        clearInterval(chartRotationInterval);
                        startChartRotation();
                    }
                });
            });
            
            // Start automatic rotation
            startChartRotation();
        }
        
        // Start chart rotation
        function startChartRotation() {
            if (chartRotationInterval) {
                clearInterval(chartRotationInterval);
            }
            
            chartRotationInterval = setInterval(() => {
                currentChartIndex = (currentChartIndex + 1) % 2;
                const chartType = currentChartIndex === 0 ? 'cumulative' : 'hourly';
                showChart(chartType);
            }, CHART_ROTATION_INTERVAL);
        }
        
       // Show specific chart
function showChart(chartType) {
    const cumulativeChart = document.getElementById('cumulative-chart');
    const hourlyChart = document.getElementById('hourly-chart');
    const chartTitle = document.getElementById('chart-title');
    const navDots = document.querySelectorAll('.chart-nav-dot');
    
    // Update nav dots
    navDots.forEach(dot => {
        if (dot.getAttribute('data-chart') === chartType) {
            dot.classList.add('active');
        } else {
            dot.classList.remove('active');
        }
    });
    
    if (chartType === 'cumulative') {
        currentChartIndex = 0;
        cumulativeChart.classList.remove('hidden');
        hourlyChart.classList.add('hidden');
        chartTitle.textContent = "TODAY'S PRODUCTION PROGRESS";
    } else {
        currentChartIndex = 1;
        cumulativeChart.classList.add('hidden');
        hourlyChart.classList.remove('hidden');
        
        // Get current hour for hourly chart title
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const displayHour = currentMinute < 30 ? currentHour : currentHour + 1;
        const hourStr = `${displayHour.toString().padStart(2, '0')}:30`;
        
        chartTitle.textContent = `CURRENT HOUR: ${hourStr} PRODUCTION`;
    }
}

        // Function to update viewport dimensions
        function updateViewportDimensions() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;
        }

        // Improved resize handler
        function handleResize() {
            updateViewportDimensions();
            
            // Only redraw if the change is significant
            if (Math.abs(window.innerWidth - viewportWidth) > 20 || 
                Math.abs(window.innerHeight - viewportHeight) > 20) {
                
                // Debounce the update for better performance
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(function() {
                    redrawDashboard();
                }, 250);
            }
        }

        // Redraw dashboard after layout changes
        function redrawDashboard() {
            // Force layout recalculation
            dashboardContainer.style.display = 'none';
            void dashboardContainer.offsetHeight; // Force reflow
            dashboardContainer.style.display = 'flex';
            
            // Update dashboard content
            updateDashboard();
        }

        // Completely redesigned fullscreen handling
        function toggleFullscreen() {
            if (!document.fullscreenElement && 
                !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && 
                !document.msFullscreenElement) {
                
                // Request fullscreen - try the standard way first
                try {
                    // First mark as fullscreen in our UI (before actual fullscreen request)
                    dashboardContainer.classList.add('fullscreen-mode');
                    isFullscreen = true;
                    fullscreenButton.textContent = 'Exit Fullscreen';
                    
                    // Then request actual browser fullscreen
                    if (dashboardContainer.requestFullscreen) {
                        dashboardContainer.requestFullscreen();
                    } else if (dashboardContainer.msRequestFullscreen) {
                        dashboardContainer.msRequestFullscreen();
                    } else if (dashboardContainer.mozRequestFullScreen) {
                        dashboardContainer.mozRequestFullScreen();
                    } else if (dashboardContainer.webkitRequestFullscreen) {
                        // Safari/Chrome specific handling
                        dashboardContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                    } else {
                        // Fallback for browsers without fullscreen API
                        simulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Fullscreen API error:', error);
                    // Fallback to simulated fullscreen
                    simulatedFullscreen();
                }
            } else {
                try {
                    // Exit browser fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else {
                        // Manual exit if no API support
                        exitSimulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Exiting fullscreen error:', error);
                    // Fallback
                    exitSimulatedFullscreen();
                }
            }
        }

        // Improved fullscreen change handler
        function handleFullscreenChange() {
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && 
                !document.msFullscreenElement) {
                
                // Only if we're currently in our fullscreen mode
                if (isFullscreen) {
                    exitFullscreenMode();
                }
            } else {
                // Browser entered fullscreen
                enterFullscreenMode();
            }
        }

        // Enter fullscreen mode - separated function for clarity
        function enterFullscreenMode() {
            if (!isFullscreen) {
                dashboardContainer.classList.add('fullscreen-mode');
                isFullscreen = true;
                fullscreenButton.textContent = 'Exit Fullscreen';
                
                // Force layout recalculation before chart updates
                setTimeout(function() {
                    updateViewportDimensions();
                    updateDashboard();
                }, 100);
            }
        }

        // Exit fullscreen mode - separated function
        function exitFullscreenMode() {
            dashboardContainer.classList.remove('fullscreen-mode');
            dashboardContainer.classList.remove('simulated-fullscreen');
            isFullscreen = false;
            fullscreenButton.textContent = 'Fullscreen';
            
            // Reset any inline styles from simulated fullscreen
            dashboardContainer.style.position = '';
            dashboardContainer.style.top = '';
            dashboardContainer.style.left = '';
            dashboardContainer.style.width = '';
            dashboardContainer.style.height = '';
            dashboardContainer.style.zIndex = '';
            document.body.style.overflow = '';
            
            // Force layout recalculation before chart updates
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        // Simulated fullscreen (fallback)
        function simulatedFullscreen() {
            dashboardContainer.classList.add('fullscreen-mode');
            dashboardContainer.classList.add('simulated-fullscreen');
            isFullscreen = true;
            fullscreenButton.textContent = 'Exit Fullscreen';
            
            // Apply styles directly for better fallback compatibility
            dashboardContainer.style.position = 'fixed';
            dashboardContainer.style.top = '0';
            dashboardContainer.style.left = '0';
            dashboardContainer.style.width = '100vw';
            dashboardContainer.style.height = '100vh';
            dashboardContainer.style.zIndex = '9999';
            document.body.style.overflow = 'hidden';
            
            // Force layout recalculation before chart updates
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        // Exit simulated fullscreen
        function exitSimulatedFullscreen() {
            exitFullscreenMode();
        }

        // Function to initialize the supervisor selection UI
        function initSupervisorSelection() {
            const selectBtn = document.getElementById('supervisor-select-btn');
            const modal = document.getElementById('supervisor-select-modal');
            const closeBtn = document.querySelector('.supervisor-select-close');
            const applyBtn = document.getElementById('apply-supervisor-selection');
            const selectAllBtn = document.getElementById('select-all-supervisors');
            const deselectAllBtn = document.getElementById('deselect-all-supervisors');
            
            // Open modal when button is clicked
            selectBtn.addEventListener('click', function() {
                updateSupervisorCheckboxes();
                modal.style.display = 'block';
            });
            
            // Close modal when X is clicked
            closeBtn.addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            // Close modal when clicking outside of it
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // Apply selection and close modal
            applyBtn.addEventListener('click', function() {
                applySupervisorSelection();
                modal.style.display = 'none';
            });
            
            // Select all supervisors
            selectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            });
            
            // Deselect all supervisors
            deselectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            });
            
            // Initialize with all supervisors selected
            if (productionData && productionData.supervisors) {
                selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
            }
        }

        // Function to update the supervisor checkboxes
        function updateSupervisorCheckboxes() {
            const checkboxContainer = document.getElementById('supervisor-checkboxes');
            checkboxContainer.innerHTML = '';
            
            if (!productionData || !productionData.supervisors || productionData.supervisors.length === 0) {
                checkboxContainer.innerHTML = '<p>No supervisors available</p>';
                return;
            }
            
            // Create a checkbox for each supervisor
            productionData.supervisors.forEach(supervisor => {
                const item = document.createElement('div');
                item.className = 'supervisor-checkbox-item';
                
                // Create color indicator
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = getSupervisorColor(supervisor.name);
                colorDiv.style.width = '16px';
                colorDiv.style.height = '16px';
                item.appendChild(colorDiv);
                
                // Create checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'supervisor-checkbox';
                checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
                checkbox.value = supervisor.name;
                checkbox.checked = selectedSupervisors.includes(supervisor.name);
                
                // Create label
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = supervisor.name;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                checkboxContainer.appendChild(item);
            });
        }

        // Function to apply supervisor selection
        function applySupervisorSelection() {
            const checkboxes = document.querySelectorAll('.supervisor-checkbox');
            selectedSupervisors = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedSupervisors.push(checkbox.value);
                }
            });
            
            // Store selection in localStorage for persistence
            localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
            
            // Update the selection button style based on whether filtering is active
            supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (supervisorFilterActive) {
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                selectBtn.classList.add('filtered');
            } else {
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
            }
            
            // Update the dashboard with the new selection
            updateDashboard();
        }

        // Function to get the supervisor color
        function getSupervisorColor(supervisorName) {
            const colorMap = {
                'Luthando': 'var(--supervisor-luthando)',
                'Apelele': 'var(--supervisor-apelele)',
                'Siyabonga': 'var(--supervisor-siyabonga)',
                'Nosi': 'var(--supervisor-nosi)',
                'Mvokwe': 'var(--supervisor-mvokwe)',
                'Michaela': 'var(--supervisor-michaela)'
            };
            
            return colorMap[supervisorName] || '#e2e8f0'; // Default color if not found
        }

        // Function to load selected supervisors from localStorage
        function loadSelectedSupervisors() {
            const stored = localStorage.getItem('selectedSupervisors');
            if (stored) {
                try {
                    selectedSupervisors = JSON.parse(stored);
                    
                    // Validate against current supervisors
                    if (productionData && productionData.supervisors) {
                        const validSupervisors = productionData.supervisors.map(s => s.name);
                        selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                        
                        // If none valid, select all
                        if (selectedSupervisors.length === 0) {
                            selectedSupervisors = validSupervisors;
                        }
                    }
                    
                    // Update UI
                    supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
                    const selectBtn = document.getElementById('supervisor-select-btn');
                    
                    if (supervisorFilterActive) {
                        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                        selectBtn.classList.add('filtered');
                    }
                } catch (e) {
                    console.error('Error parsing stored supervisors:', e);
                    if (productionData && productionData.supervisors) {
                        selectedSupervisors = productionData.supervisors.map(s => s.name);
                    }
                }
            }
        }

        // Function to fetch production data
        async function fetchProductionData() {
            try {
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                // Check if data has the expected structure
                if (!data) {
                    throw new Error('Empty data received from data.json');
                }
                
                // Transform data regardless of structure
                const transformedData = transformDataFormat(data);
                
                // Validate transformed data has the required structure for the dashboard
                if (!transformedData.variants || !Array.isArray(transformedData.variants) || 
                    !transformedData.supervisors || !Array.isArray(transformedData.supervisors)) {
                    throw new Error('Failed to transform data into the required format');
                }
                
                if (!lastUpdateTime || lastUpdateTime !== transformedData.timestamp) {
                    productionData = transformedData;
                    lastUpdateTime = transformedData.timestamp;
                    
                    // Store the original data for batch information
                    productionData.originalData = data;
                    
                    // Update only the footer timestamp
                    document.getElementById('last-update').textContent = 'Last updated: ' + transformedData.timestamp;
                    
                    // Process product-supervisor groups from the transformed data
                    processProductSupervisorGroups();
                    
                    // Load saved supervisor selections or initialize all selected
                    if (selectedSupervisors.length === 0) {
                        selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
                        loadSelectedSupervisors(); // Load any saved preferences
                    }
                    
                    updateFilterValueDropdown();
                    updateDashboard();
                }
                
                isLoading = false;
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
            }
        }

        // Function to transform data format
        function transformDataFormat(newData) {
            // This is the existing function, no changes needed
            const transformedData = {
                variants: [],
                supervisors: [],
                timestamp: newData.metadata.timestamp || new Date().toISOString()
            };
            
            // Check which structure we're working with and handle accordingly
            if (newData.production && Array.isArray(newData.production)) {
                // New structure with production array and summary
                
                // Transform production items to variants
                newData.production.forEach(item => {
                    const transformedVariant = {
                        variant: item.id,
                        "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                        cycleTime: item.variant.cycleTime,
                        actualCycleTime: item.variant.actualCycleTime,
                        "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                        "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                        dailyBoxTarget: item.targets.boxes,
                        currentBoxTotal: item.actual.boxes,
                        hourlyTargets: [],
                        hourlyProduction: []
                    };
                    
                    // Add hourly targets and production data
                    if (item.timeline && Array.isArray(item.timeline)) {
                        item.timeline.forEach(hour => {
                            // Add hourly target
                            transformedVariant.hourlyTargets.push({
                                hour: hour.hour,
                                target: hour.target
                            });
                            
                            // Add hourly production
                            transformedVariant.hourlyProduction.push({
                                hour: hour.hour,
                                production: hour.actual
                            });
                        });
                    }
                    
                    transformedData.variants.push(transformedVariant);
                });
                
                // Process supervisors from the summary section
                if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                    newData.summary.supervisors.forEach(supervisor => {
                        const transformedSupervisor = {
                            name: supervisor.name,
                            variants: {}
                        };
                        
                        // Find all production items assigned to this supervisor
                        if (supervisor.variants && Array.isArray(supervisor.variants)) {
                            supervisor.variants.forEach(variantId => {
                                // Find the production item for this variant
                                const prodItem = newData.production.find(p => p.id === variantId);
                                
                                if (prodItem) {
                                    // Find the supervisor assignment within the production item
                                    const assignment = prodItem.supervisors.find(s => s.id === supervisor.id);
                                    
                                    if (assignment) {
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: assignment.startTime,
                                            variantEndTime: assignment.endTime,
                                            dailyTarget: assignment.target,
                                            currentTotal: assignment.production,
                                            variance: assignment.production - assignment.target,
                                            percentage: assignment.progress
                                        };
                                    } else {
                                        // Fallback to using summary data if detailed assignment not found
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: prodItem.supervisors[0]?.startTime || "07:30",
                                            variantEndTime: prodItem.supervisors[0]?.endTime || "18:30",
                                            dailyTarget: prodItem.targets.daily,
                                            currentTotal: prodItem.actual.total,
                                            variance: prodItem.actual.total - prodItem.targets.daily,
                                            percentage: prodItem.actual.progress
                                        };
                                    }
                                }
                            });
                        }
                        
                        transformedData.supervisors.push(transformedSupervisor);
                    });
                }
            } else if (newData.variants && Array.isArray(newData.variants)) {
                // Previous structure with variants array
                transformedData.variants = newData.variants;
                transformedData.supervisors = newData.supervisors;
            }
            
            return transformedData;
        }
        
        // Function to process product-supervisor groups
        function processProductSupervisorGroups() {
            // Reset groups
            productSupervisorGroups = {};
            
            // First, create supervisor-product mapping
            productionData.supervisors.forEach(supervisor => {
                if (!supervisor.variants) return;
                
                // Create a temporary map of product -> variants
                const productVariants = {};
                
                // Process each variant
                Object.keys(supervisor.variants).forEach(variantKey => {
                    const product = extractProductFromVariant(variantKey);
                    
                    if (!productVariants[product]) {
                        productVariants[product] = [];
                    }
                    
                    // Find the variant in the variants array
                    const variantData = productionData.variants.find(v => v.variant === variantKey);
                    
                    if (variantData) {
                        productVariants[product].push({
                            variantKey,
                            variantData,
                            supervisorVariant: supervisor.variants[variantKey]
                        });
                    }
                });
                
                // Sort variants by start time and add to groups
                Object.keys(productVariants).forEach(product => {
                    const group = `${supervisor.name}:${product}`;
                    
                    // Sort variants by start time
                    const sortedVariants = productVariants[product].sort((a, b) => {
                        const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                        const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                        
                        const [hoursA, minutesA] = timeA.split(':').map(Number);
                        const [hoursB, minutesB] = timeB.split(':').map(Number);
                        
                        const totalMinutesA = hoursA * 60 + minutesA;
                        const totalMinutesB = hoursB * 60 + minutesB;
                        
                        return totalMinutesA - totalMinutesB;
                    });
                    
                    // Store in groups
                    productSupervisorGroups[group] = {
                        supervisor: supervisor.name,
                        product,
                        variants: sortedVariants.map(v => v.variantData),
                        supervisorData: supervisor
                    };
                });
            });
        }

        // Helper function to extract product from variant ID
        function extractProductFromVariant(variantId) {
            // For the new structure format with product-variant IDs like "Scalpel-Assembly-PARC11NS"
            if (variantId.includes('-')) {
                // Try splitting by dash and look for known product patterns
                const parts = variantId.split('-');
                
                // Handle case where product name contains a dash (like Scalpel-Assembly)
                if (parts.length > 2) {
                    // If we have more than one dash, the product likely contains a dash
                    // Extract everything except the last part (which is the variant)
                    return parts.slice(0, -1).join('-');
                } else if (parts.length === 2) {
                    // Simple product-variant format
                    return parts[0];
                }
            }

            // Fallback to original method for older formats
            const parts = variantId.split(' ');
            
            // Handle different formats
            if (parts.length === 1) return variantId; // No space, use as is
            if (parts.length === 2) return parts[0]; // Simple "Product Variant"
            
            // For more complex formats, try to find a pattern
            // Example: "LEVO XL1150SCi" -> "LEVO XL"
            const match = variantId.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            // Fallback: use first word
            return parts[0];
        }

        // Function to update filter value dropdown
        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear existing options (except 'all')
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.supervisors?.length > 0) {
                // Add all supervisors
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                // Add all unique products
                const uniqueProducts = new Set();
                
                // Extract products from all variants
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.product);
                });
                
                // Add options
                uniqueProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'variant' && productionData.variants?.length > 0) {
                // Add all unique variants
                const uniqueVariants = new Set(productionData.variants.map(v => v.variant));
                uniqueVariants.forEach(variantName => {
                    const option = document.createElement('option');
                    option.value = variantName;
                    option.textContent = variantName;
                    filterValueSelect.appendChild(option);
                });
            }
            
            // Restore previous selection if available, otherwise use 'all'
            filterValueSelect.value = Array.from(filterValueSelect.options).some(opt => opt.value === currentValue) 
                ? currentValue 
                : 'all';
                
            selectedFilterValue = filterValueSelect.value;
        }

        // Function to show loading or error message
function showLoadingOrError(message) {
    const supervisorName = document.getElementById('supervisor-name');
    const productName = document.getElementById('product-name');
    const variantSequence = document.getElementById('variant-sequence');
    
    if (supervisorName) supervisorName.textContent = 'SUPERVISOR: Loading...';
    if (productName) productName.textContent = 'PRODUCT: Loading...';
    if (variantSequence) variantSequence.innerHTML = '<div class="loading">Loading variants...</div>';
    
    // Clear the metrics - add null checks for all elements
    const elementIds = [
        'current-units', 'target-units', 'progress-percentage', 
        'current-boxes', 'target-boxes', 'actual-cycle-time', 'target-cycle-time'
    ];
    
    elementIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.textContent = '0';
    });
    
    // Set progress percentage specifically
    const progressElement = document.getElementById('progress-percentage');
    if (progressElement) progressElement.textContent = '0%';
    
    // Clear the charts
    const cumulativeChart = document.getElementById('cumulative-chart');
    const hourlyChart = document.getElementById('hourly-chart');
    
    if (cumulativeChart) {
        cumulativeChart.innerHTML = 
            `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
    }
    
    if (hourlyChart) {
        hourlyChart.innerHTML = 
            `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
    }
    
    // Clear batch info table
    const batchInfoTable = document.getElementById('batch-info-tbody');
    if (batchInfoTable) {
        batchInfoTable.innerHTML = `<tr><td colspan="5">${message}</td></tr>`;
    }
}

        // Function to update date and time
        function updateDateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            
            // Update current hour info in the legend
            updateCurrentHourInfo();
            
            // Check if we need to update dashboard based on time changes (variant transitions)
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                // Check if we crossed a variant boundary
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if we just crossed this boundary
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }

        // Function to update the current hour info in the legend
        function updateCurrentHourInfo() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Find next hour boundary (formatted as "HH:30")
            const nextHourMinute = 30;
            const nextHour = currentMinute < nextHourMinute ? currentHour : currentHour + 1;
            
            // Calculate minutes remaining
            let minutesRemaining;
            if (currentMinute < nextHourMinute) {
                minutesRemaining = nextHourMinute - currentMinute;
            } else {
                minutesRemaining = (60 - currentMinute) + nextHourMinute;
            }
            
            // Format the current hour string
            const hourStr = currentMinute < 30 ? 
                `${currentHour.toString().padStart(2, '0')}:30` : 
                `${(currentHour + 1).toString().padStart(2, '0')}:30`;
            
            document.getElementById('current-hour-info').textContent = 
                `CURRENT HOUR: ${hourStr} (${minutesRemaining} MIN LEFT)`;
        }

        // Updated dashboard rendering
        function updateDashboard() {
            // Filter groups based on selection and selected supervisors
            let filteredGroups = {};
            
            // Start with selected filter type/value
            if (selectedFilterValue === 'all') {
                // When "all" is selected, still respect supervisor selection
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'supervisor') {
                // When filtering by specific supervisor, also check if it's in selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].supervisor === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'product') {
                // Filter by product but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].product === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'variant') {
                // Filter by variant but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    if (group.variants.some(v => v.variant === selectedFilterValue) &&
                        selectedSupervisors.includes(group.supervisor)) {
                        filteredGroups[key] = group;
                    }
                });
            }
            
            // If no groups after filtering, show error and return
            if (Object.keys(filteredGroups).length === 0) {
                showLoadingOrError('No data available for this filter or selected supervisors.');
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
                return;
            }
            
            // Multiple groups - setup cycling between supervisors
            const groupKeys = Object.keys(filteredGroups);
            if (groupKeys.length > 1) {
                // Clear existing interval
                if (cycleInterval) clearInterval(cycleInterval);
                
                // Set cycling logic
                cycleIndex = 0;
                cycleInterval = setInterval(() => {
                    cycleIndex = (cycleIndex + 1) % groupKeys.length;
                    displayGroup(filteredGroups[groupKeys[cycleIndex]]);
                }, CYCLE_INTERVAL);
            } else {
                // Single group - clear cycling
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
            }
            
            // Display the first group initially
            displayGroup(filteredGroups[groupKeys[0]]);
            
            // Update batch information table for all selected supervisors
            updateBatchInfoTable(filteredGroups);
        }

        // FIXED FUNCTION: Update batch information table
function updateBatchInfoTable(filteredGroups) {
    const batchInfoTableBody = document.getElementById('batch-info-tbody');
    const batchInfoTableHead = document.getElementById('batch-info-thead');
    
    if (!batchInfoTableBody || !batchInfoTableHead) return;
    
    // Clear existing content
    batchInfoTableBody.innerHTML = '';
    batchInfoTableHead.innerHTML = '';
    
    // If no original data, show message
    if (!productionData.originalData || !productionData.originalData.production) {
        batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
        return;
    }
    
    // Get current time to determine current variant - MOVED TO TOP
    const now = new Date();
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    
    // Create the table header row
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `
        <th>Product</th>
        <th>Variant</th>
        <th>Batch</th>
        <th>Units</th>
        <th>Boxes</th>
    `;
    batchInfoTableHead.appendChild(headerRow);
    
    // Create a Map to store the unique batches by ID
    // This ensures we don't count the same batch multiple times
    const uniqueBatchesMap = new Map();
    
    // Create a set of supervisors that are currently being displayed
    const displayedSupervisors = new Set();
    Object.values(filteredGroups).forEach(group => {
        displayedSupervisors.add(group.supervisor);
    });
    
    // Process each group's variants
    Object.values(filteredGroups).forEach(group => {
        // Get the supervisor's variants
        const supervisorName = group.supervisor;
        const supervisor = productionData.supervisors.find(s => s.name === supervisorName);
        
        if (!supervisor || !supervisor.variants) return;
        
        // ONLY process variants that are actually in this filtered group
        group.variants.forEach(variantInGroup => {
            const variantKey = variantInGroup.variant;
            
            // Find the original production data
            const productionItem = productionData.originalData.production.find(p => p.id === variantKey);
            
            if (!productionItem || !productionItem.batches) return;
            
            // Get variant details
            const productName = productionItem.product?.name || extractProductFromVariant(variantKey);
            const variantName = productionItem.variant?.name || variantKey.split('-').pop();
            
            // Check if this variant is currently active
            const supervisorVariant = supervisor.variants[variantKey];
            let isCurrentVariant = false;
            
            if (supervisorVariant) {
                const startTimeStr = supervisorVariant.variantStartTime || productionItem.supervisors[0]?.startTime;
                const endTimeStr = supervisorVariant.variantEndTime || productionItem.supervisors[0]?.endTime;
                
                if (startTimeStr && endTimeStr) {
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if current time is within this variant's window
                    isCurrentVariant = (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
                }
            }
            
            // Process each batch - but only show batches for the filtered supervisors
            productionItem.batches.forEach((batch, batchIndex) => {
                // Find which supervisor this batch belongs to by matching production quantities
                const matchingSupervisor = productionItem.supervisors.find(sup => {
                    // If there's only one supervisor, it gets all batches
                    if (productionItem.supervisors.length === 1) {
                        return sup.name === supervisorName;
                    }
                    
                    // For multiple supervisors, try to match based on production quantities
                    // This is a simplified approach - in a real system you'd have explicit batch-supervisor mapping
                    if (batchIndex === 0 && productionItem.supervisors[0].name === supervisorName) {
                        return true;
                    }
                    if (batchIndex === 1 && productionItem.supervisors[1] && productionItem.supervisors[1].name === supervisorName) {
                        return true;
                    }
                    
                    return false;
                });
                
                // Only include this batch if it belongs to the current supervisor
                if (!matchingSupervisor) return;
                
                const batchKey = `${productName}-${variantName}-${batch.id}`;
                
                // Only add the batch if we haven't seen it before
                if (!uniqueBatchesMap.has(batchKey)) {
                    uniqueBatchesMap.set(batchKey, {
                        product: productName,
                        variant: variantName,
                        batchId: batch.id,
                        units: batch.quantity,  // Use original quantity
                        boxes: batch.boxes,     // Use original boxes count
                        supervisor: supervisorName,
                        isCurrent: isCurrentVariant,
                        isAssembly: productName.toLowerCase().includes('assembly')
                    });
                } else {
                    // If we do have the batch, just update the isCurrent flag if needed
                    if (isCurrentVariant) {
                        uniqueBatchesMap.get(batchKey).isCurrent = true;
                    }
                }
            });
        });
    });
    
    // Convert map to array for display
    const batchData = Array.from(uniqueBatchesMap.values());
    
    // Sort batches by product, then by variant
    batchData.sort((a, b) => {
        // First by product
        if (a.product !== b.product) {
            return a.product.localeCompare(b.product);
        }
        
        // Then by variant
        if (a.variant !== b.variant) {
            return a.variant.localeCompare(b.variant);
        }
        
        // Then by batch ID
        return a.batchId - b.batchId;
    });
    
    // Create table rows for each batch
    if (batchData.length === 0) {
        batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
        return;
    }
    
    let currentProduct = null;
    
    batchData.forEach(batch => {
        // Add product header if changed
        if (batch.product !== currentProduct) {
            currentProduct = batch.product;
            
            const productRow = document.createElement('tr');
            productRow.style.backgroundColor = '#f0f9ff'; // Light blue background
            
            const productCell = document.createElement('td');
            productCell.colSpan = 5;
            productCell.style.fontWeight = 'bold';
            productCell.style.fontSize = 'larger';
            productCell.textContent = batch.product;
            
            productRow.appendChild(productCell);
            batchInfoTableBody.appendChild(productRow);
        }
        
        // Create batch row
        const row = document.createElement('tr');
        if (batch.isCurrent) {
            row.className = 'current';
        }
        
        // Product cell - Now less prominent since we have product headers
        const productCell = document.createElement('td');
        productCell.style.opacity = '0.5'; // Make less prominent
        productCell.textContent = batch.product;
        row.appendChild(productCell);
        
        // Variant cell
        const variantCell = document.createElement('td');
        variantCell.textContent = batch.variant;
        row.appendChild(variantCell);
        
        // Batch ID cell
        const batchCell = document.createElement('td');
        batchCell.className = 'batch-number';
        batchCell.textContent = batch.batchId;
        row.appendChild(batchCell);
        
        // Units cell
        const unitsCell = document.createElement('td');
        unitsCell.textContent = batch.units;
        row.appendChild(unitsCell);
        
        // Boxes/Bags cell - Display appropriate container type
        const containerCell = document.createElement('td');
        if (batch.isAssembly) {
            containerCell.textContent = `${batch.boxes} Bags`;
        } else {
            containerCell.textContent = batch.boxes;
        }
        row.appendChild(containerCell);
        
        batchInfoTableBody.appendChild(row);
    });
}


        function renderCumulativeChart(group) {
    const chartContainer = document.getElementById('cumulative-chart');
    chartContainer.innerHTML = '';
    
    // Collect all hours across all variants
    const allHoursSet = new Set();
    const hourlyProductionMap = new Map(); // Map to store production by hour
    const hourlyTargetMap = new Map();     // Map to store targets by hour
    const hourlyStatusMap = new Map();     // Map to store hour status (met/missed)
    
    // CRITICAL FIX: Calculate the correct total production for this supervisor only
    let supervisorTotalProduction = 0;
    let supervisorTotalTarget = 0;
    
    // Calculate totals from supervisor data
    group.variants.forEach(variant => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (supervisorVariant) {
            supervisorTotalProduction += (supervisorVariant.currentTotal || 0);
            supervisorTotalTarget += (supervisorVariant.dailyTarget || 0);
        }
    });
    
    // Process each variant and collect unique hours
    group.variants.forEach(variant => {
        // Get variant time window
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Get the supervisor's proportion of production for this variant
        // This is needed because timeline data is at variant level, not supervisor level
        let supervisorProportion = 1.0;
        
        // Find the original production data to check if multiple supervisors work on this variant
        if (productionData.originalData && productionData.originalData.production) {
            const prodItem = productionData.originalData.production.find(p => p.id === variant.variant);
            if (prodItem && prodItem.supervisors && prodItem.supervisors.length > 1) {
                // Multiple supervisors - calculate this supervisor's proportion
                const totalVariantProduction = prodItem.actual.total;
                const thisSupervisorProduction = supervisorVariant.currentTotal || 0;
                supervisorProportion = totalVariantProduction > 0 ? thisSupervisorProduction / totalVariantProduction : 0;
            }
        }
        
        // Collect hourly production data with supervisor proportion applied
        if (variant.hourlyProduction) {
            variant.hourlyProduction.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Apply supervisor proportion to the production
                    const adjustedProduction = Math.round((item.production || 0) * supervisorProportion);
                    
                    // Add to hourly production map
                    if (!hourlyProductionMap.has(item.hour)) {
                        hourlyProductionMap.set(item.hour, 0);
                    }
                    hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + adjustedProduction);
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
        
        // Collect hourly target data (targets don't need proportion adjustment)
        if (variant.hourlyTargets) {
            variant.hourlyTargets.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // For targets, we need to use the supervisor-specific targets
                    // Calculate hourly target based on supervisor's daily target and time window
                    const supervisorHourlyTarget = Math.round((supervisorVariant.dailyTarget || 0) * (item.target || 0) / (variant.dailyTarget || 1));
                    
                    // Add to hourly target map
                    if (!hourlyTargetMap.has(item.hour)) {
                        hourlyTargetMap.set(item.hour, 0);
                    }
                    hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + supervisorHourlyTarget);
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
    });
    
    // Convert to sorted array of hours
    const sortedHours = Array.from(allHoursSet).sort((a, b) => {
        const [hourA, minuteA] = a.split(':').map(Number);
        const [hourB, minuteB] = b.split(':').map(Number);
        return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
    });
    
    if (sortedHours.length === 0) {
        chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available</div>';
        return;
    }
    
    // Build cumulative data arrays
    const cumulativeData = [];
    let runningProductionTotal = 0;
    let runningTargetTotal = 0;
    
    // Generate time-based data points
    sortedHours.forEach(hour => {
        const hourProduction = hourlyProductionMap.get(hour) || 0;
        const hourTarget = hourlyTargetMap.get(hour) || 0;
        
        // Add to running totals
        runningProductionTotal += hourProduction;
        runningTargetTotal += hourTarget;
        
        const [hourVal, minuteVal] = hour.split(':').map(Number);
        const timeMinutes = hourVal * 60 + minuteVal;
        
        // Ensure cumulative totals don't exceed supervisor totals
        if (runningProductionTotal > supervisorTotalProduction) {
            runningProductionTotal = supervisorTotalProduction;
        }
        
        cumulativeData.push({
            hour: hour,
            production: runningProductionTotal,
            target: runningTargetTotal,
            timeMinutes: timeMinutes
        });
        
        // Determine status for each hour
        const now = new Date();
        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
        
        // Only evaluate completed hours
        if (currentTimeMinutes >= timeMinutes + 30) {
            hourlyStatusMap.set(hour, hourProduction >= hourTarget ? 'met' : 'missed');
        } else if (currentTimeMinutes >= timeMinutes - 30 && currentTimeMinutes < timeMinutes + 30) {
            hourlyStatusMap.set(hour, 'current');
        } else {
            hourlyStatusMap.set(hour, 'upcoming');
        }
    });
    
    // Do not filter data - we want to show all available data points
    let filteredData = cumulativeData;
    
    // CRITICAL FIX: Ensure the last data point matches the supervisor's actual total
    if (filteredData.length > 0) {
        const lastPoint = filteredData[filteredData.length - 1];
        
        // If the last production value doesn't match the supervisor's total, add or update a point
        if (lastPoint.production !== supervisorTotalProduction) {
            // Get current time to use as the data point hour
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentHourStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
            const currentTimeMinutes = currentHour * 60 + currentMinute;
            
            // Add a new data point with the correct values from the supervisor's data
            filteredData.push({
                hour: currentHourStr,
                production: supervisorTotalProduction,
                target: supervisorTotalTarget, 
                timeMinutes: currentTimeMinutes
            });
        }
    }
    
    if (filteredData.length === 0) {
        chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current time period</div>';
        return;
    }
    
    // Get chart dimensions based on container
    const chartArea = chartContainer.closest('.chart-area');
    const svgWidth = chartArea.clientWidth;
    const svgHeight = chartArea.clientHeight;
    
    // Check if dimensions are valid
    if (svgWidth <= 0 || svgHeight <= 0) {
        // Try again later if dimensions are not ready
        setTimeout(() => renderCumulativeChart(group), 100);
        return;
    }
    
    // Calculate padding based on container size for responsive design
    const padding = {
        top: Math.max(10, Math.floor(svgHeight * 0.05)),
        right: Math.max(10, Math.floor(svgWidth * 0.05)),
        bottom: Math.max(50, Math.floor(svgHeight * 0.18)), // Increased bottom padding for status indicators
        left: Math.max(40, Math.floor(svgWidth * 0.12))
    };
    
    // Calculate chart dimensions
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    // Find max value for chart scaling (with 10% buffer)
    const maxValue = Math.max(
        ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
    ) * 1.1;
    
    // Create SVG element
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    chartContainer.appendChild(svg);
    
    // Add grid lines
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 10);
        text.setAttribute('y', y + 5);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 35);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add axes
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', padding.left);
    yAxis.setAttribute('y1', padding.top);
    yAxis.setAttribute('x2', padding.left);
    yAxis.setAttribute('y2', svgHeight - padding.bottom);
    yAxis.setAttribute('stroke', '#666');
    yAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(yAxis);
    
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', padding.left);
    xAxis.setAttribute('y1', svgHeight - padding.bottom);
    xAxis.setAttribute('x2', svgWidth - padding.right);
    xAxis.setAttribute('y2', svgHeight - padding.bottom);
    xAxis.setAttribute('stroke', '#666');
    xAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxis);
    
    svg.appendChild(gridGroup);
    
    // Find earliest start time and latest end time across all variants
    let earliestStartMinutes = 24 * 60; // Initialize to end of day
    let latestEndMinutes = 0;

    group.variants.forEach(variant => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (supervisorVariant) {
            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
            const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
            
            if (startTimeStr && endTimeStr) {
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const startTimeMinutes = startHour * 60 + startMinute;
                
                if (startTimeMinutes < earliestStartMinutes) {
                    earliestStartMinutes = startTimeMinutes;
                }
                
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (endTimeMinutes > latestEndMinutes) {
                    latestEndMinutes = endTimeMinutes;
                }
            }
        }
    });

    // Format the start time for display (first tick)
    const startTimeHour = Math.floor(earliestStartMinutes / 60);
    const startTimeMinute = earliestStartMinutes % 60;
    const startTimeFormatted = `${startTimeHour.toString().padStart(2, '0')}:${startTimeMinute.toString().padStart(2, '0')}`;

    // Generate hourly intervals from start time to current time
    const now = new Date();
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    // Extend end time to ensure we see the final data point
    const endTimeMinutes = Math.max(latestEndMinutes, currentTimeMinutes + 60); 

    // Create time ticks
    const allHours = [];
    
    // Add the start time as the first tick
    allHours.push(startTimeFormatted);
    
    // Calculate the first full hour after start time
    const firstFullHourMinutes = Math.ceil(earliestStartMinutes / 60) * 60 + 30;
    
    // Then add standard hour markers (8:30, 9:30, etc.)
    for (let minutes = firstFullHourMinutes; minutes <= endTimeMinutes; minutes += 60) {
        const hour = Math.floor(minutes / 60);
        const formattedHour = `${hour.toString().padStart(2, '0')}:30`;
        allHours.push(formattedHour);
    }

    // Add X-axis ticks, labels and status indicators
    const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    allHours.forEach((hour, index) => {
        const x = padding.left + (chartWidth * index / (allHours.length - 1 || 1));
        const y = svgHeight - padding.bottom + 20;
        
        // Add tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', x);
        tick.setAttribute('y1', svgHeight - padding.bottom);
        tick.setAttribute('x2', x);
        tick.setAttribute('y2', svgHeight - padding.bottom + 5);
        tick.setAttribute('stroke', '#666');
        tick.setAttribute('stroke-width', '1.5');
        xLabelsGroup.appendChild(tick);
        
        // Add hour label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('fill', '#666');
        text.textContent = hour;
        xLabelsGroup.appendChild(text);
        
        // Add status indicator below the hour label
        const status = hourlyStatusMap.get(hour);
        if (status) {
            let statusSymbol = '';
            let fillColor = '#94a3b8'; // Default gray
            
            if (status === 'met') {
                statusSymbol = '';
                fillColor = '#0d9488'; // Green for met
            } else if (status === 'missed') {
                statusSymbol = '';
                fillColor = '#e11d48'; // Red for missed
            } else if (status === 'current') {
                statusSymbol = '';
                fillColor = '#ca8a04'; // Yellow for current
            }
            
            if (statusSymbol) {
                const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statusText.setAttribute('x', x);
                statusText.setAttribute('y', y + 20);
                statusText.setAttribute('text-anchor', 'middle');
                statusText.setAttribute('font-size', isFullscreen ? '18' : '16');
                statusText.setAttribute('font-weight', 'bold');
                statusText.setAttribute('fill', fillColor);
                statusText.textContent = statusSymbol;
                xLabelsGroup.appendChild(statusText);
            }
        }
    });
    svg.appendChild(xLabelsGroup);
    
    // Draw production line - starting from the first tick (start time) with zero production
    const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let productionPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const productionPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        production: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for production line with proper cumulative totals
    filteredData.forEach((dataPoint) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
        
        productionPoints.push({ 
            x, 
            y, 
            production: dataPoint.production, 
            hour: dataPoint.hour 
        });
        productionPathD += ` L ${x} ${y}`;
    });
    
    // Add production line
    const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    productionPath.setAttribute('d', productionPathD);
    productionPath.setAttribute('stroke', 'var(--production-color)');
    productionPath.setAttribute('stroke-width', '3');
    productionPath.setAttribute('fill', 'none');
    productionLineGroup.appendChild(productionPath);
    
    // Add production points and labels
    productionPoints.forEach((point, index) => {
        // Skip emphasizing intermediate points if we have many points
        if (productionPoints.length > 7 && index > 0 && index < productionPoints.length - 1 && index % 2 === 0) {
            return;
        }
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', isFullscreen ? '5' : '4');
        circle.setAttribute('fill', 'var(--production-color)');
        productionLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 8);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('fill', 'var(--production-color)');
        text.textContent = point.production;
        productionLineGroup.appendChild(text);
    });
    
    // CRITICAL FIX: Always emphasize the last production point (current total)
    if (productionPoints.length > 0) {
        const lastPoint = productionPoints[productionPoints.length - 1];
        
        // Ensure this point shows the correct value from supervisor data
        lastPoint.production = supervisorTotalProduction;
        
        // Create emphasized circle and label
        const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        emphasizedCircle.setAttribute('cx', lastPoint.x);
        emphasizedCircle.setAttribute('cy', lastPoint.y);
        emphasizedCircle.setAttribute('r', isFullscreen ? '8' : '7');
        emphasizedCircle.setAttribute('fill', 'var(--production-color)');
        emphasizedCircle.setAttribute('stroke', '#ffffff');
        emphasizedCircle.setAttribute('stroke-width', '2');
        productionLineGroup.appendChild(emphasizedCircle);
        
        const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        emphasizedText.setAttribute('x', lastPoint.x);
        emphasizedText.setAttribute('y', lastPoint.y - 12);
        emphasizedText.setAttribute('text-anchor', 'middle');
        emphasizedText.setAttribute('font-size', isFullscreen ? '18' : '16');
        emphasizedText.setAttribute('font-weight', 'bold');
        emphasizedText.setAttribute('fill', 'var(--production-color)');
        // Ensure the text shows the current total from supervisor data
        emphasizedText.textContent = supervisorTotalProduction;
        productionLineGroup.appendChild(emphasizedText);
    }
    
    svg.appendChild(productionLineGroup);
    
    // Draw target line - starting from the first tick (start time) with zero target
    const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let targetPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const targetPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        target: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for target line with proper cumulative totals
    filteredData.forEach((dataPoint) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
        
        targetPoints.push({ 
            x, 
            y, 
            target: dataPoint.target, 
            hour: dataPoint.hour 
        });
        targetPathD += ` L ${x} ${y}`;
    });
    
    // Add target line
    const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    targetPath.setAttribute('d', targetPathD);
    targetPath.setAttribute('stroke', 'var(--target-color)');
    targetPath.setAttribute('stroke-width', '3');
    targetPath.setAttribute('fill', 'none');
    targetLineGroup.appendChild(targetPath);
    
    // Add target points and labels
    targetPoints.forEach((point, index) => {
        // Skip emphasizing intermediate points if we have many points
        if (targetPoints.length > 7 && index > 0 && index < targetPoints.length - 1 && index % 2 === 0) {
            return;
        }
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', isFullscreen ? '5' : '4');
        circle.setAttribute('fill', 'var(--target-color)');
        targetLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 8);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('fill', 'var(--target-color)');
        text.textContent = point.target;
        targetLineGroup.appendChild(text);
    });
    
    // Emphasize the last target point
    if (targetPoints.length > 0) {
        const lastPoint = targetPoints[targetPoints.length - 1];
        
        // Ensure this point shows the correct target value from supervisor data
        lastPoint.target = supervisorTotalTarget;
        
        const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        emphasizedCircle.setAttribute('cx', lastPoint.x);
        emphasizedCircle.setAttribute('cy', lastPoint.y);
        emphasizedCircle.setAttribute('r', isFullscreen ? '7' : '6');
        emphasizedCircle.setAttribute('fill', 'var(--target-color)');
        emphasizedCircle.setAttribute('stroke', '#ffffff');
        emphasizedCircle.setAttribute('stroke-width', '2');
        targetLineGroup.appendChild(emphasizedCircle);
        
        const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        emphasizedText.setAttribute('x', lastPoint.x);
        emphasizedText.setAttribute('y', lastPoint.y - 10);
        emphasizedText.setAttribute('text-anchor', 'middle');
        emphasizedText.setAttribute('font-size', isFullscreen ? '16' : '14');
        emphasizedText.setAttribute('font-weight', 'bold');
        emphasizedText.setAttribute('fill', 'var(--target-color)');
        // Ensure the text shows the current target from supervisor data
        emphasizedText.textContent = supervisorTotalTarget;
        targetLineGroup.appendChild(emphasizedText);
    }
    
    svg.appendChild(targetLineGroup);
}

function renderHourlyChart(group) {
    const chartContainer = document.getElementById('hourly-chart');
    chartContainer.innerHTML = '';
    
    // Get current time to determine current hour period
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    
    // Determine the current hour period (e.g. if it's 15:15, use the 14:30-15:30 period)
    const currentPeriodHour = currentMinute < 30 ? currentHour : currentHour + 1;
    const currentPeriodMinute = 30;
    const currentPeriodStr = `${currentPeriodHour.toString().padStart(2, '0')}:${currentPeriodMinute.toString().padStart(2, '0')}`;
    
    // Initialize maps for the current hour period only
    const hourlyProductionMap = new Map();
    const hourlyTargetMap = new Map();
    
    // Process each variant and collect data only for current hour period
    group.variants.forEach(variant => {
        // Get variant time window
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Collect hourly production data only for current period
        if (variant.hourlyProduction) {
            variant.hourlyProduction.forEach(item => {
                if (!item.hour || item.hour !== currentPeriodStr) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly production map
                    if (!hourlyProductionMap.has(item.hour)) {
                        hourlyProductionMap.set(item.hour, 0);
                    }
                    hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                }
            });
        }
        
        // Collect hourly target data only for current period
        if (variant.hourlyTargets) {
            variant.hourlyTargets.forEach(item => {
                if (!item.hour || item.hour !== currentPeriodStr) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly target map
                    if (!hourlyTargetMap.has(item.hour)) {
                        hourlyTargetMap.set(item.hour, 0);
                    }
                    hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                }
            });
        }
    });
    
    // We only show the current hour period
    const sortedHours = [currentPeriodStr];
    
    if (hourlyProductionMap.size === 0 && hourlyTargetMap.size === 0) {
        chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current hour period</div>';
        return;
    }
    
    // Get chart dimensions based on container
    const chartArea = chartContainer.closest('.chart-area');
    const svgWidth = chartArea.clientWidth;
    const svgHeight = chartArea.clientHeight;
    
    // Check if dimensions are valid
    if (svgWidth <= 0 || svgHeight <= 0) {
        // Try again later if dimensions are not ready
        setTimeout(() => renderHourlyChart(group), 100);
        return;
    }
    
    // Calculate padding based on container size for responsive design
    const padding = {
        top: Math.max(10, Math.floor(svgHeight * 0.05)),
        right: Math.max(10, Math.floor(svgWidth * 0.05)),
        bottom: Math.max(50, Math.floor(svgHeight * 0.1)), // Reduced bottom padding as we don't have status indicators
        left: Math.max(40, Math.floor(svgWidth * 0.12))
    };
    
    // Calculate chart dimensions
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    // Find max value for chart scaling (with 10% buffer)
    const maxValue = Math.max(
        hourlyProductionMap.get(currentPeriodStr) || 0,
        hourlyTargetMap.get(currentPeriodStr) || 0
    ) * 1.1 || 100; // Default to 100 if no values
    
    // Create SVG element
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    chartContainer.appendChild(svg);
    
    // Add grid lines
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 10);
        text.setAttribute('y', y + 5);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 35);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units per Hour';
    gridGroup.appendChild(yAxisTitle);
    
    // Add axes
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', padding.left);
    yAxis.setAttribute('y1', padding.top);
    yAxis.setAttribute('x2', padding.left);
    yAxis.setAttribute('y2', svgHeight - padding.bottom);
    yAxis.setAttribute('stroke', '#666');
    yAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(yAxis);
    
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', padding.left);
    xAxis.setAttribute('y1', svgHeight - padding.bottom);
    xAxis.setAttribute('x2', svgWidth - padding.right);
    xAxis.setAttribute('y2', svgHeight - padding.bottom);
    xAxis.setAttribute('stroke', '#666');
    xAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxis);
    
    svg.appendChild(gridGroup);
    
    // Calculate bar width for single hour period (centered in chart)
    const barGroupWidth = chartWidth * 0.3; // Use 30% of chart width
    const barWidth = barGroupWidth * 0.42; // Each bar takes 42% of group width
    
    // Add X-axis label for current hour period
    const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const x = padding.left + chartWidth / 2; // Center of chart
    const y = svgHeight - padding.bottom + 20;
    
    // Add tick mark
    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    tick.setAttribute('x1', x);
    tick.setAttribute('y1', svgHeight - padding.bottom);
    tick.setAttribute('x2', x);
    tick.setAttribute('y2', svgHeight - padding.bottom + 5);
    tick.setAttribute('stroke', '#666');
    tick.setAttribute('stroke-width', '1.5');
    xLabelsGroup.appendChild(tick);
    
    // Add hour label
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', isFullscreen ? '16' : '14');
    text.setAttribute('font-weight', 'bold');
    text.setAttribute('fill', '#666');
    text.textContent = currentPeriodStr;
    xLabelsGroup.appendChild(text);
    
    svg.appendChild(xLabelsGroup);
    
    // Create bar charts for current hour period only
    const barsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Calculate center position for the bar group
    const barGroupX = padding.left + (chartWidth - barGroupWidth) / 2;
    
    // Production bar (left bar in the group)
    const productionValue = hourlyProductionMap.get(currentPeriodStr) || 0;
    const productionHeight = (productionValue / maxValue) * chartHeight;
    const productionY = svgHeight - padding.bottom - productionHeight;
    
    const productionBarX = barGroupX + (barGroupWidth * 0.08); // 8% offset from left
    
    const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    productionBar.setAttribute('x', productionBarX);
    productionBar.setAttribute('y', productionY);
    productionBar.setAttribute('width', barWidth);
    productionBar.setAttribute('height', productionHeight);
    productionBar.setAttribute('rx', '2'); // Rounded corners
    productionBar.setAttribute('ry', '2');
    productionBar.setAttribute('fill', 'var(--production-color)');
    barsGroup.appendChild(productionBar);
    
    // Production value label
    const productionLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    productionLabel.setAttribute('x', productionBarX + (barWidth / 2));
    productionLabel.setAttribute('y', productionY - 5);
    productionLabel.setAttribute('text-anchor', 'middle');
    productionLabel.setAttribute('font-size', isFullscreen ? '14' : '12');
    productionLabel.setAttribute('font-weight', 'bold');
    productionLabel.setAttribute('fill', 'var(--production-color)');
    productionLabel.textContent = productionValue;
    barsGroup.appendChild(productionLabel);
    
    // Target bar (right bar in the group)
    const targetValue = hourlyTargetMap.get(currentPeriodStr) || 0;
    const targetHeight = (targetValue / maxValue) * chartHeight;
    const targetY = svgHeight - padding.bottom - targetHeight;
    
    const targetBarX = barGroupX + (barGroupWidth * 0.5); // 50% offset from left
    
    const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    targetBar.setAttribute('x', targetBarX);
    targetBar.setAttribute('y', targetY);
    targetBar.setAttribute('width', barWidth);
    targetBar.setAttribute('height', targetHeight);
    targetBar.setAttribute('rx', '2'); // Rounded corners
    targetBar.setAttribute('ry', '2');
    targetBar.setAttribute('fill', 'var(--target-color)');
    barsGroup.appendChild(targetBar);
    
    // Target value label
    const targetLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetLabel.setAttribute('x', targetBarX + (barWidth / 2));
    targetLabel.setAttribute('y', targetY - 5);
    targetLabel.setAttribute('text-anchor', 'middle');
    targetLabel.setAttribute('font-size', isFullscreen ? '14' : '12');
    targetLabel.setAttribute('font-weight', 'bold');
    targetLabel.setAttribute('fill', 'var(--target-color)');
    targetLabel.textContent = targetValue;
    barsGroup.appendChild(targetLabel);
    
    svg.appendChild(barsGroup);
    
    // Add legend
    const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Production legend
    const prodLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    prodLegendRect.setAttribute('x', padding.left);
    prodLegendRect.setAttribute('y', padding.top - 25);
    prodLegendRect.setAttribute('width', 12);
    prodLegendRect.setAttribute('height', 12);
    prodLegendRect.setAttribute('fill', 'var(--production-color)');
    legendGroup.appendChild(prodLegendRect);
    
    const prodLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    prodLegendText.setAttribute('x', padding.left + 18);
    prodLegendText.setAttribute('y', padding.top - 15);
    prodLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
    prodLegendText.setAttribute('fill', '#666');
    prodLegendText.textContent = 'Production';
    legendGroup.appendChild(prodLegendText);
    
    // Target legend
    const targetLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    targetLegendRect.setAttribute('x', padding.left + 100);
    targetLegendRect.setAttribute('y', padding.top - 25);
    targetLegendRect.setAttribute('width', 12);
    targetLegendRect.setAttribute('height', 12);
    targetLegendRect.setAttribute('fill', 'var(--target-color)');
    legendGroup.appendChild(targetLegendRect);
    
    const targetLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetLegendText.setAttribute('x', padding.left + 118);
    targetLegendText.setAttribute('y', padding.top - 15);
    targetLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
    targetLegendText.setAttribute('fill', '#666');
    targetLegendText.textContent = 'Target';
    legendGroup.appendChild(targetLegendText);
    
    svg.appendChild(legendGroup);
}

         // Completely redesigned chart rendering for better cross-device compatibility
function renderCumulativeChart(group) {
    const chartContainer = document.getElementById('cumulative-chart');
    chartContainer.innerHTML = '';
    
    // Collect all hours across all variants
    const allHoursSet = new Set();
    const hourlyProductionMap = new Map(); // Map to store production by hour
    const hourlyTargetMap = new Map();     // Map to store targets by hour
    const hourlyStatusMap = new Map();     // Map to store hour status (met/missed)
    
    // Process each variant and collect unique hours
    group.variants.forEach(variant => {
        // Get variant time window
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Collect hourly production data
        if (variant.hourlyProduction) {
            variant.hourlyProduction.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly production map
                    if (!hourlyProductionMap.has(item.hour)) {
                        hourlyProductionMap.set(item.hour, 0);
                    }
                    hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
        
        // Collect hourly target data
        if (variant.hourlyTargets) {
            variant.hourlyTargets.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly target map
                    if (!hourlyTargetMap.has(item.hour)) {
                        hourlyTargetMap.set(item.hour, 0);
                    }
                    hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
    });
    
    // Convert to sorted array of hours
    const sortedHours = Array.from(allHoursSet).sort((a, b) => {
        const [hourA, minuteA] = a.split(':').map(Number);
        const [hourB, minuteB] = b.split(':').map(Number);
        return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
    });
    
    if (sortedHours.length === 0) {
        chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available</div>';
        return;
    }
    
    // Build cumulative data arrays
    const cumulativeData = [];
    let runningProductionTotal = 0;
    let runningTargetTotal = 0;
    
    // Generate time-based data points
    sortedHours.forEach(hour => {
        const hourProduction = hourlyProductionMap.get(hour) || 0;
        const hourTarget = hourlyTargetMap.get(hour) || 0;
        
        // Add to running totals
        runningProductionTotal += hourProduction;
        runningTargetTotal += hourTarget;
        
        const [hourVal, minuteVal] = hour.split(':').map(Number);
        const timeMinutes = hourVal * 60 + minuteVal;
        
        cumulativeData.push({
            hour: hour,
            production: runningProductionTotal,
            target: runningTargetTotal,
            timeMinutes: timeMinutes
        });
        
        // Determine status for each hour
        const now = new Date();
        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
        
        // Only evaluate completed hours
        if (currentTimeMinutes >= timeMinutes + 30) {
            hourlyStatusMap.set(hour, hourProduction >= hourTarget ? 'met' : 'missed');
        } else if (currentTimeMinutes >= timeMinutes - 30 && currentTimeMinutes < timeMinutes + 30) {
            hourlyStatusMap.set(hour, 'current');
        } else {
            hourlyStatusMap.set(hour, 'upcoming');
        }
    });
    
    // Filter data to only show up to current time plus buffer
    const now = new Date();
    const currentMinuteOfDay = now.getHours() * 60 + now.getMinutes();
    const currentTimePlusBuffer = currentMinuteOfDay + 30;
    
    const filteredData = cumulativeData.filter(item => item.timeMinutes <= currentTimePlusBuffer);
    
    if (filteredData.length === 0) {
        chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current time period</div>';
        return;
    }
    
    // Get chart dimensions based on container
    const chartArea = chartContainer.closest('.chart-area');
    const svgWidth = chartArea.clientWidth;
    const svgHeight = chartArea.clientHeight;
    
    // Check if dimensions are valid
    if (svgWidth <= 0 || svgHeight <= 0) {
        // Try again later if dimensions are not ready
        setTimeout(() => renderCumulativeChart(group), 100);
        return;
    }
    
    // Calculate padding based on container size for responsive design
    const padding = {
        top: Math.max(10, Math.floor(svgHeight * 0.05)),
        right: Math.max(10, Math.floor(svgWidth * 0.05)),
        bottom: Math.max(50, Math.floor(svgHeight * 0.18)), // Increased bottom padding for status indicators
        left: Math.max(40, Math.floor(svgWidth * 0.12))
    };
    
    // Calculate chart dimensions
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    // Find max value for chart scaling (with 10% buffer)
    const maxValue = Math.max(
        ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
    ) * 1.1;
    
    // Create SVG element
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    chartContainer.appendChild(svg);
    
    // Add grid lines
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 10);
        text.setAttribute('y', y + 5);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 35);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add axes
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', padding.left);
    yAxis.setAttribute('y1', padding.top);
    yAxis.setAttribute('x2', padding.left);
    yAxis.setAttribute('y2', svgHeight - padding.bottom);
    yAxis.setAttribute('stroke', '#666');
    yAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(yAxis);
    
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', padding.left);
    xAxis.setAttribute('y1', svgHeight - padding.bottom);
    xAxis.setAttribute('x2', svgWidth - padding.right);
    xAxis.setAttribute('y2', svgHeight - padding.bottom);
    xAxis.setAttribute('stroke', '#666');
    xAxis.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxis);
    
    svg.appendChild(gridGroup);
    
    // Find earliest start time and latest end time across all variants
    let earliestStartMinutes = 24 * 60; // Initialize to end of day
    let latestEndMinutes = 0;

    group.variants.forEach(variant => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (supervisorVariant) {
            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
            const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
            
            if (startTimeStr && endTimeStr) {
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const startTimeMinutes = startHour * 60 + startMinute;
                
                if (startTimeMinutes < earliestStartMinutes) {
                    earliestStartMinutes = startTimeMinutes;
                }
                
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (endTimeMinutes > latestEndMinutes) {
                    latestEndMinutes = endTimeMinutes;
                }
            }
        }
    });

    // Format the start time for display (first tick)
    const startTimeHour = Math.floor(earliestStartMinutes / 60);
    const startTimeMinute = earliestStartMinutes % 60;
    const startTimeFormatted = `${startTimeHour.toString().padStart(2, '0')}:${startTimeMinute.toString().padStart(2, '0')}`;

    // Generate hourly intervals from start time to current time
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    const endTimeMinutes = Math.min(latestEndMinutes, currentTimeMinutes + 60); // Show up to 1 hour ahead

    // Create time ticks
    const allHours = [];
    
    // Add the start time as the first tick
    allHours.push(startTimeFormatted);
    
    // Calculate the first full hour after start time
    const firstFullHourMinutes = Math.ceil(earliestStartMinutes / 60) * 60 + 30;
    
    // Then add standard hour markers (8:30, 9:30, etc.)
    for (let minutes = firstFullHourMinutes; minutes <= endTimeMinutes; minutes += 60) {
        const hour = Math.floor(minutes / 60);
        const formattedHour = `${hour.toString().padStart(2, '0')}:30`;
        allHours.push(formattedHour);
    }

    // Add X-axis ticks, labels and status indicators
    const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    allHours.forEach((hour, index) => {
        const x = padding.left + (chartWidth * index / (allHours.length - 1 || 1));
        const y = svgHeight - padding.bottom + 20;
        
        // Add tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', x);
        tick.setAttribute('y1', svgHeight - padding.bottom);
        tick.setAttribute('x2', x);
        tick.setAttribute('y2', svgHeight - padding.bottom + 5);
        tick.setAttribute('stroke', '#666');
        tick.setAttribute('stroke-width', '1.5');
        xLabelsGroup.appendChild(tick);
        
        // Add hour label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('fill', '#666');
        text.textContent = hour;
        xLabelsGroup.appendChild(text);
        
        // Add status indicator below the hour label
        const status = hourlyStatusMap.get(hour);
        if (status) {
            let statusSymbol = '';
            let fillColor = '#94a3b8'; // Default gray
            
            if (status === 'met') {
                statusSymbol = '';
                fillColor = '#0d9488'; // Green for met
            } else if (status === 'missed') {
                statusSymbol = '';
                fillColor = '#e11d48'; // Red for missed
            } else if (status === 'current') {
                statusSymbol = '';
                fillColor = '#ca8a04'; // Yellow for current
            }
            
            if (statusSymbol) {
                const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statusText.setAttribute('x', x);
                statusText.setAttribute('y', y + 20);
                statusText.setAttribute('text-anchor', 'middle');
                statusText.setAttribute('font-size', isFullscreen ? '18' : '16');
                statusText.setAttribute('font-weight', 'bold');
                statusText.setAttribute('fill', fillColor);
                statusText.textContent = statusSymbol;
                xLabelsGroup.appendChild(statusText);
            }
        }
    });
    svg.appendChild(xLabelsGroup);
    
    // Draw production line - starting from the first tick (start time) with zero production
    const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let productionPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const productionPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        production: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for production line with proper cumulative totals
    filteredData.forEach((dataPoint) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
        
        productionPoints.push({ 
            x, 
            y, 
            production: dataPoint.production, 
            hour: dataPoint.hour 
        });
        productionPathD += ` L ${x} ${y}`;
    });
    
    // Add production line
    const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    productionPath.setAttribute('d', productionPathD);
    productionPath.setAttribute('stroke', 'var(--production-color)');
    productionPath.setAttribute('stroke-width', '3');
    productionPath.setAttribute('fill', 'none');
    productionLineGroup.appendChild(productionPath);
    
    // Add production points and labels
    productionPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', isFullscreen ? '5' : '4');
        circle.setAttribute('fill', 'var(--production-color)');
        productionLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 8);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('fill', 'var(--production-color)');
        text.textContent = point.production;
        productionLineGroup.appendChild(text);
    });
    svg.appendChild(productionLineGroup);
    
    // Draw target line - starting from the first tick (start time) with zero target
    const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let targetPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const targetPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        target: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for target line with proper cumulative totals
    filteredData.forEach((dataPoint) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
        
        targetPoints.push({ 
            x, 
            y, 
            target: dataPoint.target, 
            hour: dataPoint.hour 
        });
        targetPathD += ` L ${x} ${y}`;
    });
    
    // Add target line
    const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    targetPath.setAttribute('d', targetPathD);
    targetPath.setAttribute('stroke', 'var(--target-color)');
    targetPath.setAttribute('stroke-width', '3');
    targetPath.setAttribute('fill', 'none');
    targetLineGroup.appendChild(targetPath);
    
    // Add target points and labels
    targetPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', isFullscreen ? '5' : '4');
        circle.setAttribute('fill', 'var(--target-color)');
        targetLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 8);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', isFullscreen ? '14' : '12');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('fill', 'var(--target-color)');
        text.textContent = point.target;
        targetLineGroup.appendChild(text);
    });
    svg.appendChild(targetLineGroup);
}
        
        // Function to display a group
        function displayGroup(group) {
            // Set current product and supervisor
            currentProduct = group.product;
            currentSupervisor = group.supervisor;
            currentProductVariants = group.variants;
            
            // Find current variant
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Sort variants by start time
            const sortedVariants = [...currentProductVariants].sort((a, b) => {
                const supervisorA = group.supervisorData.variants[a.variant];
                const supervisorB = group.supervisorData.variants[b.variant];
                
                const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                
                const [hoursA, minutesA] = timeA.split(':').map(Number);
                const [hoursB, minutesB] = timeB.split(':').map(Number);
                
                return (hoursA * 60 + minutesA) - (hoursB * 60 + minutesB);
            });
            
            // Find the current active variant
            let currentVariantIndex = -1;
            
            for (let i = 0; i < sortedVariants.length; i++) {
                const variant = sortedVariants[i];
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) continue;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Check if current time is within this variant's window
                if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                    currentVariantIndex = i;
                    break;
                }
            }
            
            // If no current variant found, use last variant
            if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                currentVariantIndex = sortedVariants.length - 1;
            }
            
            // Set current variant
            currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
            
            // Apply styling based on supervisor
            applySupervisorStyling(currentSupervisor);
            
            // Update UI
            updateSupervisorInfo(group);
            updateMetrics(group);
            
            // Small delay to ensure UI updates before redrawing charts
            setTimeout(() => {
                renderCumulativeChart(group);
                renderHourlyChart(group);
            }, 50);
        }

        // Function to apply supervisor styling
        function applySupervisorStyling(supervisorName) {
            const supervisorColorBanner = document.querySelector('.supervisor-color-banner');
            supervisorPanel = document.querySelector('.supervisor-panel');
            
            // Apply supervisor-specific color
            if (supervisorName) {
                const color = getSupervisorColor(supervisorName);
                supervisorColorBanner.style.backgroundColor = color;
                supervisorPanel.style.backgroundColor = color;
            }
        }

        // Function to update supervisor info
        function updateSupervisorInfo(group) {
            document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${group.supervisor}`;
            document.getElementById('product-name').textContent = `PRODUCT: ${group.product}`;
            
            // Update variant sequence
            const sequenceContainer = document.getElementById('variant-sequence');
            sequenceContainer.innerHTML = '';
            
            if (group.variants.length === 0) {
                sequenceContainer.innerHTML = '<div>No variants available</div>';
                return;
            }
            
            // Get current time to determine variant status
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Add each variant to the sequence
            group.variants.forEach((variant, index) => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Determine variant status
                let status = '';
                if (currentTimeMinutes < startTimeMinutes) {
                    status = 'upcoming';
                } else if (currentTimeMinutes > endTimeMinutes) {
                    status = 'completed';
                } else {
                    status = 'current';
                }
                
                // Extract variant name from full variant string
                let displayName = variant.variant;
                
                // Try to extract just the variant part
                if (variant.variant.includes('-')) {
                    displayName = variant.variant.split('-').pop();
                } else if (variant.variant.startsWith(group.product + ' ')) {
                    displayName = variant.variant.substring(group.product.length + 1);
                }
                
                // Create variant element
                const variantElement = document.createElement('div');
                variantElement.className = `variant-item ${status}`;
                variantElement.textContent = displayName;
                
                sequenceContainer.appendChild(variantElement);
                
                // Add arrow if not the last variant
                if (index < group.variants.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-right';
                    arrow.textContent = '';
                    sequenceContainer.appendChild(arrow);
                }
            });
        }

        // Function to update metrics
        function updateMetrics(group) {
            // Initialize aggregated values
            let totalTarget = 0;
            let totalProduction = 0;
            let totalBoxTarget = 0;
            let totalBoxProduction = 0;
            let weightedCycleTime = 0;
            let totalCycleTimeWeight = 0;
            
            // Calculate aggregated values
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                    totalProduction += (supervisorVariant.currentTotal || 0);
                    
                    // Add box totals consistently for all variants
                    totalBoxTarget += (variant.dailyBoxTarget || 0);
                    totalBoxProduction += (variant.currentBoxTotal || 0);
                    
                    // Add cycle time weighted by target
                    const cycleTime = variant.cycleTime || 0;
                    const target = supervisorVariant.dailyTarget || 0;
                    
                    if (cycleTime > 0 && target > 0) {
                        weightedCycleTime += cycleTime * target;
                        totalCycleTimeWeight += target;
                    }
                }
            });
            
            // Calculate overall progress percentage
            const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            // Calculate average cycle time
            const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
            
            // Calculate actual cycle time across all variants
            const actualCycleTime = calculateActualCycleTime(group.variants);
            
            // Update metrics display
            document.getElementById('current-units').textContent = totalProduction;
            document.getElementById('target-units').textContent = totalTarget;
            document.getElementById('progress-percentage').textContent = `${progressPercentage}%`;
            
            document.getElementById('current-boxes').textContent = totalBoxProduction;
            document.getElementById('target-boxes').textContent = totalBoxTarget;
            
            document.getElementById('actual-cycle-time').textContent = actualCycleTime === "N/A" ? "N/A" : actualCycleTime;
            document.getElementById('target-cycle-time').textContent = avgCycleTime;
        }

       function calculateActualCycleTime(variants) {
    // Check if any variant has actualCycleTime - if so, use weighted average of those values
    const variantsWithActualCycleTime = variants.filter(v => v.actualCycleTime !== undefined && v.actualCycleTime !== null);
    
    if (variantsWithActualCycleTime.length > 0) {
        // Calculate weighted average of actualCycleTime if multiple variants
        if (variantsWithActualCycleTime.length > 1) {
            let totalWeight = 0;
            let weightedSum = 0;
            
            // Weight by production quantities
            variantsWithActualCycleTime.forEach(variant => {
                const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                if (supervisor && supervisor.variants[variant.variant]) {
                    const supervisorVariant = supervisor.variants[variant.variant];
                    if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                        totalWeight += supervisorVariant.currentTotal;
                        weightedSum += variant.actualCycleTime * supervisorVariant.currentTotal;
                    }
                }
            });
            
            if (totalWeight > 0) {
                return Math.round(weightedSum / totalWeight);
            } else {
                // If no weights, use simple average
                const sum = variantsWithActualCycleTime.reduce((acc, v) => acc + v.actualCycleTime, 0);
                return Math.round(sum / variantsWithActualCycleTime.length);
            }
        } else {
            // If only one variant, just return its actualCycleTime
            return variantsWithActualCycleTime[0].actualCycleTime;
        }
    }
    
    // Fall back to original calculation if no actualCycleTime is available
    let totalProduction = 0;
    let totalElapsedWorkingTime = 0;
    
    variants.forEach(variant => {
        const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
        if (supervisor && supervisor.variants[variant.variant]) {
            const supervisorVariant = supervisor.variants[variant.variant];
            
            if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                
                if (startTimeStr && variant.hourlyProduction) {
                    // Find the last hour with non-zero production
                    const hoursWithProduction = variant.hourlyProduction
                        .filter(h => h.production > 0)
                        .sort((a, b) => {
                            const [hourA, minuteA] = a.hour.split(':').map(Number);
                            const [hourB, minuteB] = b.hour.split(':').map(Number);
                            return (hourB * 60 + minuteB) - (hourA * 60 + minuteA); // Sort descending
                        });
                    
                    if (hoursWithProduction.length > 0) {
                        // Get the latest hour with non-zero production
                        const lastProductionHourData = hoursWithProduction[0];
                        const [lastHours, lastMinutes] = lastProductionHourData.hour.split(':').map(Number);
                        const lastTotalMinutes = lastHours * 60 + lastMinutes;
                        
                        const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                        const startTotalMinutes = startHours * 60 + startMinutes;
                        
                        // Calculate elapsed time in minutes (from start until last production hour)
                        let elapsedMinutes = lastTotalMinutes - startTotalMinutes;
                        if (elapsedMinutes < 0) {
                            elapsedMinutes += 24 * 60; // Handle case where start was yesterday
                        }
                        
                        // Create a date object for the last production hour to calculate break times
                        const now = new Date();
                        const lastProductionTime = new Date(now);
                        lastProductionTime.setHours(lastHours);
                        lastProductionTime.setMinutes(lastMinutes);
                        
                        // Calculate elapsed break time
                        const elapsedBreakMinutes = calculateElapsedBreakMinutes(variant, startTimeStr, lastProductionTime);
                        
                        // Calculate actual working time
                        const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                        
                        // Add to totals
                        totalProduction += supervisorVariant.currentTotal;
                        totalElapsedWorkingTime += workingMinutes * 60; // Convert to seconds
                    }
                }
            }
        }
    });
    
    if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
    
    // Calculate overall cycle time
    return Math.round(totalElapsedWorkingTime / totalProduction);
}
        
// Helper function to calculate elapsed break minutes
function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
    let totalElapsedBreakMinutes = 0;
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    // Function to check if a break has already occurred or is occurring
    const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
        if (!breakStartStr || !breakEndStr) return 0;
        if (breakStartStr === "-" || breakEndStr === "-") return 0;
        
        const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
        const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
        
        const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
        const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
        
        // If break hasn't started yet, return 0
        if (currentTime < breakStartMinutes) return 0;
        
        // If break is in progress, return elapsed portion
        if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
        
        // If break is complete, return full duration
        return breakEndMinutes - breakStartMinutes;
    };
    
    // Check each break
    if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
    }
    
    if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
    }
    
    if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
        variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
    }
    
    return totalElapsedBreakMinutes;
}

// Initialize the dashboard when DOM is fully loaded
document.addEventListener('DOMContentLoaded', initDashboard);

// Make sure we cleanup on page unload
window.addEventListener('beforeunload', function() {
    // Clear all intervals to prevent memory leaks
    if (cycleInterval) clearInterval(cycleInterval);
    if (chartRotationInterval) clearInterval(chartRotationInterval);
    if (countdownInterval) clearInterval(countdownInterval);
});
    </script>
</body>
</html>

        
