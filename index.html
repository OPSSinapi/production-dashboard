<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <link rel="icon" href="data:,">
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        :root {
    --primary-color: #2c3e50;
    --secondary-color: #3B82F6;
    --success-color: #10B981;
    --warning-color: #F59E0B;
    --danger-color: #e74c3c;
    --light-color: #f3f4f6;
    --dark-color: #1e293b;
    --supervisor-luthando: #F9E79F;
    --supervisor-apelele: #e6e6e6;
    --supervisor-siyabonga: #FADBD8;
    --supervisor-nosi: #D6EAF8;
    --supervisor-mvokwe: #D5F5E3;
    --supervisor-michaela: #F9E79F;
    --production-color: #e74c3c;
    --target-color: #10B981;
    --current-indicator: #F59E0B;
    --completed-variant: #D1E7DD;
    --current-variant: #FFF3CD;
    --upcoming-variant: #F8D7DA;
    --legend-bg: #f8fafc;
    --status-met: #D1E7DD;
    --status-missed: #FECDD3;
    --status-current: #FEF9C3;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
}

body {
    font-family: Arial, Helvetica, sans-serif;
    background-color: var(--light-color);
    color: var(--primary-color);
    transition: background-color 0.3s ease;
}

.dashboard-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    padding: clamp(0.5rem, 1vw, 1rem);
    transition: all 0.3s ease;
}

.dashboard-container.fullscreen-mode {
    padding: clamp(0.25rem, 0.5vw, 0.5rem);
}

.supervisor-color-banner {
    width: 100%;
    height: clamp(0.5rem, 1vh, 1.25rem);
    border-radius: 3px;
    margin-bottom: clamp(0.15rem, 0.3vh, 0.3rem);
    transition: height 0.3s ease;
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    padding-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    min-height: fit-content;
    flex-shrink: 0;
}

.title-section {
    display: flex;
    align-items: center;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.title {
    font-size: clamp(1.4rem, 2.2vw, 2.8rem);
    font-weight: bold;
    color: var(--primary-color);
    white-space: nowrap;
}

.controls-section {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.filter-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.filter-select {
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem);
    min-width: clamp(120px, 10vw, 180px);
    background-color: white;
}

.buttons-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.supervisor-select-btn {
    background-color: var(--secondary-color);
    color: white;
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    min-width: clamp(100px, 8vw, 140px);
    white-space: nowrap;
    transition: all 0.2s ease;
}

.supervisor-select-btn:hover {
    background-color: #2563eb;
}

.fullscreen-button {
    background-color: #e2e8f0;
    color: var(--dark-color);
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s ease;
}

.fullscreen-button:hover {
    background-color: #cbd5e1;
}

.date-time {
    text-align: right;
    white-space: nowrap;
}

.time {
    font-size: clamp(1.2rem, 1.8vw, 2.2rem);
    font-weight: bold;
}

.legend-section {
    width: 100%;
    background-color: var(--legend-bg);
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.75rem, 1.25vw, 1.25rem);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    border-radius: 0.5rem;
    flex-shrink: 0;
}

.legend-container {
    display: flex;
    flex-wrap: wrap;
    gap: clamp(1rem, 3vw, 3rem);
}

.legend-item {
    display: flex;
    align-items: center;
}

.legend-color {
    width: clamp(1.5rem, 2.2vw, 2.5rem);
    height: clamp(1.5rem, 2.2vw, 2.5rem);
    margin-right: clamp(0.25rem, 0.5vw, 0.5rem);
    border-radius: 5px;
}

.legend-label {
    font-size: clamp(1rem, 1.4vw, 1.6rem);
    font-weight: 700;
    white-space: nowrap;
}

.current-hour-info {
    font-size: clamp(1rem, 1.4vw, 1.6rem);
    color: var(--secondary-color);
    font-weight: 700;
    white-space: nowrap;
    text-align: right;
}

.content {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.charts-row {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.main-content {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex-shrink: 0;
    overflow: visible;
}

.top-row {
    display: flex;
    gap: clamp(0.5rem, 1vw, 1rem);
    width: 100%;
    flex-shrink: 0;
    overflow: visible;
}

.supervisor-panel {
    flex: 0 0 clamp(250px, 25vw, 450px);
    background-color: var(--supervisor-mvokwe);
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    display: flex;
    flex-direction: column;
}

.supervisor-name {
    font-size: clamp(1.2rem, 1.7vw, 2rem);
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    color: var(--dark-color);
}

.product-name {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem);
    color: var(--dark-color);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
}

.variant-sequence {
    display: flex;
    align-items: center;
    font-size: clamp(0.9rem, 1.2vw, 1.4rem);
    flex-wrap: wrap;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    margin-top: auto;
}

.variant-item {
    padding: clamp(0.35rem, 0.75vh, 0.75rem) clamp(0.5rem, 1vw, 1rem);
    border-radius: 8px;
    white-space: nowrap;
    position: relative;
    text-align: center;
    min-width: clamp(60px, 7vw, 100px);
}

.variant-item.completed {
    background-color: var(--completed-variant);
    color: var(--dark-color);
}

.variant-item.current {
    background-color: var(--current-variant);
    color: var(--dark-color);
    font-weight: bold;
}

.variant-item.upcoming {
    background-color: var(--upcoming-variant);
    color: var(--dark-color);
}

.arrow-right {
    margin: 0 clamp(0.1rem, 0.25vw, 0.25rem);
    font-size: clamp(1.1rem, 1.45vw, 1.7rem);
    color: var(--dark-color);
}

.metrics-container {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.metric-card {
    flex: 1 1 clamp(150px, 15vw, 300px);
    min-width: clamp(120px, 15vw, 200px);
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.metric-title {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem);
    font-weight: bold;
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    color: var(--primary-color);
    text-align: center;
}

.metric-value {
    font-size: clamp(1.8rem, 2.8vw, 3.4rem);
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    text-align: center;
}

.metric-subvalue {
    font-size: clamp(0.9rem, 1.3vw, 1.6rem);
    text-align: center;
}

.current-value {
    color: var(--production-color);
}

.target-value {
    color: var(--target-color);
}

.charts-container {
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    position: relative;
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
}

.chart-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem);
    font-weight: 600;
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    color: var(--primary-color);
    flex-shrink: 0;
    text-align: center;
}

.chart-area {
    flex: 1;
    position: relative;
    min-height: 0;
    overflow: hidden;
}

.chart {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 1;
    transition: opacity 0.5s ease;
}

.chart.hidden {
    opacity: 0;
    pointer-events: none;
}

.chart-nav {
    display: flex;
    justify-content: center;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-top: clamp(0.5rem, 1vh, 1rem);
}

.chart-nav-dot {
    width: clamp(0.8rem, 1.3vw, 1.2rem);
    height: clamp(0.8rem, 1.3vw, 1.2rem);
    border-radius: 50%;
    background-color: #cbd5e1;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
}

.chart-nav-dot.active {
    background-color: var(--secondary-color);
    transform: scale(1.2);
}

.batch-info-section {
    flex: 0 0 clamp(375px, 32vw, 650px);
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    max-height: 100%;
}

.batch-info-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem);
    font-weight: bold;
    margin-bottom: clamp(0.75rem, 1.5vh, 1.5rem);
    color: var(--primary-color);
    text-align: center;
}

.batch-info-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
}

.batch-info-table th {
    background-color: var(--primary-color);
    color: white;
    font-size: clamp(0.9rem, 1.3vw, 1.6rem);
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.25rem, 0.5vw, 0.5rem);
    text-align: left;
    position: sticky;
    top: 0;
}

.batch-info-table td {
    font-size: clamp(0.85rem, 1.2vw, 1.5rem);
    padding: clamp(0.4rem, 0.8vh, 0.8rem) clamp(0.25rem, 0.5vw, 0.5rem);
    border-bottom: 1px solid #e2e8f0;
}

.batch-info-table tr:nth-child(even) {
    background-color: #f8fafc;
}

.batch-info-table tr:hover {
    background-color: #e9f5fd;
}

.batch-info-table tr.current {
    background-color: var(--current-variant);
}

.batch-number {
    font-weight: bold;
}

.view-toggle-container {
    display: flex;
    align-items: center;
}

.view-toggle-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    gap: clamp(0.5rem, 0.75vw, 0.75rem);
}

.view-toggle-checkbox {
    display: none;
}

.view-toggle-slider {
    position: relative;
    width: clamp(50px, 5vw, 60px);
    height: clamp(26px, 2.5vw, 32px);
    background-color: #cbd5e1;
    border-radius: clamp(13px, 1.25vw, 16px);
    transition: background-color 0.3s ease;
}

.view-toggle-slider::before {
    content: '';
    position: absolute;
    width: clamp(20px, 2vw, 24px);
    height: clamp(20px, 2vw, 24px);
    left: clamp(3px, 0.3vw, 4px);
    top: 50%;
    transform: translateY(-50%);
    background-color: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
}

.view-toggle-checkbox:checked + .view-toggle-slider {
    background-color: var(--secondary-color);
}

.view-toggle-checkbox:checked + .view-toggle-slider::before {
    transform: translateY(-50%) translateX(clamp(24px, 2.5vw, 28px));
}

.view-toggle-text {
    font-size: clamp(0.85rem, 1.1vw, 1.2rem);
    font-weight: 500;
    color: var(--dark-color);
    white-space: nowrap;
}

.target-board-container {
    display: none;
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    background-color: #1e293b;
    border-radius: 12px;
    padding: clamp(1rem, 2vh, 2rem);
}

.target-board-container.active {
    display: flex;
    flex-direction: column;
}

.target-board-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: clamp(1rem, 2vh, 2rem);
}

.target-board-title {
    font-size: clamp(1.8rem, 2.5vw, 3rem);
    font-weight: bold;
    color: white;
}

.target-board-subtitle {
    font-size: clamp(1.2rem, 1.7vw, 2rem);
    color: #94a3b8;
}

.target-board-content {
    flex: 1;
    display: flex;
    gap: clamp(1rem, 2vw, 2rem);
    overflow: hidden;
}

.target-board-left {
    flex: 0 0 clamp(300px, 35vw, 500px);
    display: flex;
    flex-direction: column;
    gap: clamp(1rem, 2vh, 2rem);
}

.supervisor-info-box {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    border-radius: 12px;
    padding: clamp(1.5rem, 3vh, 3rem);
    color: white;
}

.supervisor-info-label {
    font-size: clamp(1rem, 1.3vw, 1.5rem);
    opacity: 0.9;
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
}

.supervisor-info-value {
    font-size: clamp(1.6rem, 2.2vw, 2.8rem);
    font-weight: bold;
}

.target-summary-box {
    background-color: #2d3748;
    border-radius: 12px;
    padding: clamp(1.5rem, 3vh, 3rem);
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.target-summary-label {
    font-size: clamp(1.2rem, 1.6vw, 2rem);
    color: #94a3b8;
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
}

.target-summary-value {
    font-size: clamp(3rem, 5vw, 6rem);
    font-weight: bold;
    color: white;
}

.target-board-right {
    flex: 1;
    background-color: #2d3748;
    border-radius: 12px;
    padding: clamp(1rem, 2vh, 2rem);
    overflow-y: auto;
}

.target-board-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
}

.target-board-table thead th {
    position: sticky;
    top: 0;
    background-color: #1e293b;
    color: white;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    font-size: clamp(1.2rem, 1.6vw, 2rem);
    text-align: center;
    border-bottom: 2px solid #475569;
    z-index: 10;
}

.target-board-table tbody td {
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    text-align: center;
    font-size: clamp(1.4rem, 1.9vw, 2.4rem);
    font-weight: bold;
    border-bottom: 1px solid #475569;
}

.target-board-table tbody tr {
    transition: transform 0.2s ease;
}

.target-board-table tbody tr.current-hour {
    outline: 3px solid #f59e0b;
    outline-offset: -3px;
}

.target-board-table .time-cell {
    color: white;
    background-color: #374151;
    font-size: clamp(1.3rem, 1.8vw, 2.2rem);
    border-radius: 8px 0 0 8px;
}

.target-board-table .target-cell {
    color: white;
    background-color: #374151;
}

.target-board-table .actual-cell {
    color: white;
    border-radius: 0 8px 8px 0;
}

.target-board-table .actual-cell.met {
    background-color: #059669;
}

.target-board-table .actual-cell.not-met {
    background-color: #dc2626;
}

.target-board-table .actual-cell.pending {
    background-color: #374151;
}

.footer {
    margin-top: clamp(0.25rem, 0.5vh, 0.5rem);
    font-size: clamp(0.85rem, 1.1vw, 1.3rem);
    color: var(--dark-color);
    width: 100%;
    flex-shrink: 0;
}

.update-info {
    text-align: left;
}

.supervisor-select-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(2px);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from {opacity: 0}
    to {opacity: 1}
}

.supervisor-select-content {
    position: relative;
    background-color: #fefefe;
    margin: 10vh auto;
    padding: 0;
    border-radius: 8px;
    width: clamp(300px, 80vw, 600px);
    max-height: 80vh;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    animation: slideIn 0.3s ease;
    display: flex;
    flex-direction: column;
}

@keyframes slideIn {
    from {transform: translateY(-50px); opacity: 0}
    to {transform: translateY(0); opacity: 1}
}

.supervisor-select-header {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.supervisor-select-header h3 {
    margin: 0;
    font-size: clamp(1.3rem, 1.7vw, 1.9rem);
    color: var(--dark-color);
}

.supervisor-select-close {
    color: #aaa;
    font-size: clamp(1.8rem, 2.5vw, 2.8rem);
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
}

.supervisor-select-close:hover {
    color: var(--dark-color);
}

.supervisor-select-body {
    padding: clamp(1rem, 2vw, 2rem);
    overflow-y: auto;
    flex: 1;
}

.supervisor-checkboxes {
    display: flex;
    flex-direction: column;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.supervisor-checkbox-item {
    display: flex;
    align-items: center;
    padding: clamp(0.5rem, 1vh, 1rem);
    border-radius: 6px;
    transition: background-color 0.2s;
}

.supervisor-checkbox-item:hover {
    background-color: #f8fafc;
}

.supervisor-checkbox-item input[type="checkbox"] {
    width: clamp(18px, 1.7vw, 22px);
    height: clamp(18px, 1.7vw, 22px);
    margin-right: clamp(0.5rem, 1vw, 1rem);
    cursor: pointer;
}

.supervisor-checkbox-item label {
    font-size: clamp(1.1rem, 1.4vw, 1.6rem);
    font-weight: 500;
    cursor: pointer;
    flex: 1;
}

.supervisor-select-footer {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: flex-end;
    gap: clamp(0.5rem, 1vw, 1rem);
    flex-shrink: 0;
}

@media screen and (min-width: 2000px) {
    .chart-title {
        font-size: clamp(1.4rem, 2vw, 2.4rem);
    }
    
    .legend-label {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
    
    .current-hour-info {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
}

@media screen and (max-width: 1200px) {
    .charts-row {
        flex-direction: column;
    }
    
    .top-row {
        flex-direction: column;
    }
    
    .supervisor-panel {
        flex: 0 0 auto;
        width: 100%;
    }
    
    .metrics-container {
        width: 100%;
    }
    
    .batch-info-section {
        flex: 0 0 auto;
        width: 100%;
        max-height: 300px;
    }
    
    .target-board-content {
        flex-direction: column;
    }
    
    .target-board-left {
        flex: 0 0 auto;
        width: 100%;
    }
    
    .target-board-right {
        flex: 1;
    }
}

@media screen and (max-width: 768px) {
    .header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .controls-section {
        width: 100%;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .filter-container {
        width: 100%;
    }
    
    .filter-select {
        flex: 1;
    }
    
    .buttons-container {
        width: 100%;
    }
    
    .date-time {
        align-self: flex-end;
        margin-top: clamp(0.5rem, 1vh, 1rem);
    }
}

@media screen and (max-height: 768px) and (orientation: landscape) {
    .dashboard-container {
        padding: clamp(0.25rem, 0.5vw, 0.5rem);
    }
    
    .header {
        padding-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    }
    
    .legend-section {
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 1vw, 1rem);
    }
}
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="supervisor-color-banner"></div>
        
        <div class="header">
            <div class="title-section">
                <div class="title">Sinapi Secondary Production Dashboard</div>
            </div>
            
            <div class="controls-section">
                <div class="filter-container">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                
                <div class="buttons-container">
                    <button id="supervisor-select-btn" class="supervisor-select-btn">
                        Select Supervisors
                    </button>
                    <button id="fullscreen-button" class="fullscreen-button">Fullscreen</button>
                    <div class="view-toggle-container">
                        <label class="view-toggle-label">
                            <input type="checkbox" id="view-toggle" class="view-toggle-checkbox">
                            <span class="view-toggle-slider"></span>
                            <span class="view-toggle-text">Target Board</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="date-time">
                <div class="time" id="current-time">Loading...</div>
            </div>
        </div>
        
        <div class="legend-section">
            <div class="legend-container">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--production-color);"></div>
                    <div class="legend-label">PRODUCTION</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--target-color);"></div>
                    <div class="legend-label">TARGET</div>
                </div>
            </div>
            <div class="current-hour-info" id="current-hour-info">CURRENT HOUR: --:-- (-- MIN LEFT)</div>
        </div>
        
        <div class="content">
            <div class="main-content">
                <div class="top-row">
                    <div class="supervisor-panel">
                        <div class="supervisor-name" id="supervisor-name">SUPERVISOR: Loading...</div>
                        <div class="product-name" id="product-name">PRODUCT: Loading...</div>
                        
                        <div class="variant-sequence" id="variant-sequence">
                            <div class="loading">Loading variants...</div>
                        </div>
                    </div>
                    
                    <div class="metrics-container">
                        <div class="metric-card">
                            <div class="metric-title">UNITS</div>
                            <div class="metric-value">
                                <span class="current-value" id="current-units">0</span>/<span class="target-value" id="target-units">0</span>
                            </div>
                            <div class="metric-subvalue" id="progress-percentage">0%</div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-title">BOXES</div>
                            <div class="metric-value">
                                <span class="current-value" id="current-boxes">0</span>/<span class="target-value" id="target-boxes">0</span>
                            </div>
                            <div class="metric-subvalue">completed</div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-title">CYCLE TIME</div>
                            <div class="metric-value">
                                <span class="current-value" id="actual-cycle-time">0</span>/<span class="target-value" id="target-cycle-time">0</span>
                            </div>
                            <div class="metric-subvalue">seconds</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="charts-row">
                <div class="charts-container">
                    <div class="chart-title" id="chart-title">Production Progress</div>
                    <div class="chart-area">
                        <div class="chart" id="cumulative-chart"></div>
                        <div class="chart hidden" id="hourly-chart"></div>
                    </div>
                    <div class="chart-nav">
                        <div class="chart-nav-dot active" data-chart="cumulative"></div>
                        <div class="chart-nav-dot" data-chart="hourly"></div>
                    </div>
                </div>
                
                <div class="batch-info-section">
                    <div class="batch-info-title">BATCH INFORMATION</div>
                    <table class="batch-info-table" id="batch-info-table">
                        <thead id="batch-info-thead">
                        </thead>
                        <tbody id="batch-info-tbody">
                            <tr>
                                <td colspan="5">Loading batch information...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="target-board-container" id="target-board-container">
            <div class="target-board-header">
                <div class="target-board-title">DAILY TARGET BOARD</div>
                <div class="target-board-subtitle" id="board-product-name">PRODUCT</div>
            </div>
            
            <div class="target-board-content">
                <div class="target-board-left">
                    <div class="supervisor-info-box" id="board-supervisor-box">
                        <div class="supervisor-info-label">SUPERVISOR</div>
                        <div class="supervisor-info-value" id="board-supervisor-name">Loading...</div>
                    </div>
                    
                    <div class="target-summary-box">
                        <div class="target-summary-label">DAILY TARGET</div>
                        <div class="target-summary-value" id="board-daily-target">0</div>
                    </div>
                </div>
                
                <div class="target-board-right">
                    <table class="target-board-table">
                        <thead>
                            <tr>
                                <th>TIME</th>
                                <th>TARGET</th>
                                <th>ACTUAL</th>
                            </tr>
                        </thead>
                        <tbody id="target-board-tbody">
                            <tr>
                                <td colspan="3">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <div class="update-info" id="last-update">Last updated: Never</div>
        </div>
        
        <div id="supervisor-select-modal" class="supervisor-select-modal">
            <div class="supervisor-select-content">
                <div class="supervisor-select-header">
                    <h3>Select Supervisors to Display</h3>
                    <span class="supervisor-select-close">&times;</span>
                </div>
                <div class="supervisor-select-body">
                    <div id="supervisor-checkboxes" class="supervisor-checkboxes">
                    </div>
                </div>
                <div class="supervisor-select-footer">
                    <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                    <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                    <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 30 * 1000;
        const CYCLE_INTERVAL = 20000;

        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        let cycleInterval = null;
        let cycleIndex = 0;
        
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;
        let selectedSupervisors = [];
        let supervisorFilterActive = false;
        
        let isTargetBoardView = false;
        
        let chartRotationInterval = null;
        let currentChartIndex = 0;
        const CHART_ROTATION_INTERVAL = 10000;

        let viewportWidth, viewportHeight, chartWidth, chartHeight;

        let dashboardContainer, supervisorPanel, chartsRow;
        let fullscreenButton;

        function initDashboard() {
            dashboardContainer = document.querySelector('.dashboard-container');
            supervisorPanel = document.querySelector('.supervisor-panel');
            fullscreenButton = document.getElementById('fullscreen-button');

            updateDateTime();
            updateViewportDimensions();
            setInterval(updateDateTime, 1000);

            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            initSupervisorSelection();
            
            setupChartNavigation();
            
            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            fullscreenButton.addEventListener('click', toggleFullscreen);
            window.addEventListener('resize', handleResize);
            
            document.getElementById('view-toggle').addEventListener('change', handleViewToggle);
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }
        
        function setupChartNavigation() {
            const navDots = document.querySelectorAll('.chart-nav-dot');
            navDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    const chartType = this.getAttribute('data-chart');
                    showChart(chartType);
                    
                    if (chartRotationInterval) {
                        clearInterval(chartRotationInterval);
                        startChartRotation();
                    }
                });
            });
            
            startChartRotation();
        }
        
        function startChartRotation() {
            if (chartRotationInterval) {
                clearInterval(chartRotationInterval);
            }
            
            chartRotationInterval = setInterval(() => {
                currentChartIndex = (currentChartIndex + 1) % 2;
                const chartType = currentChartIndex === 0 ? 'cumulative' : 'hourly';
                showChart(chartType);
            }, CHART_ROTATION_INTERVAL);
        }
        
        function showChart(chartType) {
            const cumulativeChart = document.getElementById('cumulative-chart');
            const hourlyChart = document.getElementById('hourly-chart');
            const chartTitle = document.getElementById('chart-title');
            const navDots = document.querySelectorAll('.chart-nav-dot');
            
            navDots.forEach(dot => {
                if (dot.getAttribute('data-chart') === chartType) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
            
            if (chartType === 'cumulative') {
                currentChartIndex = 0;
                cumulativeChart.classList.remove('hidden');
                hourlyChart.classList.add('hidden');
                chartTitle.textContent = "TODAY'S PRODUCTION PROGRESS";
            } else {
                currentChartIndex = 1;
                cumulativeChart.classList.add('hidden');
                hourlyChart.classList.remove('hidden');
                
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const displayHour = currentMinute < 30 ? currentHour : currentHour + 1;
                const hourStr = `${displayHour.toString().padStart(2, '0')}:30`;
                
                chartTitle.textContent = `CURRENT HOUR: ${hourStr} PRODUCTION`;
            }
        }

        function updateViewportDimensions() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;
        }

        function handleResize() {
            updateViewportDimensions();
            
            if (Math.abs(window.innerWidth - viewportWidth) > 20 || 
                Math.abs(window.innerHeight - viewportHeight) > 20) {
                
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(function() {
                    redrawDashboard();
                }, 250);
            }
        }

        function redrawDashboard() {
            dashboardContainer.style.display = 'none';
            void dashboardContainer.offsetHeight;
            dashboardContainer.style.display = 'flex';
            
            updateDashboard();
        }
        
        function handleViewToggle(event) {
            isTargetBoardView = event.target.checked;
            
            const content = document.querySelector('.content');
            const targetBoardContainer = document.getElementById('target-board-container');
            
            if (isTargetBoardView) {
                content.style.display = 'none';
                targetBoardContainer.classList.add('active');
                
                updateDashboard();
            } else {
                content.style.display = 'flex';
                targetBoardContainer.classList.remove('active');
                
                updateDashboard();
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement && 
                !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && 
                !document.msFullscreenElement) {
                
                try {
                    dashboardContainer.classList.add('fullscreen-mode');
                    isFullscreen = true;
                    fullscreenButton.textContent = 'Exit Fullscreen';
                    
                    if (dashboardContainer.requestFullscreen) {
                        dashboardContainer.requestFullscreen();
                    } else if (dashboardContainer.msRequestFullscreen) {
                        dashboardContainer.msRequestFullscreen();
                    } else if (dashboardContainer.mozRequestFullScreen) {
                        dashboardContainer.mozRequestFullScreen();
                    } else if (dashboardContainer.webkitRequestFullscreen) {
                        dashboardContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                    } else {
                        simulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Fullscreen API error:', error);
                    simulatedFullscreen();
                }
            } else {
                try {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else {
                        exitSimulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Exiting fullscreen error:', error);
                    exitSimulatedFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && 
                !document.msFullscreenElement) {
                
                if (isFullscreen) {
                    exitFullscreenMode();
                }
            } else {
                enterFullscreenMode();
            }
        }

        function enterFullscreenMode() {
            if (!isFullscreen) {
                dashboardContainer.classList.add('fullscreen-mode');
                isFullscreen = true;
                fullscreenButton.textContent = 'Exit Fullscreen';
                
                setTimeout(function() {
                    updateViewportDimensions();
                    updateDashboard();
                }, 100);
            }
        }

        function exitFullscreenMode() {
            dashboardContainer.classList.remove('fullscreen-mode');
            dashboardContainer.classList.remove('simulated-fullscreen');
            isFullscreen = false;
            fullscreenButton.textContent = 'Fullscreen';
            
            dashboardContainer.style.position = '';
            dashboardContainer.style.top = '';
            dashboardContainer.style.left = '';
            dashboardContainer.style.width = '';
            dashboardContainer.style.height = '';
            dashboardContainer.style.zIndex = '';
            document.body.style.overflow = '';
            
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        function simulatedFullscreen() {
            dashboardContainer.classList.add('fullscreen-mode');
            dashboardContainer.classList.add('simulated-fullscreen');
            isFullscreen = true;
            fullscreenButton.textContent = 'Exit Fullscreen';
            
            dashboardContainer.style.position = 'fixed';
            dashboardContainer.style.top = '0';
            dashboardContainer.style.left = '0';
            dashboardContainer.style.width = '100vw';
            dashboardContainer.style.height = '100vh';
            dashboardContainer.style.zIndex = '9999';
            document.body.style.overflow = 'hidden';
            
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        function exitSimulatedFullscreen() {
            exitFullscreenMode();
        }

        function initSupervisorSelection() {
            const selectBtn = document.getElementById('supervisor-select-btn');
            const modal = document.getElementById('supervisor-select-modal');
            const closeBtn = document.querySelector('.supervisor-select-close');
            const applyBtn = document.getElementById('apply-supervisor-selection');
            const selectAllBtn = document.getElementById('select-all-supervisors');
            const deselectAllBtn = document.getElementById('deselect-all-supervisors');
            
            selectBtn.addEventListener('click', function() {
                updateSupervisorCheckboxes();
                modal.style.display = 'block';
            });
            
            closeBtn.addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            applyBtn.addEventListener('click', function() {
                applySupervisorSelection();
                modal.style.display = 'none';
            });
            
            selectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            });
            
            deselectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            });
            
            if (productionData && productionData.supervisors) {
                selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
            }
        }

        function updateSupervisorCheckboxes() {
            const checkboxContainer = document.getElementById('supervisor-checkboxes');
            checkboxContainer.innerHTML = '';
            
            if (!productionData || !productionData.supervisors || productionData.supervisors.length === 0) {
                checkboxContainer.innerHTML = '<p>No supervisors available</p>';
                return;
            }
            
            productionData.supervisors.forEach(supervisor => {
                const item = document.createElement('div');
                item.className = 'supervisor-checkbox-item';
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = getSupervisorColor(supervisor.name);
                colorDiv.style.width = '16px';
                colorDiv.style.height = '16px';
                item.appendChild(colorDiv);
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'supervisor-checkbox';
                checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
                checkbox.value = supervisor.name;
                checkbox.checked = selectedSupervisors.includes(supervisor.name);
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = supervisor.name;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                checkboxContainer.appendChild(item);
            });
        }

        function applySupervisorSelection() {
            const checkboxes = document.querySelectorAll('.supervisor-checkbox');
            selectedSupervisors = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedSupervisors.push(checkbox.value);
                }
            });
            
            localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
            
            supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (supervisorFilterActive) {
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                selectBtn.classList.add('filtered');
            } else {
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
            }
            
            updateDashboard();
        }

        function getSupervisorColor(supervisorName) {
            const colorMap = {
                'Luthando': 'var(--supervisor-luthando)',
                'Apelele': 'var(--supervisor-apelele)',
                'Siyabonga': 'var(--supervisor-siyabonga)',
                'Nosi': 'var(--supervisor-nosi)',
                'Mvokwe': 'var(--supervisor-mvokwe)',
                'Michaela': 'var(--supervisor-michaela)'
            };
            
            return colorMap[supervisorName] || '#e2e8f0';
        }

        function loadSelectedSupervisors() {
            const stored = localStorage.getItem('selectedSupervisors');
            if (stored) {
                try {
                    selectedSupervisors = JSON.parse(stored);
                    
                    if (productionData && productionData.supervisors) {
                        const validSupervisors = productionData.supervisors.map(s => s.name);
                        selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                        
                        if (selectedSupervisors.length === 0) {
                            selectedSupervisors = validSupervisors;
                        }
                    }
                    
                    supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
                    const selectBtn = document.getElementById('supervisor-select-btn');
                    
                    if (supervisorFilterActive) {
                        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                        selectBtn.classList.add('filtered');
                    }
                } catch (e) {
                    console.error('Error parsing stored supervisors:', e);
                    if (productionData && productionData.supervisors) {
                        selectedSupervisors = productionData.supervisors.map(s => s.name);
                    }
                }
            }
        }

        async function fetchProductionData() {
            try {
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                if (!data) {
                    throw new Error('Empty data received from data.json');
                }
                
                const transformedData = transformDataFormat(data);
                
                if (!transformedData.variants || !Array.isArray(transformedData.variants) || 
                    !transformedData.supervisors || !Array.isArray(transformedData.supervisors)) {
                    throw new Error('Failed to transform data into the required format');
                }
                
                if (!lastUpdateTime || lastUpdateTime !== transformedData.timestamp) {
                    productionData = transformedData;
                    lastUpdateTime = transformedData.timestamp;
                    
                    productionData.originalData = data;
                    
                    document.getElementById('last-update').textContent = 'Last updated: ' + transformedData.timestamp;
                    
                    processProductSupervisorGroups();
                    
                    if (selectedSupervisors.length === 0) {
                        selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
                        loadSelectedSupervisors();
                    }
                    
                    updateFilterValueDropdown();
                    updateDashboard();
                }
                
                isLoading = false;
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
            }
        }

        function transformDataFormat(newData) {
            const transformedData = {
                variants: [],
                supervisors: [],
                timestamp: newData.metadata.timestamp || new Date().toISOString()
            };
            
            if (newData.production && Array.isArray(newData.production)) {
                
                newData.production.forEach(item => {
                    const transformedVariant = {
                        variant: item.id,
                        "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                        cycleTime: item.variant.cycleTime,
                        actualCycleTime: item.variant.actualCycleTime,
                        "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                        "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                        dailyBoxTarget: item.targets.boxes,
                        currentBoxTotal: item.actual.boxes,
                        hourlyTargets: [],
                        hourlyProduction: []
                    };
                    
                    if (item.timeline && Array.isArray(item.timeline)) {
                        item.timeline.forEach(hour => {
                            transformedVariant.hourlyTargets.push({
                                hour: hour.hour,
                                target: hour.target
                            });
                            
                            transformedVariant.hourlyProduction.push({
                                hour: hour.hour,
                                production: hour.actual
                            });
                        });
                    }
                    
                    transformedData.variants.push(transformedVariant);
                });
                
                if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                    newData.summary.supervisors.forEach(supervisor => {
                        const transformedSupervisor = {
                            name: supervisor.name,
                            variants: {}
                        };
                        
                        if (supervisor.variants && Array.isArray(supervisor.variants)) {
                            supervisor.variants.forEach(variantId => {
                                const prodItem = newData.production.find(p => p.id === variantId);
                                
                                if (prodItem) {
                                    const assignment = prodItem.supervisors.find(s => s.id === supervisor.id);
                                    
                                    if (assignment) {
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: assignment.startTime,
                                            variantEndTime: assignment.endTime,
                                            dailyTarget: assignment.target,
                                            currentTotal: assignment.production,
                                            variance: assignment.production - assignment.target,
                                            percentage: assignment.progress
                                        };
                                    } else {
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: prodItem.supervisors[0]?.startTime || "07:30",
                                            variantEndTime: prodItem.supervisors[0]?.endTime || "18:30",
                                            dailyTarget: prodItem.targets.daily,
                                            currentTotal: prodItem.actual.total,
                                            variance: prodItem.actual.total - prodItem.targets.daily,
                                            percentage: prodItem.actual.progress
                                        };
                                    }
                                }
                            });
                        }
                        
                        transformedData.supervisors.push(transformedSupervisor);
                    });
                }
            } else if (newData.variants && Array.isArray(newData.variants)) {
                transformedData.variants = newData.variants;
                transformedData.supervisors = newData.supervisors;
            }
            
            return transformedData;
        }
        
        function processProductSupervisorGroups() {
            productSupervisorGroups = {};
            
            productionData.supervisors.forEach(supervisor => {
                if (!supervisor.variants) return;
                
                const productVariants = {};
                
                Object.keys(supervisor.variants).forEach(variantKey => {
                    const product = extractProductFromVariant(variantKey);
                    
                    if (!productVariants[product]) {
                        productVariants[product] = [];
                    }
                    
                    const variantData = productionData.variants.find(v => v.variant === variantKey);
                    
                    if (variantData) {
                        productVariants[product].push({
                            variantKey,
                            variantData,
                            supervisorVariant: supervisor.variants[variantKey]
                        });
                    }
                });
                
                Object.keys(productVariants).forEach(product => {
                    const group = `${supervisor.name}:${product}`;
                    
                    const sortedVariants = productVariants[product].sort((a, b) => {
                        const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                        const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                        
                        const [hoursA, minutesA] = timeA.split(':').map(Number);
                        const [hoursB, minutesB] = timeB.split(':').map(Number);
                        
                        const totalMinutesA = hoursA * 60 + minutesA;
                        const totalMinutesB = hoursB * 60 + minutesB;
                        
                        return totalMinutesA - totalMinutesB;
                    });
                    
                    productSupervisorGroups[group] = {
                        supervisor: supervisor.name,
                        product,
                        variants: sortedVariants.map(v => v.variantData),
                        supervisorData: supervisor
                    };
                });
            });
        }

        function extractProductFromVariant(variantId) {
            if (variantId.includes('-')) {
                const parts = variantId.split('-');
                
                if (parts.length > 2) {
                    return parts.slice(0, -1).join('-');
                } else if (parts.length === 2) {
                    return parts[0];
                }
            }

            const parts = variantId.split(' ');
            
            if (parts.length === 1) return variantId;
            if (parts.length === 2) return parts[0];
            
            const match = variantId.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            return parts[0];
        }

        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.supervisors?.length > 0) {
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                const uniqueProducts = new Set();
                
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.product);
                });
                
                uniqueProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'variant' && productionData.variants?.length > 0) {
                const uniqueVariants = new Set(productionData.variants.map(v => v.variant));
                uniqueVariants.forEach(variantName => {
                    const option = document.createElement('option');
                    option.value = variantName;
                    option.textContent = variantName;
                    filterValueSelect.appendChild(option);
                });
            }
            
            filterValueSelect.value = Array.from(filterValueSelect.options).some(opt => opt.value === currentValue) 
                ? currentValue 
                : 'all';
                
            selectedFilterValue = filterValueSelect.value;
        }

        function showLoadingOrError(message) {
            const supervisorName = document.getElementById('supervisor-name');
            const productName = document.getElementById('product-name');
            const variantSequence = document.getElementById('variant-sequence');
            
            if (supervisorName) supervisorName.textContent = 'SUPERVISOR: Loading...';
            if (productName) productName.textContent = 'PRODUCT: Loading...';
            if (variantSequence) variantSequence.innerHTML = '<div class="loading">Loading variants...</div>';
            
            const elementIds = [
                'current-units', 'target-units', 'progress-percentage', 
                'current-boxes', 'target-boxes', 'actual-cycle-time', 'target-cycle-time'
            ];
            
            elementIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = '0';
            });
            
            const progressElement = document.getElementById('progress-percentage');
            if (progressElement) progressElement.textContent = '0%';
            
            const cumulativeChart = document.getElementById('cumulative-chart');
            const hourlyChart = document.getElementById('hourly-chart');
            
            if (cumulativeChart) {
                cumulativeChart.innerHTML = 
                    `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
            }
            
            if (hourlyChart) {
                hourlyChart.innerHTML = 
                    `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
            }
            
            const batchInfoTable = document.getElementById('batch-info-tbody');
            if (batchInfoTable) {
                batchInfoTable.innerHTML = `<tr><td colspan="5">${message}</td></tr>`;
            }
        }

        function updateDateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            
            updateCurrentHourInfo();
            
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }

        function updateCurrentHourInfo() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            const nextHourMinute = 30;
            const nextHour = currentMinute < nextHourMinute ? currentHour : currentHour + 1;
            
            let minutesRemaining;
            if (currentMinute < nextHourMinute) {
                minutesRemaining = nextHourMinute - currentMinute;
            } else {
                minutesRemaining = (60 - currentMinute) + nextHourMinute;
            }
            
            const hourStr = currentMinute < 30 ? 
                `${currentHour.toString().padStart(2, '0')}:30` : 
                `${(currentHour + 1).toString().padStart(2, '0')}:30`;
            
            document.getElementById('current-hour-info').textContent = 
                `CURRENT HOUR: ${hourStr} (${minutesRemaining} MIN LEFT)`;
        }

        function updateDashboard() {
            let filteredGroups = {};
            
            if (selectedFilterValue === 'all') {
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'supervisor') {
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].supervisor === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'product') {
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].product === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'variant') {
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    if (group.variants.some(v => v.variant === selectedFilterValue) &&
                        selectedSupervisors.includes(group.supervisor)) {
                        filteredGroups[key] = group;
                    }
                });
            }
            
            if (Object.keys(filteredGroups).length === 0) {
                showLoadingOrError('No data available for this filter or selected supervisors.');
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
                return;
            }
            
            const groupKeys = Object.keys(filteredGroups);
            if (groupKeys.length > 1) {
                if (cycleInterval) clearInterval(cycleInterval);
                
                cycleIndex = 0;
                cycleInterval = setInterval(() => {
                    cycleIndex = (cycleIndex + 1) % groupKeys.length;
                    displayGroup(filteredGroups[groupKeys[cycleIndex]]);
                }, CYCLE_INTERVAL);
            } else {
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
            }
            
            displayGroup(filteredGroups[groupKeys[0]]);
            
            updateBatchInfoTable(filteredGroups);
        }

        function updateBatchInfoTable(filteredGroups) {
            const batchInfoTableBody = document.getElementById('batch-info-tbody');
            const batchInfoTableHead = document.getElementById('batch-info-thead');
            
            if (!batchInfoTableBody || !batchInfoTableHead) return;
            
            batchInfoTableBody.innerHTML = '';
            batchInfoTableHead.innerHTML = '';
            
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `
                <th>Product</th>
                <th>Variant</th>
                <th>Batch</th>
                <th>Units</th>
                <th>Boxes</th>
            `;
            batchInfoTableHead.appendChild(headerRow);
            
            if (!productionData.originalData || !productionData.originalData.production) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
                return;
            }
            
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            if (!selectedSupervisors || selectedSupervisors.length === 0) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No supervisors selected</td></tr>';
                return;
            }
            
            const processedBatches = [];
            
            selectedSupervisors.forEach(supervisorName => {
                const supervisorOriginal = productionData.originalData.summary.supervisors.find(
                    s => s.name === supervisorName
                );
                
                if (!supervisorOriginal) return;
                
                const supervisorVariantIds = supervisorOriginal.variants || [];
                
                supervisorVariantIds.forEach(variantId => {
                    const productionItem = productionData.originalData.production.find(p => p.id === variantId);
                    
                    if (!productionItem || !productionItem.batches || productionItem.batches.length === 0) return;
                    
                    const supervisorData = productionItem.supervisors.find(s => s.name === supervisorName);
                    
                    if (!supervisorData) return;
                    
                    const productName = productionItem.product?.name || '';
                    const variantName = productionItem.variant?.name || '';
                    
                    let isCurrentVariant = false;
                    const startTimeStr = supervisorData.startTime;
                    const endTimeStr = supervisorData.endTime;
                    
                    if (startTimeStr && endTimeStr) {
                        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                        
                        const startTimeMinutes = startHour * 60 + startMinute;
                        const endTimeMinutes = endHour * 60 + endMinute;
                        
                        isCurrentVariant = (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
                    }
                    
                    const totalProduction = productionItem.actual.total || 0;
                    const supervisorProduction = supervisorData.production || 0;
                    const supervisorRatio = totalProduction > 0 ? supervisorProduction / totalProduction : 0;
                    
                    productionItem.batches.forEach(batch => {
                        let batchBelongsToSupervisor = false;
                        let supervisorUnits = 0;
                        let supervisorBoxes = 0;
                        
                        const supervisorIndex = productionItem.supervisors.findIndex(s => s.name === supervisorName);
                        
                        if (supervisorIndex === 0 && productionItem.supervisors.length === 1) {
                            batchBelongsToSupervisor = true;
                            supervisorUnits = batch.quantity;
                            supervisorBoxes = batch.boxes;
                        } else if (supervisorIndex !== -1) {
                            if (supervisorIndex < productionItem.batches.length) {
                                if (productionItem.batches[supervisorIndex].id === batch.id) {
                                    batchBelongsToSupervisor = true;
                                    supervisorUnits = batch.quantity;
                                    supervisorBoxes = batch.boxes;
                                }
                            } else {
                                supervisorUnits = Math.round(batch.quantity * supervisorRatio);
                                supervisorBoxes = Math.round(batch.boxes * supervisorRatio);
                                batchBelongsToSupervisor = supervisorUnits > 0 || supervisorBoxes > 0;
                            }
                        }
                        
                        if (batchBelongsToSupervisor) {
                            processedBatches.push({
                                supervisor: supervisorName,
                                product: productName,
                                variant: variantName,
                                batchId: batch.id,
                                units: supervisorUnits,
                                boxes: supervisorBoxes,
                                isCurrent: isCurrentVariant,
                                isAssembly: productName.toLowerCase().includes('assembly'),
                                supervisorOrder: selectedSupervisors.indexOf(supervisorName),
                                startTimeMinutes: startTimeStr ? 
                                    (parseInt(startTimeStr.split(':')[0]) * 60 + parseInt(startTimeStr.split(':')[1])) : 0
                            });
                        }
                    });
                });
            });
            
            if (processedBatches.length === 0) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available for selected supervisors</td></tr>';
                return;
            }
            
            processedBatches.sort((a, b) => {
                if (a.supervisorOrder !== b.supervisorOrder) {
                    return a.supervisorOrder - b.supervisorOrder;
                }
                
                if (a.startTimeMinutes !== b.startTimeMinutes) {
                    return a.startTimeMinutes - b.startTimeMinutes;
                }
                
                if (a.product !== b.product) {
                    return a.product.localeCompare(b.product);
                }
                
                if (a.variant !== b.variant) {
                    return a.variant.localeCompare(b.variant);
                }
                
                return a.batchId - b.batchId;
            });
            
            let currentSupervisor = null;
            let currentProduct = null;
            
            processedBatches.forEach(batch => {
                if (batch.supervisor !== currentSupervisor) {
                    currentSupervisor = batch.supervisor;
                    currentProduct = null;
                    
                    const supervisorRow = document.createElement('tr');
                    supervisorRow.className = 'supervisor-header';
                    supervisorRow.style.backgroundColor = getSupervisorColor(batch.supervisor);
                    
                    const supervisorCell = document.createElement('td');
                    supervisorCell.colSpan = 5;
                    supervisorCell.textContent = `SUPERVISOR: ${batch.supervisor}`;
                    
                    supervisorRow.appendChild(supervisorCell);
                    batchInfoTableBody.appendChild(supervisorRow);
                }
                
                if (batch.product !== currentProduct) {
                    currentProduct = batch.product;
                    
                    const productRow = document.createElement('tr');
                    productRow.className = 'product-header';
                    
                    const productCell = document.createElement('td');
                    productCell.colSpan = 5;
                    productCell.textContent = batch.product;
                    
                    productRow.appendChild(productCell);
                    batchInfoTableBody.appendChild(productRow);
                }
                
                const row = document.createElement('tr');
                if (batch.isCurrent) {
                    row.className = 'current';
                }
                
                const productCell = document.createElement('td');
                productCell.style.opacity = '0.5';
                productCell.textContent = batch.product;
                row.appendChild(productCell);
                
                const variantCell = document.createElement('td');
                variantCell.textContent = batch.variant;
                row.appendChild(variantCell);
                
                const batchCell = document.createElement('td');
                batchCell.className = 'batch-number';
                batchCell.textContent = batch.batchId;
                row.appendChild(batchCell);
                
                const unitsCell = document.createElement('td');
                unitsCell.textContent = batch.units;
                row.appendChild(unitsCell);
                
                const containerCell = document.createElement('td');
                if (batch.isAssembly) {
                    containerCell.textContent = `${batch.boxes} Bags`;
                } else {
                    containerCell.textContent = batch.boxes;
                }
                row.appendChild(containerCell);
                
                batchInfoTableBody.appendChild(row);
            });
        }
        
        function displayGroup(group) {
            currentProduct = group.product;
            currentSupervisor = group.supervisor;
            currentProductVariants = group.variants;
            
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            const sortedVariants = [...currentProductVariants].sort((a, b) => {
                const supervisorA = group.supervisorData.variants[a.variant];
                const supervisorB = group.supervisorData.variants[b.variant];
                
                const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                
                const [hoursA, minutesA] = timeA.split(':').map(Number);
                const [hoursB, minutesB] = timeB.split(':').map(Number);
                
                return (hoursA * 60 + minutesA) - (hoursB * 60 + minutesB);
            });
            
            let currentVariantIndex = -1;
            
            for (let i = 0; i < sortedVariants.length; i++) {
                const variant = sortedVariants[i];
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) continue;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                    currentVariantIndex = i;
                    break;
                }
            }
            
            if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                currentVariantIndex = sortedVariants.length - 1;
            }
            
            currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
            
            applySupervisorStyling(currentSupervisor);
            
            if (isTargetBoardView) {
                renderTargetBoard(group);
            } else {
                updateSupervisorInfo(group);
                updateMetrics(group);
                
                setTimeout(() => {
                    renderCumulativeChart(group);
                    renderHourlyChart(group);
                }, 50);
            }
        }
        
        function renderTargetBoard(group) {
            const supervisorBox = document.getElementById('board-supervisor-box');
            const supervisorNameEl = document.getElementById('board-supervisor-name');
            const productNameEl = document.getElementById('board-product-name');
            const dailyTargetEl = document.getElementById('board-daily-target');
            
            supervisorBox.style.background = `linear-gradient(135deg, ${getSupervisorColor(group.supervisor)} 0%, ${getSupervisorColor(group.supervisor)} 100%)`;
            supervisorNameEl.textContent = group.supervisor;
            productNameEl.textContent = group.product;
            
            let totalTarget = 0;
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                }
            });
            
            dailyTargetEl.textContent = totalTarget;
            
            const tbody = document.getElementById('target-board-tbody');
            tbody.innerHTML = '';
            
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentTimeMinutes = currentHour * 60 + currentMinute;
            
            const currentPeriodHour = currentMinute < 30 ? currentHour : currentHour + 1;
            const currentPeriodStr = `${currentPeriodHour.toString().padStart(2, '0')}:30`;
            
            const cumulativeData = {};
            
            const standardHourMarks = [];
            for (let hour = 7; hour <= 16; hour++) {
                standardHourMarks.push(`${hour.toString().padStart(2, '0')}:30`);
            }
            
            standardHourMarks.forEach(hour => {
                cumulativeData[hour] = { target: 0, actual: 0 };
            });
            
            function parseTimeToMinutes(timeStr) {
                const [hour, minute] = timeStr.split(':').map(Number);
                return hour * 60 + minute;
            }
            
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (!supervisorVariant) return;
                
                const variantStartMin = parseTimeToMinutes(supervisorVariant.variantStartTime || variant["Start Time"]);
                const variantEndMin = parseTimeToMinutes(supervisorVariant.variantEndTime || variant["End Time"]);
                
                if (variant.hourlyProduction && variant.hourlyTargets) {
                    standardHourMarks.forEach(hourMark => {
                        const hourMinutes = parseTimeToMinutes(hourMark);
                        
                        if (hourMinutes >= variantStartMin && hourMinutes <= variantEndMin) {
                            const prodData = variant.hourlyProduction.find(p => p.hour === hourMark);
                            const targetData = variant.hourlyTargets.find(t => t.hour === hourMark);
                            
                            if (prodData) {
                                cumulativeData[hourMark].actual += (prodData.production || 0);
                            }
                            if (targetData) {
                                cumulativeData[hourMark].target += (targetData.target || 0);
                            }
                        }
                    });
                }
            });
            
            let runningTarget = 0;
            let runningActual = 0;
            
            standardHourMarks.forEach(hourMark => {
                runningTarget += cumulativeData[hourMark].target;
                runningActual += cumulativeData[hourMark].actual;
                
                cumulativeData[hourMark].cumTarget = runningTarget;
                cumulativeData[hourMark].cumActual = runningActual;
            });
            
            standardHourMarks.forEach(hourMark => {
                const data = cumulativeData[hourMark];
                const hourMinutes = parseTimeToMinutes(hourMark);
                
                const row = document.createElement('tr');
                
                if (hourMark === currentPeriodStr) {
                    row.classList.add('current-hour');
                }
                
                const timeCell = document.createElement('td');
                timeCell.className = 'time-cell';
                timeCell.textContent = hourMark;
                row.appendChild(timeCell);
                
                const targetCell = document.createElement('td');
                targetCell.className = 'target-cell';
                targetCell.textContent = data.cumTarget;
                row.appendChild(targetCell);
                
                const actualCell = document.createElement('td');
                actualCell.className = 'actual-cell';
                actualCell.textContent = data.cumActual;
                
                if (hourMinutes > currentTimeMinutes) {
                    actualCell.classList.add('pending');
                } else if (data.cumActual >= data.cumTarget) {
                    actualCell.classList.add('met');
                } else {
                    actualCell.classList.add('not-met');
                }
                
                row.appendChild(actualCell);
                tbody.appendChild(row);
            });
            
            const hasOvertime = group.variants.some(v => {
                const supervisorVariant = group.supervisorData.variants[v.variant];
                if (!supervisorVariant) return false;
                const endTime = supervisorVariant.variantEndTime || v["End Time"];
                return endTime && parseTimeToMinutes(endTime) > parseTimeToMinutes("16:30");
            });
            
            if (hasOvertime) {
                const otRow = document.createElement('tr');
                
                const otTimeCell = document.createElement('td');
                otTimeCell.className = 'time-cell';
                otTimeCell.textContent = 'Overtime';
                otRow.appendChild(otTimeCell);
                
                const otTargetCell = document.createElement('td');
                otTargetCell.className = 'target-cell';
                otTargetCell.textContent = totalTarget;
                otRow.appendChild(otTargetCell);
                
                const otActualCell = document.createElement('td');
                otActualCell.className = 'actual-cell';
                
                let totalProduction = 0;
                group.variants.forEach(variant => {
                    const supervisorVariant = group.supervisorData.variants[variant.variant];
                    if (supervisorVariant) {
                        totalProduction += (supervisorVariant.currentTotal || 0);
                    }
                });
                
                otActualCell.textContent = totalProduction;
                
                if (totalProduction >= totalTarget) {
                    otActualCell.classList.add('met');
                } else {
                    otActualCell.classList.add('not-met');
                }
                
                otRow.appendChild(otActualCell);
                tbody.appendChild(otRow);
            }
        }

        function applySupervisorStyling(supervisorName) {
            const supervisorColorBanner = document.querySelector('.supervisor-color-banner');
            supervisorPanel = document.querySelector('.supervisor-panel');
            
            if (supervisorName) {
                const color = getSupervisorColor(supervisorName);
                supervisorColorBanner.style.backgroundColor = color;
                supervisorPanel.style.backgroundColor = color;
            }
        }

        function updateSupervisorInfo(group) {
            document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${group.supervisor}`;
            document.getElementById('product-name').textContent = `PRODUCT: ${group.product}`;
            
            const sequenceContainer = document.getElementById('variant-sequence');
            sequenceContainer.innerHTML = '';
            
            if (group.variants.length === 0) {
                sequenceContainer.innerHTML = '<div>No variants available</div>';
                return;
            }
            
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            group.variants.forEach((variant, index) => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                let status = '';
                if (currentTimeMinutes < startTimeMinutes) {
                    status = 'upcoming';
                } else if (currentTimeMinutes > endTimeMinutes) {
                    status = 'completed';
                } else {
                    status = 'current';
                }
                
                let displayName = variant.variant;
                
                if (variant.variant.includes('-')) {
                    displayName = variant.variant.split('-').pop();
                } else if (variant.variant.startsWith(group.product + ' ')) {
                    displayName = variant.variant.substring(group.product.length + 1);
                }
                
                const variantElement = document.createElement('div');
                variantElement.className = `variant-item ${status}`;
                variantElement.textContent = displayName;
                
                sequenceContainer.appendChild(variantElement);
                
                if (index < group.variants.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-right';
                    arrow.textContent = '';
                    sequenceContainer.appendChild(arrow);
                }
            });
        }

        function updateMetrics(group) {
            let totalTarget = 0;
            let totalProduction = 0;
            let totalBoxTarget = 0;
            let totalBoxProduction = 0;
            let weightedCycleTime = 0;
            let totalCycleTimeWeight = 0;
            
            const currentSupervisor = group.supervisor;
            
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    const prodItem = productionData.originalData.production.find(p => p.id === variant.variant);
                    const supervisorData = prodItem?.supervisors.find(s => s.name === currentSupervisor);
                    
                    if (supervisorData) {
                        totalTarget += (supervisorVariant.dailyTarget || 0);
                        totalProduction += (supervisorVariant.currentTotal || 0);
                        
                        if (prodItem && prodItem.actual.total > 0) {
                            const supervisorRatio = supervisorData.production / prodItem.actual.total;
                            totalBoxProduction += Math.round((variant.currentBoxTotal || 0) * supervisorRatio);
                            totalBoxTarget += Math.round((variant.dailyBoxTarget || 0) * (supervisorVariant.dailyTarget / prodItem.targets.daily));
                        }
                        
                        const cycleTime = variant.cycleTime || 0;
                        const target = supervisorVariant.dailyTarget || 0;
                        
                        if (cycleTime > 0 && target > 0) {
                            weightedCycleTime += cycleTime * target;
                            totalCycleTimeWeight += target;
                        }
                    }
                }
            });
            
            const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
            
            const actualCycleTime = calculateActualCycleTime(group.variants);
            
            document.getElementById('current-units').textContent = totalProduction;
            document.getElementById('target-units').textContent = totalTarget;
            document.getElementById('progress-percentage').textContent = `${progressPercentage}%`;
            
            document.getElementById('current-boxes').textContent = totalBoxProduction;
            document.getElementById('target-boxes').textContent = totalBoxTarget;
            
            document.getElementById('actual-cycle-time').textContent = actualCycleTime === "N/A" ? "N/A" : actualCycleTime;
            document.getElementById('target-cycle-time').textContent = avgCycleTime;
        }

        function calculateActualCycleTime(variants) {
            const variantsWithActualCycleTime = variants.filter(v => v.actualCycleTime !== undefined && v.actualCycleTime !== null);
            
            if (variantsWithActualCycleTime.length > 0) {
                if (variantsWithActualCycleTime.length > 1) {
                    let totalWeight = 0;
                    let weightedSum = 0;
                    
                    variantsWithActualCycleTime.forEach(variant => {
                        const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                        if (supervisor && supervisor.variants[variant.variant]) {
                            const supervisorVariant = supervisor.variants[variant.variant];
                            if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                                totalWeight += supervisorVariant.currentTotal;
                                weightedSum += variant.actualCycleTime * supervisorVariant.currentTotal;
                            }
                        }
                    });
                    
                    if (totalWeight > 0) {
                        return Math.round(weightedSum / totalWeight);
                    } else {
                        const sum = variantsWithActualCycleTime.reduce((acc, v) => acc + v.actualCycleTime, 0);
                        return Math.round(sum / variantsWithActualCycleTime.length);
                    }
                } else {
                    return variantsWithActualCycleTime[0].actualCycleTime;
                }
            }
            
            let totalProduction = 0;
            let totalElapsedWorkingTime = 0;
            
            variants.forEach(variant => {
                const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                if (supervisor && supervisor.variants[variant.variant]) {
                    const supervisorVariant = supervisor.variants[variant.variant];
                    
                    if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                        
                        if (startTimeStr && variant.hourlyProduction) {
                            const hoursWithProduction = variant.hourlyProduction
                                .filter(h => h.production > 0)
                                .sort((a, b) => {
                                    const [hourA, minuteA] = a.hour.split(':').map(Number);
                                    const [hourB, minuteB] = b.hour.split(':').map(Number);
                                    return (hourB * 60 + minuteB) - (hourA * 60 + minuteA);
                                });
                            
                            if (hoursWithProduction.length > 0) {
                                const lastProductionHourData = hoursWithProduction[0];
                                const [lastHours, lastMinutes] = lastProductionHourData.hour.split(':').map(Number);
                                const lastTotalMinutes = lastHours * 60 + lastMinutes;
                                
                                const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                                const startTotalMinutes = startHours * 60 + startMinutes;
                                
                                let elapsedMinutes = lastTotalMinutes - startTotalMinutes;
                                if (elapsedMinutes < 0) {
                                    elapsedMinutes += 24 * 60;
                                }
                                
                                const now = new Date();
                                const lastProductionTime = new Date(now);
                                lastProductionTime.setHours(lastHours);
                                lastProductionTime.setMinutes(lastMinutes);
                                
                                const elapsedBreakMinutes = calculateElapsedBreakMinutes(variant, startTimeStr, lastProductionTime);
                                
                                const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                                
                                totalProduction += supervisorVariant.currentTotal;
                                totalElapsedWorkingTime += workingMinutes * 60;
                            }
                        }
                    }
                }
            });
            
            if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
            
            return Math.round(totalElapsedWorkingTime / totalProduction);
        }
        
        function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
            let totalElapsedBreakMinutes = 0;
            const currentTime = now.getHours() * 60 + now.getMinutes();
            
            const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
                if (!breakStartStr || !breakEndStr) return 0;
                if (breakStartStr === "-" || breakEndStr === "-") return 0;
                
                const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
                const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
                
                const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
                const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
                
                if (currentTime < breakStartMinutes) return 0;
                
                if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
                
                return breakEndMinutes - breakStartMinutes;
            };
            
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
            }
            
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
            }
            
            if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
            }
            
            return totalElapsedBreakMinutes;
        }

        function renderCumulativeChart(group) {
            const chartContainer = document.getElementById('cumulative-chart');
            chartContainer.innerHTML = '';
            
            const currentSupervisor = group.supervisor;
            
            const supervisorTotalProduction = parseInt(document.getElementById('current-units').textContent, 10) || 0;
            const supervisorTotalTarget = parseInt(document.getElementById('target-units').textContent, 10) || 0;
            
            const supervisorProductionItems = [];
            
            if (productionData.originalData && productionData.originalData.production) {
                productionData.originalData.production.forEach(prodItem => {
                    const supervisorData = prodItem.supervisors.find(s => s.name === currentSupervisor);
                    if (supervisorData) {
                        supervisorProductionItems.push({
                            prodItem,
                            supervisorData,
                            variantId: prodItem.id,
                            startTime: supervisorData.startTime,
                            endTime: supervisorData.endTime,
                            production: supervisorData.production
                        });
                    }
                });
            }
            
            if (supervisorProductionItems.length === 0) {
                chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for this supervisor</div>';
                return;
            }
            
            supervisorProductionItems.sort((a, b) => {
                const [aHour, aMin] = a.startTime.split(':').map(Number);
                const [bHour, bMin] = b.startTime.split(':').map(Number);
                return (aHour * 60 + aMin) - (bHour * 60 + bMin);
            });
            
            let earliestStart = "23:59";
            let latestEnd = "00:00";
            
            supervisorProductionItems.forEach(item => {
                if (item.startTime < earliestStart) earliestStart = item.startTime;
                if (item.endTime > latestEnd) latestEnd = item.endTime;
            });
            
            const [startHour, startMin] = earliestStart.split(':').map(Number);
            const [endHour, endMin] = latestEnd.split(':').map(Number);
            const startTimeMinutes = startHour * 60 + startMin;
            const endTimeMinutes = endHour * 60 + endMin;
            
            const standardHourMarks = [];
            for (let hour = 7; hour <= 16; hour++) {
                standardHourMarks.push(`${hour.toString().padStart(2, '0')}:30`);
            }
            
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentTimeMinutes = currentHour * 60 + currentMinute;
            
            function parseTimeToMinutes(timeStr) {
                const [hour, minute] = timeStr.split(':').map(Number);
                return hour * 60 + minute;
            }
            
            const hourlyData = {};
            
            standardHourMarks.forEach(hour => {
                hourlyData[hour] = {
                    hour,
                    production: 0,
                    minutes: parseTimeToMinutes(hour)
                };
            });
            
            supervisorProductionItems.forEach(item => {
                if (!item.prodItem.timeline) return;
                
                const variantStartMin = parseTimeToMinutes(item.startTime);
                const variantEndMin = parseTimeToMinutes(item.endTime);
                
                const totalVariantProduction = item.prodItem.actual.total || 0;
                const supervisorVariantProduction = item.supervisorData.production || 0;
                const supervisorRatio = totalVariantProduction > 0 ? supervisorVariantProduction / totalVariantProduction : 0;
                
                item.prodItem.timeline.forEach(timeSlot => {
                    if (!timeSlot.hour || !timeSlot.actual) return;
                    
                    const slotMinutes = parseTimeToMinutes(timeSlot.hour);
                    
                    if (slotMinutes >= variantStartMin && slotMinutes <= variantEndMin) {
                        let productionPortion = 0;
                        
                        if (item.prodItem.supervisors.length === 1) {
                            productionPortion = timeSlot.actual;
                        } else {
                            productionPortion = Math.round(timeSlot.actual * supervisorRatio);
                        }
                        
                        if (hourlyData[timeSlot.hour]) {
                            hourlyData[timeSlot.hour].production += productionPortion;
                        }
                    }
                });
            });
            
            const hourlyDataArray = Object.values(hourlyData)
                .filter(item => item.minutes >= startTimeMinutes && item.minutes <= endTimeMinutes)
                .sort((a, b) => a.minutes - b.minutes);
            
            let runningProduction = 0;
            const cumulativeData = [];
            
            cumulativeData.push({
                hour: earliestStart,
                minutes: startTimeMinutes,
                production: 0,
                target: 0
            });
            
            hourlyDataArray.forEach(hourData => {
                runningProduction += hourData.production;
                
                cumulativeData.push({
                    hour: hourData.hour,
                    minutes: hourData.minutes,
                    production: runningProduction,
                    target: 0
                });
            });
            
            if (cumulativeData.length > 1 && runningProduction !== supervisorTotalProduction) {
                const difference = supervisorTotalProduction - runningProduction;
                
                cumulativeData[cumulativeData.length - 1].production = supervisorTotalProduction;
                
                if (Math.abs(difference) > 5 && hourlyDataArray.length > 0) {
                    console.log(`Adjusting production for ${currentSupervisor}: Timeline total ${runningProduction}, Metrics total ${supervisorTotalProduction}, Difference ${difference}`);
                    
                    const adjustment = difference / hourlyDataArray.length;
                    runningProduction = 0;
                    
                    for (let i = 1; i < cumulativeData.length; i++) {
                        const hourIndex = i - 1;
                        hourlyDataArray[hourIndex].production += adjustment;
                        runningProduction += hourlyDataArray[hourIndex].production;
                        cumulativeData[i].production = Math.round(runningProduction);
                    }
                    
                    cumulativeData[cumulativeData.length - 1].production = supervisorTotalProduction;
                }
            }
            
            const workDuration = endTimeMinutes - startTimeMinutes;
            
            cumulativeData.forEach(dataPoint => {
                const elapsedProportion = (dataPoint.minutes - startTimeMinutes) / workDuration;
                dataPoint.target = Math.round(supervisorTotalTarget * elapsedProportion);
            });
            
            const currentTimePlusBuffer = currentTimeMinutes + 60;
            let filteredData = cumulativeData.filter(item => item.minutes <= currentTimePlusBuffer);
            
            const currentTimePoint = filteredData.find(item => item.minutes === currentTimeMinutes);
            if (!currentTimePoint && filteredData.length > 0) {
                const prevPoints = filteredData.filter(item => item.minutes < currentTimeMinutes);
                const nextPoints = filteredData.filter(item => item.minutes > currentTimeMinutes);
                
                let currentProduction = supervisorTotalProduction;
                let currentTarget = Math.round(supervisorTotalTarget * ((currentTimeMinutes - startTimeMinutes) / workDuration));
                
                if (prevPoints.length > 0 && nextPoints.length > 0) {
                    const prevPoint = prevPoints[prevPoints.length - 1];
                    const nextPoint = nextPoints[0];
                    
                    const ratio = (currentTimeMinutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                    currentProduction = Math.round(prevPoint.production + (nextPoint.production - prevPoint.production) * ratio);
                } else if (prevPoints.length > 0) {
                    currentProduction = prevPoints[prevPoints.length - 1].production;
                }
                
                const currentHourStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
                filteredData.push({
                    hour: currentHourStr,
                    minutes: currentTimeMinutes,
                    production: currentProduction,
                    target: currentTarget
                });
                
                filteredData.sort((a, b) => a.minutes - b.minutes);
            }
            
            if (filteredData.length > 0) {
                filteredData[filteredData.length - 1].production = supervisorTotalProduction;
            }
            
            if (filteredData.length === 0) {
                chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current time period</div>';
                return;
            }
            
            const chartArea = chartContainer.closest('.chart-area');
            const svgWidth = chartArea.clientWidth;
            const svgHeight = chartArea.clientHeight;
            
            if (svgWidth <= 0 || svgHeight <= 0) {
                setTimeout(() => renderCumulativeChart(group), 100);
                return;
            }
            
            const padding = {
                top: Math.max(10, Math.floor(svgHeight * 0.05)),
                right: Math.max(10, Math.floor(svgWidth * 0.05)),
                bottom: Math.max(50, Math.floor(svgHeight * 0.18)),
                left: Math.max(40, Math.floor(svgWidth * 0.12))
            };
            
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            const maxValue = Math.max(
                ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
            ) * 1.1;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            chartContainer.appendChild(svg);
            
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 35);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            gridGroup.appendChild(yAxisTitle);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding.left);
            yAxis.setAttribute('y1', padding.top);
            yAxis.setAttribute('x2', padding.left);
            yAxis.setAttribute('y2', svgHeight - padding.bottom);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(yAxis);
            
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding.left);
            xAxis.setAttribute('y1', svgHeight - padding.bottom);
            xAxis.setAttribute('x2', svgWidth - padding.right);
            xAxis.setAttribute('y2', svgHeight - padding.bottom);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxis);
            
            svg.appendChild(gridGroup);
            
            function timeToXPosition(minutes) {
                const normalizedTime = (minutes - startTimeMinutes) / (endTimeMinutes - startTimeMinutes);
                return padding.left + (chartWidth * normalizedTime);
            }
            
            const visibleHourMarks = standardHourMarks.filter(hourMark => {
                const minutes = parseTimeToMinutes(hourMark);
                return minutes >= startTimeMinutes && minutes <= endTimeMinutes;
            });
            
            const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            visibleHourMarks.forEach(hourMark => {
                const minutes = parseTimeToMinutes(hourMark);
                const x = timeToXPosition(minutes);
                const y = svgHeight - padding.bottom + 20;
                
                const tickLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tickLine.setAttribute('x1', x);
                tickLine.setAttribute('y1', svgHeight - padding.bottom);
                tickLine.setAttribute('x2', x);
                tickLine.setAttribute('y2', svgHeight - padding.bottom + 5);
                tickLine.setAttribute('stroke', '#666');
                tickLine.setAttribute('stroke-width', '1.5');
                xLabelsGroup.appendChild(tickLine);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('fill', '#666');
                text.textContent = hourMark;
                xLabelsGroup.appendChild(text);
                
                if (minutes < currentTimeMinutes) {
                    const hourProduction = hourlyData[hourMark] ? hourlyData[hourMark].production : 0;
                    const dataPoint = filteredData.find(dp => dp.hour === hourMark);
                    let hourTarget = 0;
                    
                    if (dataPoint) {
                        hourTarget = dataPoint.target;
                    } else {
                        const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                        const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                        
                        if (prevPoints.length > 0 && nextPoints.length > 0) {
                            const prevPoint = prevPoints[prevPoints.length - 1];
                            const nextPoint = nextPoints[0];
                            
                            const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                            hourTarget = Math.round(prevPoint.target + (nextPoint.target - prevPoint.target) * ratio);
                        } else if (prevPoints.length > 0) {
                            hourTarget = prevPoints[prevPoints.length - 1].target;
                        }
                    }
                    
                    let statusSymbol = '';
                    let fillColor = '#94a3b8';
                    
                    if (hourProduction >= hourTarget) {
                        statusSymbol = '';
                        fillColor = '#0d9488';
                    } else {
                        statusSymbol = '';
                        fillColor = '#e11d48';
                    }
                    
                    if (parseTimeToMinutes(hourMark) === (Math.floor(currentTimeMinutes / 60) * 60 + 30)) {
                        statusSymbol = '';
                        fillColor = '#ca8a04';
                    }
                    
                    const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    statusText.setAttribute('x', x);
                    statusText.setAttribute('y', y + 20);
                    statusText.setAttribute('text-anchor', 'middle');
                    statusText.setAttribute('font-size', isFullscreen ? '18' : '16');
                    statusText.setAttribute('font-weight', 'bold');
                    statusText.setAttribute('fill', fillColor);
                    statusText.textContent = statusSymbol;
                    xLabelsGroup.appendChild(statusText);
                }
            });
            svg.appendChild(xLabelsGroup);
            
            const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            let productionPathD = '';
            const productionPoints = [];
            
            filteredData.forEach((dataPoint, index) => {
                const x = timeToXPosition(dataPoint.minutes);
                
                const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
                
                if (index === 0) {
                    productionPathD = `M ${x} ${y}`;
                } else {
                    productionPathD += ` L ${x} ${y}`;
                }
                
                productionPoints.push({
                    x, y,
                    production: dataPoint.production,
                    hour: dataPoint.hour
                });
            });
            
            const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            productionPath.setAttribute('d', productionPathD);
            productionPath.setAttribute('stroke', 'var(--production-color)');
            productionPath.setAttribute('stroke-width', '3');
            productionPath.setAttribute('fill', 'none');
            productionLineGroup.appendChild(productionPath);
            
            visibleHourMarks.forEach(hourMark => {
                const minutes = parseTimeToMinutes(hourMark);
                
                if (minutes > currentTimeMinutes) return;
                
                let productionValue = 0;
                let x = timeToXPosition(minutes);
                let y = padding.top + chartHeight;
                
                const exactMatch = filteredData.find(dp => dp.hour === hourMark);
                if (exactMatch) {
                    productionValue = exactMatch.production;
                    y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                } else {
                    const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                    const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                    
                    if (prevPoints.length > 0 && nextPoints.length > 0) {
                        const prevPoint = prevPoints[prevPoints.length - 1];
                        const nextPoint = nextPoints[0];
                        
                        const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                        productionValue = Math.round(prevPoint.production + (nextPoint.production - prevPoint.production) * ratio);
                        y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                    } else if (prevPoints.length > 0) {
                        productionValue = prevPoints[prevPoints.length - 1].production;
                        y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                    }
                }
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', isFullscreen ? '5' : '4');
                circle.setAttribute('fill', 'var(--production-color)');
                productionLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'var(--production-color)');
                text.textContent = productionValue;
                productionLineGroup.appendChild(text);
            });
            
            if (productionPoints.length > 0) {
                const lastPoint = productionPoints[productionPoints.length - 1];
                
                const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                emphasizedCircle.setAttribute('cx', lastPoint.x);
                emphasizedCircle.setAttribute('cy', lastPoint.y);
                emphasizedCircle.setAttribute('r', isFullscreen ? '8' : '7');
                emphasizedCircle.setAttribute('fill', 'var(--production-color)');
                emphasizedCircle.setAttribute('stroke', '#ffffff');
                emphasizedCircle.setAttribute('stroke-width', '2');
                productionLineGroup.appendChild(emphasizedCircle);
                
                const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                emphasizedText.setAttribute('x', lastPoint.x);
                emphasizedText.setAttribute('y', lastPoint.y - 12);
                emphasizedText.setAttribute('text-anchor', 'middle');
                emphasizedText.setAttribute('font-size', isFullscreen ? '18' : '16');
                emphasizedText.setAttribute('font-weight', 'bold');
                emphasizedText.setAttribute('fill', 'var(--production-color)');
                emphasizedText.textContent = lastPoint.production;
                productionLineGroup.appendChild(emphasizedText);
            }
            
            svg.appendChild(productionLineGroup);
            
            const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            let targetPathD = '';
            const targetPoints = [];
            
            filteredData.forEach((dataPoint, index) => {
                const x = timeToXPosition(dataPoint.minutes);
                
                const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
                
                if (index === 0) {
                    targetPathD = `M ${x} ${y}`;
                } else {
                    targetPathD += ` L ${x} ${y}`;
                }
                
                targetPoints.push({
                    x, y,
                    target: dataPoint.target,
                    hour: dataPoint.hour
                });
            });
            
            const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            targetPath.setAttribute('d', targetPathD);
            targetPath.setAttribute('stroke', 'var(--target-color)');
            targetPath.setAttribute('stroke-width', '3');
            targetPath.setAttribute('fill', 'none');
            targetLineGroup.appendChild(targetPath);
            
            visibleHourMarks.forEach(hourMark => {
                const minutes = parseTimeToMinutes(hourMark);
                
                if (minutes > currentTimeMinutes + 60) return;
                
                let targetValue = 0;
                let x = timeToXPosition(minutes);
                let y = padding.top + chartHeight;
                
                const exactMatch = filteredData.find(dp => dp.hour === hourMark);
                if (exactMatch) {
                    targetValue = exactMatch.target;
                    y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                } else {
                    const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                    const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                    
                    if (prevPoints.length > 0 && nextPoints.length > 0) {
                        const prevPoint = prevPoints[prevPoints.length - 1];
                        const nextPoint = nextPoints[0];
                        
                        const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                        targetValue = Math.round(prevPoint.target + (nextPoint.target - prevPoint.target) * ratio);
                        y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                    } else if (prevPoints.length > 0) {
                        targetValue = prevPoints[prevPoints.length - 1].target;
                        y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                    }
                }
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', isFullscreen ? '5' : '4');
                circle.setAttribute('fill', 'var(--target-color)');
                targetLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'var(--target-color)');
                text.textContent = targetValue;
                targetLineGroup.appendChild(text);
            });
            
            if (targetPoints.length > 0) {
                const lastPoint = targetPoints[targetPoints.length - 1];
                
                const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                emphasizedCircle.setAttribute('cx', lastPoint.x);
                emphasizedCircle.setAttribute('cy', lastPoint.y);
                emphasizedCircle.setAttribute('r', isFullscreen ? '7' : '6');
                emphasizedCircle.setAttribute('fill', 'var(--target-color)');
                emphasizedCircle.setAttribute('stroke', '#ffffff');
                emphasizedCircle.setAttribute('stroke-width', '2');
                targetLineGroup.appendChild(emphasizedCircle);
                
                const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                emphasizedText.setAttribute('x', lastPoint.x);
                emphasizedText.setAttribute('y', lastPoint.y - 10);
                emphasizedText.setAttribute('text-anchor', 'middle');
                emphasizedText.setAttribute('font-size', isFullscreen ? '16' : '14');
                emphasizedText.setAttribute('font-weight', 'bold');
                emphasizedText.setAttribute('fill', 'var(--target-color)');
                emphasizedText.textContent = lastPoint.target;
                targetLineGroup.appendChild(emphasizedText);
            }
            
            svg.appendChild(targetLineGroup);
        }
             
        function renderHourlyChart(group) {
            const chartContainer = document.getElementById('hourly-chart');
            chartContainer.innerHTML = '';
            
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            const currentPeriodHour = currentMinute < 30 ? currentHour : currentHour + 1;
            const currentPeriodMinute = 30;
            const currentPeriodStr = `${currentPeriodHour.toString().padStart(2, '0')}:${currentPeriodMinute.toString().padStart(2, '0')}`;
            
            const hourlyProductionMap = new Map();
            const hourlyTargetMap = new Map();
            
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (variant.hourlyProduction) {
                    variant.hourlyProduction.forEach(item => {
                        if (!item.hour || item.hour !== currentPeriodStr) return;
                        
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            if (!hourlyProductionMap.has(item.hour)) {
                                hourlyProductionMap.set(item.hour, 0);
                            }
                            hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                        }
                    });
                }
                
                if (variant.hourlyTargets) {
                    variant.hourlyTargets.forEach(item => {
                        if (!item.hour || item.hour !== currentPeriodStr) return;
                        
                        const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                        const itemTimeMinutes = itemHour * 60 + itemMinute;
                        
                        if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                            if (!hourlyTargetMap.has(item.hour)) {
                                hourlyTargetMap.set(item.hour, 0);
                            }
                            hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                        }
                    });
                }
            });
            
            const sortedHours = [currentPeriodStr];
            
            if (hourlyProductionMap.size === 0 && hourlyTargetMap.size === 0) {
                chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current hour period</div>';
                return;
            }
            
            const chartArea = chartContainer.closest('.chart-area');
            const svgWidth = chartArea.clientWidth;
            const svgHeight = chartArea.clientHeight;
            
            if (svgWidth <= 0 || svgHeight <= 0) {
                setTimeout(() => renderHourlyChart(group), 100);
                return;
            }
            
            const padding = {
                top: Math.max(10, Math.floor(svgHeight * 0.05)),
                right: Math.max(10, Math.floor(svgWidth * 0.05)),
                bottom: Math.max(50, Math.floor(svgHeight * 0.1)),
                left: Math.max(40, Math.floor(svgWidth * 0.12))
            };
            
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            const maxValue = Math.max(
                hourlyProductionMap.get(currentPeriodStr) || 0,
                hourlyTargetMap.get(currentPeriodStr) || 0
            ) * 1.1 || 100;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            chartContainer.appendChild(svg);
            
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 35);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units per Hour';
            gridGroup.appendChild(yAxisTitle);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding.left);
            yAxis.setAttribute('y1', padding.top);
            yAxis.setAttribute('x2', padding.left);
            yAxis.setAttribute('y2', svgHeight - padding.bottom);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(yAxis);
            
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding.left);
            xAxis.setAttribute('y1', svgHeight - padding.bottom);
            xAxis.setAttribute('x2', svgWidth - padding.right);
            xAxis.setAttribute('y2', svgHeight - padding.bottom);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxis);
            
            svg.appendChild(gridGroup);
            
            const barGroupWidth = chartWidth * 0.3;
            const barWidth = barGroupWidth * 0.42;
            
            const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const x = padding.left + chartWidth / 2;
            const y = svgHeight - padding.bottom + 20;
            
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tick.setAttribute('x1', x);
            tick.setAttribute('y1', svgHeight - padding.bottom);
            tick.setAttribute('x2', x);
            tick.setAttribute('y2', svgHeight - padding.bottom + 5);
            tick.setAttribute('stroke', '#666');
            tick.setAttribute('stroke-width', '1.5');
            xLabelsGroup.appendChild(tick);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', isFullscreen ? '16' : '14');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', '#666');
            text.textContent = currentPeriodStr;
            xLabelsGroup.appendChild(text);
            
            svg.appendChild(xLabelsGroup);
            
            const barsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const barGroupX = padding.left + (chartWidth - barGroupWidth) / 2;
            
            const productionValue = hourlyProductionMap.get(currentPeriodStr) || 0;
            const productionHeight = (productionValue / maxValue) * chartHeight;
            const productionY = svgHeight - padding.bottom - productionHeight;
            
            const productionBarX = barGroupX + (barGroupWidth * 0.08);
            
            const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            productionBar.setAttribute('x', productionBarX);
            productionBar.setAttribute('y', productionY);
            productionBar.setAttribute('width', barWidth);
            productionBar.setAttribute('height', productionHeight);
            productionBar.setAttribute('rx', '2');
            productionBar.setAttribute('ry', '2');
            productionBar.setAttribute('fill', 'var(--production-color)');
            barsGroup.appendChild(productionBar);
            
            const productionLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            productionLabel.setAttribute('x', productionBarX + (barWidth / 2));
            productionLabel.setAttribute('y', productionY - 5);
            productionLabel.setAttribute('text-anchor', 'middle');
            productionLabel.setAttribute('font-size', isFullscreen ? '14' : '12');
            productionLabel.setAttribute('font-weight', 'bold');
            productionLabel.setAttribute('fill', 'var(--production-color)');
            productionLabel.textContent = productionValue;
            barsGroup.appendChild(productionLabel);
            
            const targetValue = hourlyTargetMap.get(currentPeriodStr) || 0;
            const targetHeight = (targetValue / maxValue) * chartHeight;
            const targetY = svgHeight - padding.bottom - targetHeight;
            
            const targetBarX = barGroupX + (barGroupWidth * 0.5);
            
            const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetBar.setAttribute('x', targetBarX);
            targetBar.setAttribute('y', targetY);
            targetBar.setAttribute('width', barWidth);
            targetBar.setAttribute('height', targetHeight);
            targetBar.setAttribute('rx', '2');
            targetBar.setAttribute('ry', '2');
            targetBar.setAttribute('fill', 'var(--target-color)');
            barsGroup.appendChild(targetBar);
            
            const targetLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLabel.setAttribute('x', targetBarX + (barWidth / 2));
            targetLabel.setAttribute('y', targetY - 5);
            targetLabel.setAttribute('text-anchor', 'middle');
            targetLabel.setAttribute('font-size', isFullscreen ? '14' : '12');
            targetLabel.setAttribute('font-weight', 'bold');
            targetLabel.setAttribute('fill', 'var(--target-color)');
            targetLabel.textContent = targetValue;
            barsGroup.appendChild(targetLabel);
            
            svg.appendChild(barsGroup);
            
            const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const prodLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            prodLegendRect.setAttribute('x', padding.left);
            prodLegendRect.setAttribute('y', padding.top - 25);
            prodLegendRect.setAttribute('width', 12);
            prodLegendRect.setAttribute('height', 12);
            prodLegendRect.setAttribute('fill', 'var(--production-color)');
            legendGroup.appendChild(prodLegendRect);
            
            const prodLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            prodLegendText.setAttribute('x', padding.left + 18);
            prodLegendText.setAttribute('y', padding.top - 15);
            prodLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
            prodLegendText.setAttribute('fill', '#666');
            prodLegendText.textContent = 'Production';
            legendGroup.appendChild(prodLegendText);
            
            const targetLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetLegendRect.setAttribute('x', padding.left + 100);
            targetLegendRect.setAttribute('y', padding.top - 25);
            targetLegendRect.setAttribute('width', 12);
            targetLegendRect.setAttribute('height', 12);
            targetLegendRect.setAttribute('fill', 'var(--target-color)');
            legendGroup.appendChild(targetLegendRect);
            
            const targetLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLegendText.setAttribute('x', padding.left + 118);
            targetLegendText.setAttribute('y', padding.top - 15);
            targetLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
            targetLegendText.setAttribute('fill', '#666');
            targetLegendText.textContent = 'Target';
            legendGroup.appendChild(targetLegendText);
            
            svg.appendChild(legendGroup);
        }

        document.addEventListener('DOMContentLoaded', initDashboard);

        window.addEventListener('beforeunload', function() {
            if (cycleInterval) clearInterval(cycleInterval);
            if (chartRotationInterval) clearInterval(chartRotationInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        });
    </script>
</body>
</html>
