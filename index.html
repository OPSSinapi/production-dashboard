<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <style>
        :root {
            --primary-color: #6e8efb;
            --secondary-color: #a777e3;
            --success-color: #52c41a;
            --danger-color: #ff4d4f;
            --warning-color: #faad14;
            --text-color: #1a1a1a;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --border-color: #e0e0e0;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.15);
            --production-color: #ff6b6b;
            --target-color: #51cf66;
            --supervisor-michaela: #ff6b6b;
            --supervisor-leticia: #ffd93d;
            --supervisor-isaac: #6bcf7f;
            --supervisor-jonas: #4ecdc4;
            --supervisor-eunice: #a8e6cf;
            --supervisor-josephine: #ffeaa7;
            --supervisor-moses: #dfe6e9;
            --supervisor-godsway: #74b9ff;
            --supervisor-faustina: #fdcb6e;
            --supervisor-aaron: #e17055;
            --supervisor-seth: #00b894;
            --supervisor-elvis: #0984e3;
            --supervisor-belinda: #6c5ce7;
            --supervisor-benedict: #fd79a8;
            --supervisor-michael: #636e72;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .fullscreen-active {
            background-color: #000000;
        }

        .fullscreen-active .main-container {
            max-width: 100%;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--bg-primary);
            box-shadow: var(--shadow);
            padding: 1rem 2rem;
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-group label {
            font-weight: 500;
            color: #666;
        }

        .filter-select {
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-select:hover {
            border-color: var(--primary-color);
        }

        .supervisor-select-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .supervisor-select-btn:hover {
            border-color: var(--primary-color);
            background-color: #f8f9fa;
        }

        .supervisor-select-btn.filtered {
            border-color: var(--primary-color);
            background-color: #e8f0ff;
            color: var(--primary-color);
            font-weight: 500;
        }

        .supervisor-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        .supervisor-dropdown.show {
            display: block;
        }

        .supervisor-dropdown-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f8f9fa;
        }

        .supervisor-dropdown-header button {
            padding: 0.25rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-primary);
            cursor: pointer;
            font-size: 0.875rem;
        }

        .supervisor-dropdown-header button:hover {
            background-color: #e8f0ff;
        }

        .supervisor-option {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .supervisor-option:hover {
            background-color: #f8f9fa;
        }

        .supervisor-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .supervisor-option .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .fullscreen-btn {
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .fullscreen-btn:hover {
            background-color: #5a7aed;
            transform: translateY(-2px);
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .fullscreen-active .main-container {
            padding: 1rem;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 3fr;
            gap: 1.5rem;
            flex: 1;
        }

        .fullscreen-active .content-grid {
            gap: 1rem;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .status-card {
            background-color: var(--bg-primary);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
        }

        .fullscreen-active .status-card {
            padding: 1rem;
        }

        .time-display {
            text-align: center;
            margin-bottom: 1rem;
        }

        .current-time {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .current-hour-indicator {
            font-size: 1.1rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .variant-info {
            background-color: #fff9e6;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .variant-info h3 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .variant-chain {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            color: #666;
            flex-wrap: wrap;
        }

        .variant-item {
            background-color: var(--bg-primary);
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .variant-item.active {
            background-color: var(--primary-color);
            color: white;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .metric-card {
            text-align: center;
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: 8px;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .metric-value.production {
            color: var(--production-color);
        }

        .metric-value.target {
            color: var(--target-color);
        }

        .cycle-time-display {
            text-align: center;
            padding: 1rem;
            background-color: #f0f4ff;
            border-radius: 8px;
        }

        .cycle-time-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .cycle-time-label {
            font-size: 0.9rem;
            color: #666;
        }

        .chart-section {
            background-color: var(--bg-primary);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .fullscreen-active .chart-section {
            padding: 1rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .chart-area {
            flex: 1;
            position: relative;
            min-height: 400px;
        }

        .fullscreen-active .chart-area {
            min-height: 0;
        }

        .chart-container {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chart-navigation {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .chart-nav-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chart-nav-dot.active {
            background-color: var(--primary-color);
            transform: scale(1.2);
        }

        .chart-nav-dot:hover {
            background-color: #999;
        }

        .batch-info-section {
            margin-top: 1rem;
            border-top: 2px solid var(--border-color);
            padding-top: 1rem;
        }

        .batch-info-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .batch-info-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .batch-info-table th,
        .batch-info-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .batch-info-table th {
            background-color: var(--bg-secondary);
            font-weight: 600;
        }

        .batch-info-table tr:hover {
            background-color: #f8f9fa;
        }

        .batch-info-table tr.current {
            background-color: #e8f0ff;
            font-weight: 500;
        }

        .batch-number {
            font-family: monospace;
            font-size: 0.95rem;
        }

        .progress-indicator {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .progress-indicator.on-track {
            background-color: #d4f8d4;
            color: #2e7d2e;
        }

        .progress-indicator.behind {
            background-color: #ffe4e4;
            color: #d32f2f;
        }

        .footer {
            text-align: center;
            padding: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 1024px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .main-container {
                padding: 1rem;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>Sinapi Secondary Production Dashboard</h1>
            <div class="header-controls">
                <div class="filter-group">
                    <label for="filter-type-select">Filter by</label>
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Supervisor</option>
                        <option value="product">Product</option>
                    </select>
                </div>
                <div class="filter-group">
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                <div style="position: relative;">
                    <button id="supervisor-select-btn" class="supervisor-select-btn">
                        Select Supervisors
                    </button>
                    <div id="supervisor-dropdown" class="supervisor-dropdown">
                        <div class="supervisor-dropdown-header">
                            <span id="supervisor-count">All selected</span>
                            <div>
                                <button onclick="selectAllSupervisors()">All</button>
                                <button onclick="selectNoneSupervisors()">None</button>
                            </div>
                        </div>
                        <div id="supervisor-list"></div>
                    </div>
                </div>
                <button id="fullscreen-btn" class="fullscreen-btn">
                    <span>Fullscreen</span>
                </button>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="content-grid">
            <div class="info-panel">
                <div class="status-card">
                    <div class="time-display">
                        <div class="current-time" id="current-time">00:00:00</div>
                        <div class="current-hour-indicator">
                            CURRENT HOUR: <span id="current-hour-period">00:00</span> 
                            (<span id="time-remaining">0 MIN LEFT</span>)
                        </div>
                    </div>
                    
                    <div class="variant-info">
                        <h3>SUPERVISOR: <span id="supervisor-name">-</span></h3>
                        <div>PRODUCT: <span id="product-name">-</span></div>
                        <div class="variant-chain" id="variant-chain"></div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-label">UNITS</div>
                            <div class="metric-value">
                                <span class="production" id="current-units">0</span>/<span class="target" id="target-units">0</span>
                            </div>
                            <div id="units-progress" style="font-size: 0.9rem; color: #666;">0%</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">BOXES</div>
                            <div class="metric-value">
                                <span class="production" id="current-boxes">0</span>/<span class="target" id="target-boxes">0</span>
                            </div>
                            <div style="font-size: 0.9rem; color: #666;">completed</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">CYCLE TIME</div>
                            <div class="metric-value">
                                <span class="production" id="actual-cycle-time">0</span>/<span class="target" id="target-cycle-time">0</span>
                            </div>
                            <div style="font-size: 0.9rem; color: #666;">seconds</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chart-section">
                <div class="chart-header">
                    <h2 class="chart-title" id="chart-title">Production Progress</h2>
                </div>
                <div class="chart-area">
                    <div class="chart-container" id="cumulative-chart"></div>
                    <div class="chart-container" id="hourly-chart" style="display: none;"></div>
                </div>
                <div class="chart-navigation">
                    <span class="chart-nav-dot active" data-chart="cumulative"></span>
                    <span class="chart-nav-dot" data-chart="hourly"></span>
                </div>
                
                <div class="batch-info-section">
                    <h3 class="batch-info-title">BATCH INFORMATION</h3>
                    <table class="batch-info-table">
                        <thead>
                            <tr>
                                <th>Product</th>
                                <th>Variant</th>
                                <th>Batch</th>
                                <th>Units</th>
                                <th>Boxes</th>
                            </tr>
                        </thead>
                        <tbody id="batch-info-body">
                            <!-- Batch rows will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Last updated: <span id="last-updated">-</span></p>
    </div>

    <script>
        // Configuration
        const UPDATE_INTERVAL = 5000; // 5 seconds
        const CHART_ROTATION_INTERVAL = 10000; // 10 seconds
        const DATA_URL = './data.json';
        
        // State
        let productionData = null;
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let currentChartIndex = 0;
        let cycleInterval = null;
        let chartRotationInterval = null;
        let countdownInterval = null;
        let isFullscreen = false;
        let selectedSupervisors = [];
        let supervisorFilterActive = false;
        
        // DOM Elements
        const fullscreenButton = document.getElementById('fullscreen-btn');
        const body = document.body;

        // Initialize supervisor multi-select functionality
        function initSupervisorSelection() {
            const selectBtn = document.getElementById('supervisor-select-btn');
            const dropdown = document.getElementById('supervisor-dropdown');
            
            selectBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                dropdown.classList.toggle('show');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!dropdown.contains(e.target) && e.target !== selectBtn) {
                    dropdown.classList.remove('show');
                }
            });
        }

        // Select all supervisors
        function selectAllSupervisors() {
            const checkboxes = document.querySelectorAll('#supervisor-list input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateSelectedSupervisors();
        }

        // Deselect all supervisors
        function selectNoneSupervisors() {
            const checkboxes = document.querySelectorAll('#supervisor-list input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            updateSelectedSupervisors();
        }

        // Update selected supervisors
        function updateSelectedSupervisors() {
            const checkboxes = document.querySelectorAll('#supervisor-list input[type="checkbox"]:checked');
            selectedSupervisors = Array.from(checkboxes).map(cb => cb.value);
            
            const totalSupervisors = document.querySelectorAll('#supervisor-list input[type="checkbox"]').length;
            const countSpan = document.getElementById('supervisor-count');
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (selectedSupervisors.length === 0) {
                countSpan.textContent = 'None selected';
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
                supervisorFilterActive = false;
            } else if (selectedSupervisors.length === totalSupervisors) {
                countSpan.textContent = 'All selected';
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
                supervisorFilterActive = false;
            } else {
                countSpan.textContent = `${selectedSupervisors.length} of ${totalSupervisors} selected`;
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${totalSupervisors})`;
                selectBtn.classList.add('filtered');
                supervisorFilterActive = true;
            }
            
            // Save to localStorage
            localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
            
            // Update dashboard
            updateDashboard();
        }

        // Populate supervisor dropdown
        function populateSupervisorDropdown() {
            const supervisorList = document.getElementById('supervisor-list');
            supervisorList.innerHTML = '';
            
            if (productionData && productionData.supervisors) {
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('div');
                    option.className = 'supervisor-option';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = supervisor.name;
                    checkbox.checked = selectedSupervisors.length === 0 || selectedSupervisors.includes(supervisor.name);
                    checkbox.addEventListener('change', updateSelectedSupervisors);
                    
                    const colorIndicator = document.createElement('span');
                    colorIndicator.className = 'color-indicator';
                    colorIndicator.style.backgroundColor = getSupervisorColor(supervisor.name);
                    
                    const label = document.createElement('label');
                    label.style.cursor = 'pointer';
                    label.textContent = supervisor.name;
                    
                    option.appendChild(checkbox);
                    option.appendChild(colorIndicator);
                    option.appendChild(label);
                    
                    // Make the whole row clickable
                    option.addEventListener('click', function(e) {
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                            updateSelectedSupervisors();
                        }
                    });
                    
                    supervisorList.appendChild(option);
                });
                
                // Initialize selected supervisors if empty
                if (selectedSupervisors.length === 0) {
                    selectedSupervisors = productionData.supervisors.map(s => s.name);
                }
            }
        }

        // Get supervisor color
        function getSupervisorColor(supervisorName) {
            const colorMap = {
                'Michaela': 'var(--supervisor-michaela)',
                'Leticia': 'var(--supervisor-leticia)',
                'Isaac': 'var(--supervisor-isaac)',
                'Jonas': 'var(--supervisor-jonas)',
                'Eunice': 'var(--supervisor-eunice)',
                'Josephine': 'var(--supervisor-josephine)',
                'Moses': 'var(--supervisor-moses)',
                'Godsway': 'var(--supervisor-godsway)',
                'Faustina': 'var(--supervisor-faustina)',
                'Aaron': 'var(--supervisor-aaron)',
                'Seth': 'var(--supervisor-seth)',
                'Elvis': 'var(--supervisor-elvis)',
                'Belinda': 'var(--supervisor-belinda)',
                'Benedict': 'var(--supervisor-benedict)',
                'Michael': 'var(--supervisor-michael)',
                'Michaela': 'var(--supervisor-michaela)'
            };
            
            return colorMap[supervisorName] || '#e2e8f0'; // Default color if not found
        }

        // Function to load selected supervisors from localStorage
        function loadSelectedSupervisors() {
            const stored = localStorage.getItem('selectedSupervisors');
            if (stored) {
                try {
                    selectedSupervisors = JSON.parse(stored);
                    
                    // Validate against current supervisors
                    if (productionData && productionData.supervisors) {
                        const validSupervisors = productionData.supervisors.map(s => s.name);
                        selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                        
                        // If none valid, select all
                        if (selectedSupervisors.length === 0) {
                            selectedSupervisors = validSupervisors;
                        }
                    }
                    
                    // Update UI
                    supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
                    const selectBtn = document.getElementById('supervisor-select-btn');
                    
                    if (supervisorFilterActive) {
                        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                        selectBtn.classList.add('filtered');
                    }
                } catch (e) {
                    console.error('Error parsing stored supervisors:', e);
                    if (productionData && productionData.supervisors) {
                        selectedSupervisors = productionData.supervisors.map(s => s.name);
                    }
                }
            }
        }

        // Function to fetch production data
        async function fetchProductionData() {
            try {
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const newData = await response.json();
                
                // Transform the data to the expected format
                productionData = transformDataFormat(newData);
                
                // Load saved supervisor selections
                loadSelectedSupervisors();
                
                // Update dropdowns
                updateFilterOptions();
                populateSupervisorDropdown();
                
                // Update display
                updateDashboard();
                
                // Update last updated time
                document.getElementById('last-updated').textContent = 
                    new Date(productionData.timestamp).toLocaleString();
            } catch (error) {
                console.error('Error fetching production data:', error);
                showError(`Failed to load production data: ${error.message}`);
            }
        }

        // Function to transform data format
        function transformDataFormat(newData) {
            // This is the existing function, no changes needed
            const transformedData = {
                variants: [],
                supervisors: [],
                timestamp: newData.metadata.timestamp || new Date().toISOString()
            };
            
            // Check which structure we're working with and handle accordingly
            if (newData.production && Array.isArray(newData.production)) {
                // New structure with production array and summary
                
                // Transform production items to variants
                newData.production.forEach(item => {
                    const transformedVariant = {
                        variant: item.id,
                        "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                        cycleTime: item.variant.cycleTime,
                        actualCycleTime: item.variant.actualCycleTime,
                        "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                        "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                        dailyBoxTarget: item.targets.boxes,
                        currentBoxTotal: item.actual.boxes,
                        hourlyTargets: [],
                        hourlyProduction: [],
                        timeline: item.timeline // Keep the timeline data
                    };
                    
                    // Add hourly targets and production data
                    if (item.timeline && Array.isArray(item.timeline)) {
                        item.timeline.forEach(hour => {
                            // Add hourly target
                            transformedVariant.hourlyTargets.push({
                                hour: hour.hour,
                                target: hour.target
                            });
                            
                            // Add hourly production
                            transformedVariant.hourlyProduction.push({
                                hour: hour.hour,
                                production: hour.actual
                            });
                        });
                    }
                    
                    transformedData.variants.push(transformedVariant);
                });
                
                // Process supervisors from the summary section
                if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                    newData.summary.supervisors.forEach(supervisor => {
                        const transformedSupervisor = {
                            name: supervisor.name,
                            variants: {}
                        };
                        
                        // Find all production items assigned to this supervisor
                        if (supervisor.variants && Array.isArray(supervisor.variants)) {
                            supervisor.variants.forEach(variantId => {
                                // Find the production item for this variant
                                const prodItem = newData.production.find(p => p.id === variantId);
                                
                                if (prodItem) {
                                    // Find the supervisor assignment within the production item
                                    const assignment = prodItem.supervisors.find(s => s.id === supervisor.id || s.name === supervisor.name);
                                    
                                    if (assignment) {
                                        transformedSupervisor.variants[variantId] = {
                                            production: assignment.production,
                                            target: assignment.target,
                                            variantStartTime: assignment.startTime,
                                            variantEndTime: assignment.endTime,
                                            progress: assignment.progress
                                        };
                                    }
                                }
                            });
                        }
                        
                        transformedData.supervisors.push(transformedSupervisor);
                    });
                }
            }
            
            return transformedData;
        }

        // Function to update filter options
        function updateFilterOptions() {
            if (!productionData) return;
            
            const filterValueSelect = document.getElementById('filter-value-select');
            filterValueSelect.innerHTML = '<option value="all">All</option>';
            
            if (selectedFilterType === 'supervisor') {
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                const products = [...new Set(productionData.variants.map(v => v["Product Name"].split(' ')[0]))];
                products.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            }
            
            filterValueSelect.value = selectedFilterValue;
        }

        // Function to update filter value dropdown
        function updateFilterValueDropdown() {
            selectedFilterValue = 'all';
            updateFilterOptions();
        }

        // Function to calculate combined hourly data across multiple supervisors/variants
        function calculateCombinedHourlyData(selectedData, isForHourlyChart = false) {
            const combinedData = new Map();
            const now = new Date();
            
            selectedData.variants.forEach(variant => {
                const supervisorVariant = selectedData.supervisorData ? 
                    selectedData.supervisorData.variants[variant.variant] : null;
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Use timeline data instead of hourlyTargets/hourlyProduction
                if (variant.timeline && Array.isArray(variant.timeline)) {
                    variant.timeline.forEach(hourData => {
                        const hour = hourData.hour;
                        const [hourVal, minuteVal] = hour.split(':').map(Number);
                        const hourTimeMinutes = hourVal * 60 + minuteVal;
                        
                        // Check if this hour falls within the variant's active period
                        if (hourTimeMinutes >= startTimeMinutes && hourTimeMinutes <= endTimeMinutes) {
                            if (!combinedData.has(hour)) {
                                combinedData.set(hour, {
                                    hour: hour,
                                    production: 0,
                                    target: 0,
                                    variants: []
                                });
                            }
                            
                            const data = combinedData.get(hour);
                            data.production += hourData.actual || 0;
                            
                            // For transition hours, add the transition target
                            if (hourData.transitionTarget > 0) {
                                data.target += hourData.transitionTarget;
                            } else {
                                data.target += hourData.target || 0;
                            }
                            
                            data.variants.push({
                                name: variant.variant,
                                production: hourData.actual || 0,
                                target: hourData.transitionTarget > 0 ? hourData.transitionTarget : (hourData.target || 0),
                                previousVariant: hourData.previousVariant,
                                previousVariantMinutes: hourData.previousVariantMinutes,
                                currentVariantMinutes: hourData.currentVariantMinutes
                            });
                        }
                    });
                }
            });
            
            return Array.from(combinedData.values()).sort((a, b) => {
                const [hourA, minuteA] = a.hour.split(':').map(Number);
                const [hourB, minuteB] = b.hour.split(':').map(Number);
                return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
            });
        }

        // Function to get filtered data
        function getFilteredData() {
            if (!productionData) return null;
            
            let filteredSupervisors = productionData.supervisors;
            
            // Apply supervisor multi-select filter
            if (supervisorFilterActive && selectedSupervisors.length > 0) {
                filteredSupervisors = filteredSupervisors.filter(s => 
                    selectedSupervisors.includes(s.name)
                );
            }
            
            // Apply dropdown filter
            if (selectedFilterType === 'supervisor' && selectedFilterValue !== 'all') {
                filteredSupervisors = filteredSupervisors.filter(s => s.name === selectedFilterValue);
            }
            
            // Get all variants assigned to filtered supervisors
            const assignedVariants = new Set();
            filteredSupervisors.forEach(supervisor => {
                Object.keys(supervisor.variants).forEach(variantId => {
                    assignedVariants.add(variantId);
                });
            });
            
            let filteredVariants = productionData.variants.filter(v => 
                assignedVariants.has(v.variant)
            );
            
            // Apply product filter
            if (selectedFilterType === 'product' && selectedFilterValue !== 'all') {
                filteredVariants = filteredVariants.filter(v => 
                    v["Product Name"].split(' ')[0] === selectedFilterValue
                );
            }
            
            return {
                variants: filteredVariants,
                supervisors: filteredSupervisors
            };
        }

        // Function to update dashboard
        function updateDashboard() {
            const filteredData = getFilteredData();
            if (!filteredData || filteredData.variants.length === 0) {
                showNoDataMessage();
                return;
            }
            
            // Calculate totals
            const totals = calculateTotals(filteredData);
            
            // Update metrics
            updateMetrics(totals);
            
            // Update variant info
            updateVariantInfo(totals);
            
            // Update charts
            updateCharts(totals);
            
            // Update batch information
            updateBatchInfo(totals);
        }

        // Function to calculate totals
        function calculateTotals(filteredData) {
            const groups = [];
            
            filteredData.supervisors.forEach(supervisor => {
                const group = {
                    supervisor: supervisor.name,
                    supervisorData: supervisor,
                    variants: [],
                    totalProduction: 0,
                    totalTarget: 0,
                    totalBoxes: 0,
                    totalBoxTarget: 0,
                    weightedCycleTime: 0,
                    weightedActualCycleTime: 0,
                    totalActiveMinutes: 0
                };
                
                // Get variants for this supervisor
                Object.keys(supervisor.variants).forEach(variantId => {
                    const variant = filteredData.variants.find(v => v.variant === variantId);
                    if (variant) {
                        const variantData = supervisor.variants[variantId];
                        group.variants.push(variant);
                        group.totalProduction += variantData.production || 0;
                        group.totalTarget += variantData.target || 0;
                        group.totalBoxes += variant.currentBoxTotal || 0;
                        group.totalBoxTarget += variant.dailyBoxTarget || 0;
                        
                        // Calculate active minutes for weighted average
                        const startTime = variantData.variantStartTime || variant["Start Time"];
                        const endTime = variantData.variantEndTime || variant["End Time"];
                        
                        if (startTime && endTime) {
                            const activeMinutes = calculateActiveMinutes(startTime, endTime, variant);
                            group.totalActiveMinutes += activeMinutes;
                            group.weightedCycleTime += (variant.cycleTime || 0) * activeMinutes;
                            group.weightedActualCycleTime += (variant.actualCycleTime || 0) * activeMinutes;
                        }
                    }
                });
                
                // Calculate weighted averages
                if (group.totalActiveMinutes > 0) {
                    group.avgCycleTime = Math.round(group.weightedCycleTime / group.totalActiveMinutes);
                    group.avgActualCycleTime = Math.round(group.weightedActualCycleTime / group.totalActiveMinutes);
                } else {
                    group.avgCycleTime = 0;
                    group.avgActualCycleTime = 0;
                }
                
                if (group.variants.length > 0) {
                    groups.push(group);
                }
            });
            
            // If multiple groups, combine them
            if (groups.length > 1) {
                const combined = {
                    supervisor: groups.map(g => g.supervisor).join(', '),
                    supervisorData: null, // Combined data
                    variants: [],
                    totalProduction: 0,
                    totalTarget: 0,
                    totalBoxes: 0,
                    totalBoxTarget: 0,
                    weightedCycleTime: 0,
                    weightedActualCycleTime: 0,
                    totalActiveMinutes: 0
                };
                
                groups.forEach(group => {
                    combined.variants.push(...group.variants);
                    combined.totalProduction += group.totalProduction;
                    combined.totalTarget += group.totalTarget;
                    combined.totalBoxes += group.totalBoxes;
                    combined.totalBoxTarget += group.totalBoxTarget;
                    combined.weightedCycleTime += group.weightedCycleTime;
                    combined.weightedActualCycleTime += group.weightedActualCycleTime;
                    combined.totalActiveMinutes += group.totalActiveMinutes;
                });
                
                // Remove duplicates from variants
                const uniqueVariants = [];
                const seenVariants = new Set();
                combined.variants.forEach(v => {
                    if (!seenVariants.has(v.variant)) {
                        seenVariants.add(v.variant);
                        uniqueVariants.push(v);
                    }
                });
                combined.variants = uniqueVariants;
                
                // Calculate weighted averages
                if (combined.totalActiveMinutes > 0) {
                    combined.avgCycleTime = Math.round(combined.weightedCycleTime / combined.totalActiveMinutes);
                    combined.avgActualCycleTime = Math.round(combined.weightedActualCycleTime / combined.totalActiveMinutes);
                } else {
                    combined.avgCycleTime = 0;
                    combined.avgActualCycleTime = 0;
                }
                
                return combined;
            } else if (groups.length === 1) {
                return groups[0];
            } else {
                return null;
            }
        }

        // Function to calculate active minutes
        function calculateActiveMinutes(startTime, endTime, variant) {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentTotalMinutes = currentHour * 60 + currentMinute;
            
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const [endHour, endMinute] = endTime.split(':').map(Number);
            
            const startTotalMinutes = startHour * 60 + startMinute;
            let endTotalMinutes = endHour * 60 + endMinute;
            
            // If current time is before variant start, return 0
            if (currentTotalMinutes < startTotalMinutes) return 0;
            
            // If current time is after variant end, use full duration
            if (currentTotalMinutes > endTotalMinutes) {
                return endTotalMinutes - startTotalMinutes - getElapsedBreakMinutes(variant);
            }
            
            // Otherwise, use elapsed time
            return currentTotalMinutes - startTotalMinutes - getElapsedBreakMinutes(variant);
        }

        // Function to update metrics
        function updateMetrics(group) {
            if (!group) return;
            
            document.getElementById('current-units').textContent = group.totalProduction;
            document.getElementById('target-units').textContent = group.totalTarget;
            document.getElementById('units-progress').textContent = 
                group.totalTarget > 0 ? Math.round((group.totalProduction / group.totalTarget) * 100) + '%' : '0%';
            
            document.getElementById('current-boxes').textContent = group.totalBoxes;
            document.getElementById('target-boxes').textContent = group.totalBoxTarget;
            
            document.getElementById('actual-cycle-time').textContent = group.avgActualCycleTime;
            document.getElementById('target-cycle-time').textContent = group.avgCycleTime;
        }

        // Function to update variant info
        function updateVariantInfo(group) {
            if (!group) return;
            
            document.getElementById('supervisor-name').textContent = group.supervisor;
            
            // Get unique products
            const products = [...new Set(group.variants.map(v => v["Product Name"].split(' ')[0]))];
            document.getElementById('product-name').textContent = products.join(', ');
            
            // Create variant chain
            const variantChain = document.getElementById('variant-chain');
            variantChain.innerHTML = '';
            
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            
            group.variants.forEach((variant, index) => {
                if (index > 0) {
                    const arrow = document.createElement('span');
                    arrow.textContent = '→';
                    arrow.style.margin = '0 0.5rem';
                    variantChain.appendChild(arrow);
                }
                
                const variantItem = document.createElement('span');
                variantItem.className = 'variant-item';
                variantItem.textContent = variant.variant.split('-')[1] || variant.variant;
                
                // Check if variant is currently active
                const supervisorVariant = group.supervisorData ? 
                    group.supervisorData.variants[variant.variant] : null;
                
                if (supervisorVariant) {
                    const startTime = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTime = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (startTime && endTime) {
                        const [startHour, startMinute] = startTime.split(':').map(Number);
                        const [endHour, endMinute] = endTime.split(':').map(Number);
                        
                        const startMinutes = startHour * 60 + startMinute;
                        const endMinutes = endHour * 60 + endMinute;
                        
                        if (currentMinutes >= startMinutes && currentMinutes <= endMinutes) {
                            variantItem.classList.add('active');
                        }
                    }
                }
                
                variantChain.appendChild(variantItem);
            });
        }

        // Function to update charts
        function updateCharts(group) {
            if (!group) return;
            
            if (currentChartIndex === 0) {
                renderCumulativeChart(group);
            } else {
                renderHourlyChart(group);
            }
        }

        // Function to update batch information
        function updateBatchInfo(group) {
            if (!group) return;
            
            const batchInfoBody = document.getElementById('batch-info-body');
            batchInfoBody.innerHTML = '';
            
            // Collect all batches from variants
            const batches = [];
            
            group.variants.forEach(variant => {
                // Check if variant has batch information in the expected format
                if (variant.batches && Array.isArray(variant.batches)) {
                    variant.batches.forEach(batch => {
                        batches.push({
                            product: variant["Product Name"].split(' ')[0],
                            variant: variant.variant.split('-')[1] || variant.variant,
                            batchId: batch.id,
                            units: batch.quantity,
                            boxes: batch.boxes,
                            isCurrent: false // You might want to determine this based on time
                        });
                    });
                } else {
                    // Fallback for legacy data format
                    const batchMatch = variant.variant.match(/(\d+)$/);
                    if (batchMatch) {
                        batches.push({
                            product: variant["Product Name"].split(' ')[0],
                            variant: variant.variant.split('-')[1] || variant.variant,
                            batchId: batchMatch[1],
                            units: group.supervisorData ? 
                                (group.supervisorData.variants[variant.variant]?.production || 0) : 0,
                            boxes: variant.currentBoxTotal || 0,
                            isCurrent: false
                        });
                    }
                }
            });
            
            // Sort batches by product and batch ID
            batches.sort((a, b) => {
                if (a.product !== b.product) {
                    return a.product.localeCompare(b.product);
                }
                return a.batchId.localeCompare(b.batchId);
            });
            
            // Render batch rows with product grouping
            let lastProduct = '';
            batches.forEach(batch => {
                // Add product header if it's a new product
                if (batch.product !== lastProduct) {
                    lastProduct = batch.product;
                    const productRow = document.createElement('tr');
                    productRow.style.backgroundColor = '#f8f9fa';
                    
                    const productCell = document.createElement('td');
                    productCell.colSpan = 5;
                    productCell.style.fontWeight = 'bold';
                    productCell.style.fontSize = 'larger';
                    productCell.textContent = batch.product;
                    
                    productRow.appendChild(productCell);
                    batchInfoBody.appendChild(productRow);
                }
                
                // Create batch row
                const row = document.createElement('tr');
                if (batch.isCurrent) {
                    row.className = 'current';
                }
                
                // Product cell - Now less prominent since we have product headers
                const productCell = document.createElement('td');
                productCell.style.opacity = '0.5'; // Make less prominent
                productCell.textContent = batch.product;
                row.appendChild(productCell);
                
                // Variant cell
                const variantCell = document.createElement('td');
                variantCell.textContent = batch.variant;
                row.appendChild(variantCell);
                
                // Batch ID cell
                const batchCell = document.createElement('td');
                batchCell.className = 'batch-number';
                batchCell.textContent = batch.batchId;
                row.appendChild(batchCell);
                
                // Units cell
                const unitsCell = document.createElement('td');
                unitsCell.textContent = batch.units;
                row.appendChild(unitsCell);
                
                // Boxes cell
                const boxesCell = document.createElement('td');
                boxesCell.textContent = batch.boxes;
                row.appendChild(boxesCell);
                
                batchInfoBody.appendChild(row);
            });
        }

        // Fixed version of renderCumulativeChart
        function renderCumulativeChart(group) {
            const chartContainer = document.getElementById('cumulative-chart');
            chartContainer.innerHTML = '';
            
            // Get combined hourly data
            const combinedData = calculateCombinedHourlyData(group);
            if (combinedData.length === 0) {
                chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available</div>';
                return;
            }
            
            // Build cumulative data arrays
            const cumulativeData = [];
            let runningProductionTotal = 0;
            let runningTargetTotal = 0;
            
            combinedData.forEach(hourData => {
                runningProductionTotal += hourData.production;
                runningTargetTotal += hourData.target;
                
                const [hourVal, minuteVal] = hourData.hour.split(':').map(Number);
                const timeMinutes = hourVal * 60 + minuteVal;
                
                cumulativeData.push({
                    hour: hourData.hour,
                    production: runningProductionTotal,
                    target: runningTargetTotal,
                    timeMinutes: timeMinutes,
                    variants: hourData.variants
                });
            });
            
            // Get current totals from metrics for validation
            const metricsCurrentUnits = parseInt(document.getElementById('current-units').textContent, 10);
            const metricsTargetUnits = parseInt(document.getElementById('target-units').textContent, 10);
            
            // Add current time point if needed
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            const currentTimeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            
            // Ensure we have the most recent data point
            if (cumulativeData.length > 0) {
                const lastPoint = cumulativeData[cumulativeData.length - 1];
                if (lastPoint.production !== metricsCurrentUnits && metricsCurrentUnits > 0) {
                    cumulativeData.push({
                        hour: currentTimeStr,
                        production: metricsCurrentUnits,
                        target: metricsTargetUnits,
                        timeMinutes: currentTimeMinutes,
                        variants: []
                    });
                }
            }
            
            // FIX: Don't filter data - show all available data points
            // Instead of filtering, we'll use all cumulative data
            
            // Get chart dimensions
            const chartArea = chartContainer.closest('.chart-area');
            const svgWidth = chartArea.clientWidth;
            const svgHeight = chartArea.clientHeight;
            
            if (svgWidth <= 0 || svgHeight <= 0) {
                setTimeout(() => renderCumulativeChart(group), 100);
                return;
            }
            
            const padding = {
                top: Math.max(30, Math.floor(svgHeight * 0.08)),
                right: Math.max(10, Math.floor(svgWidth * 0.05)),
                bottom: Math.max(50, Math.floor(svgHeight * 0.18)),
                left: Math.max(50, Math.floor(svgWidth * 0.08))
            };
            
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            // Find max value for scaling
            const maxValue = Math.max(
                ...cumulativeData.map(item => Math.max(item.target || 0, item.production || 0))
            ) * 1.1;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            chartContainer.appendChild(svg);
            
            // Add grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            svg.appendChild(gridGroup);
            
            // Add y-axis title
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 35);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', isFullscreen ? '16' : '14');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            svg.appendChild(yAxisTitle);
            
            // Calculate x-axis range
            const startTime = 7.5 * 60; // 7:30
            const endTime = 16.5 * 60; // 16:30
            
            // Draw x-axis with time labels
            const xAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const hours = ['07:30', '08:30', '09:30', '10:30', '11:30', '12:30', '13:30', '14:30', '15:30', '16:30'];
            
            hours.forEach((hour, index) => {
                const x = padding.left + (chartWidth * index / (hours.length - 1));
                
                // Add tick
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', svgHeight - padding.bottom);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', svgHeight - padding.bottom + 5);
                tick.setAttribute('stroke', '#666');
                xAxisGroup.appendChild(tick);
                
                // Add label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', svgHeight - padding.bottom + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', isFullscreen ? '14' : '12');
                label.setAttribute('fill', '#666');
                label.textContent = hour;
                xAxisGroup.appendChild(label);
                
                // Add status indicator
                const [hourVal] = hour.split(':').map(Number);
                const hourMinutes = hourVal * 60 + 30;
                const hourStatus = getHourStatus(hourMinutes, cumulativeData);
                
                if (hourStatus !== 'upcoming') {
                    const statusSymbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    statusSymbol.setAttribute('x', x);
                    statusSymbol.setAttribute('y', svgHeight - padding.bottom + 35);
                    statusSymbol.setAttribute('text-anchor', 'middle');
                    statusSymbol.setAttribute('font-size', isFullscreen ? '16' : '14');
                    statusSymbol.setAttribute('font-weight', 'bold');
                    
                    if (hourStatus === 'met') {
                        statusSymbol.setAttribute('fill', var(--success-color));
                        statusSymbol.textContent = '✓';
                    } else if (hourStatus === 'missed') {
                        statusSymbol.setAttribute('fill', var(--danger-color));
                        statusSymbol.textContent = '✗';
                    } else if (hourStatus === 'current') {
                        statusSymbol.setAttribute('fill', var(--warning-color));
                        statusSymbol.textContent = '●';
                    }
                    
                    xAxisGroup.appendChild(statusSymbol);
                }
            });
            
            svg.appendChild(xAxisGroup);
            
            // Helper function to calculate x position
            const getXPosition = (timeMinutes) => {
                const ratio = (timeMinutes - startTime) / (endTime - startTime);
                return padding.left + (chartWidth * ratio);
            };
            
            // Draw production line
            const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Start from zero at 7:30
            let productionPathD = `M ${padding.left} ${padding.top + chartHeight}`;
            const productionPoints = [{
                x: padding.left,
                y: padding.top + chartHeight,
                production: 0,
                hour: '07:30'
            }];
            
            cumulativeData.forEach(dataPoint => {
                const x = getXPosition(dataPoint.timeMinutes);
                const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
                
                productionPoints.push({
                    x, y,
                    production: dataPoint.production,
                    hour: dataPoint.hour
                });
                productionPathD += ` L ${x} ${y}`;
            });
            
            // Add production line
            const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            productionPath.setAttribute('d', productionPathD);
            productionPath.setAttribute('stroke', 'var(--production-color)');
            productionPath.setAttribute('stroke-width', '3');
            productionPath.setAttribute('fill', 'none');
            productionLineGroup.appendChild(productionPath);
            
            // Add production points
            productionPoints.forEach((point, index) => {
                if (index === 0 && point.production === 0) return; // Skip initial zero point
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', isFullscreen ? '5' : '4');
                circle.setAttribute('fill', 'var(--production-color)');
                productionLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'var(--production-color)');
                text.textContent = point.production;
                productionLineGroup.appendChild(text);
            });
            
            svg.appendChild(productionLineGroup);
            
            // Draw target line
            const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Start from zero at 7:30
            let targetPathD = `M ${padding.left} ${padding.top + chartHeight}`;
            const targetPoints = [{
                x: padding.left,
                y: padding.top + chartHeight,
                target: 0,
                hour: '07:30'
            }];
            
            cumulativeData.forEach(dataPoint => {
                const x = getXPosition(dataPoint.timeMinutes);
                const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
                
                targetPoints.push({
                    x, y,
                    target: dataPoint.target,
                    hour: dataPoint.hour
                });
                targetPathD += ` L ${x} ${y}`;
            });
            
            // Add target line
            const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            targetPath.setAttribute('d', targetPathD);
            targetPath.setAttribute('stroke', 'var(--target-color)');
            targetPath.setAttribute('stroke-width', '3');
            targetPath.setAttribute('fill', 'none');
            targetLineGroup.appendChild(targetPath);
            
            // Add target points
            targetPoints.forEach((point, index) => {
                if (index === 0 && point.target === 0) return; // Skip initial zero point
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', isFullscreen ? '5' : '4');
                circle.setAttribute('fill', 'var(--target-color)');
                targetLineGroup.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isFullscreen ? '14' : '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'var(--target-color)');
                text.textContent = point.target;
                targetLineGroup.appendChild(text);
            });
            
            svg.appendChild(targetLineGroup);
            
            // Add legend
            const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Production legend
            const prodLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            prodLegendRect.setAttribute('x', padding.left);
            prodLegendRect.setAttribute('y', padding.top - 25);
            prodLegendRect.setAttribute('width', 12);
            prodLegendRect.setAttribute('height', 12);
            prodLegendRect.setAttribute('fill', 'var(--production-color)');
            legendGroup.appendChild(prodLegendRect);
            
            const prodLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            prodLegendText.setAttribute('x', padding.left + 18);
            prodLegendText.setAttribute('y', padding.top - 15);
            prodLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
            prodLegendText.setAttribute('fill', '#666');
            prodLegendText.textContent = 'Production';
            legendGroup.appendChild(prodLegendText);
            
            // Target legend
            const targetLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetLegendRect.setAttribute('x', padding.left + 100);
            targetLegendRect.setAttribute('y', padding.top - 25);
            targetLegendRect.setAttribute('width', 12);
            targetLegendRect.setAttribute('height', 12);
            targetLegendRect.setAttribute('fill', 'var(--target-color)');
            legendGroup.appendChild(targetLegendRect);
            
            const targetLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLegendText.setAttribute('x', padding.left + 118);
            targetLegendText.setAttribute('y', padding.top - 15);
            targetLegendText.setAttribute('font-size', isFullscreen ? '14' : '12');
            targetLegendText.setAttribute('fill', '#666');
            targetLegendText.textContent = 'Target';
            legendGroup.appendChild(targetLegendText);
            
            svg.appendChild(legendGroup);
        }

        // Helper function to get hour status
        function getHourStatus(hourMinutes, cumulativeData) {
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Find the data point for this hour
            const hourData = cumulativeData.find(d => {
                const [h, m] = d.hour.split(':').map(Number);
                return (h * 60 + m) === hourMinutes;
            });
            
            if (!hourData) return 'upcoming';
            
            // Only evaluate completed hours (past the :30 mark)
            if (currentTimeMinutes >= hourMinutes) {
                // Find the previous hour's data to calculate hourly performance
                const prevIndex = cumulativeData.indexOf(hourData) - 1;
                const prevData = prevIndex >= 0 ? cumulativeData[prevIndex] : { production: 0, target: 0 };
                
                const hourlyProduction = hourData.production - prevData.production;
                const hourlyTarget = hourData.target - prevData.target;
                
                return hourlyProduction >= hourlyTarget ? 'met' : 'missed';
            } else if (currentTimeMinutes >= hourMinutes - 60 && currentTimeMinutes < hourMinutes) {
                return 'current';
            } else {
                return 'upcoming';
            }
        }

        // Function to render hourly chart
        function renderHourlyChart(group) {
            const chartContainer = document.getElementById('hourly-chart');
            chartContainer.innerHTML = '';
            
            // Calculate current hour period
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentPeriodHour = currentMinute < 30 ? currentHour : currentHour + 1;
            const currentPeriodStr = `${currentPeriodHour.toString().padStart(2, '0')}:30`;
            
            // Get combined hourly data for the current hour only
            const combinedData = calculateCombinedHourlyData(group, true);
            const currentHourData = combinedData.find(d => d.hour === currentPeriodStr);
            
            if (!currentHourData) {
                chartContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for current hour</div>';
                return;
            }
            
            // Get chart dimensions
            const chartArea = chartContainer.closest('.chart-area');
            const svgWidth = chartArea.clientWidth;
            const svgHeight = chartArea.clientHeight;
            
            if (svgWidth <= 0 || svgHeight <= 0) {
                setTimeout(() => renderHourlyChart(group), 100);
                return;
            }
            
            const padding = {
                top: Math.max(30, Math.floor(svgHeight * 0.1)),
                right: Math.max(20, Math.floor(svgWidth * 0.05)),
                bottom: Math.max(60, Math.floor(svgHeight * 0.15)),
                left: Math.max(20, Math.floor(svgWidth * 0.05))
            };
            
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            chartContainer.appendChild(svg);
            
            // Calculate bar dimensions
            const barWidth = Math.min(chartWidth * 0.3, 100);
            const barSpacing = (chartWidth - 2 * barWidth) / 3;
            
            const maxValue = Math.max(currentHourData.production, currentHourData.target) * 1.2;
            
            // Draw production bar
            const prodX = padding.left + barSpacing;
            const prodHeight = (currentHourData.production / maxValue) * chartHeight;
            const prodY = padding.top + chartHeight - prodHeight;
            
            const prodBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            prodBar.setAttribute('x', prodX);
            prodBar.setAttribute('y', prodY);
            prodBar.setAttribute('width', barWidth);
            prodBar.setAttribute('height', prodHeight);
            prodBar.setAttribute('fill', 'var(--production-color)');
            prodBar.setAttribute('rx', '4');
            svg.appendChild(prodBar);
            
            // Production value
            const prodText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            prodText.setAttribute('x', prodX + barWidth / 2);
            prodText.setAttribute('y', prodY - 10);
            prodText.setAttribute('text-anchor', 'middle');
            prodText.setAttribute('font-size', isFullscreen ? '24' : '20');
            prodText.setAttribute('font-weight', 'bold');
            prodText.setAttribute('fill', 'var(--production-color)');
            prodText.textContent = currentHourData.production;
            svg.appendChild(prodText);
            
            // Production label
            const prodLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            prodLabel.setAttribute('x', prodX + barWidth / 2);
            prodLabel.setAttribute('y', padding.top + chartHeight + 25);
            prodLabel.setAttribute('text-anchor', 'middle');
            prodLabel.setAttribute('font-size', isFullscreen ? '16' : '14');
            prodLabel.setAttribute('fill', '#666');
            prodLabel.textContent = 'PRODUCTION';
            svg.appendChild(prodLabel);
            
            // Draw target bar
            const targetX = padding.left + 2 * barSpacing + barWidth;
            const targetHeight = (currentHourData.target / maxValue) * chartHeight;
            const targetY = padding.top + chartHeight - targetHeight;
            
            const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetBar.setAttribute('x', targetX);
            targetBar.setAttribute('y', targetY);
            targetBar.setAttribute('width', barWidth);
            targetBar.setAttribute('height', targetHeight);
            targetBar.setAttribute('fill', 'var(--target-color)');
            targetBar.setAttribute('rx', '4');
            svg.appendChild(targetBar);
            
            // Target value
            const targetText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetText.setAttribute('x', targetX + barWidth / 2);
            targetText.setAttribute('y', targetY - 10);
            targetText.setAttribute('text-anchor', 'middle');
            targetText.setAttribute('font-size', isFullscreen ? '24' : '20');
            targetText.setAttribute('font-weight', 'bold');
            targetText.setAttribute('fill', 'var(--target-color)');
            targetText.textContent = currentHourData.target;
            svg.appendChild(targetText);
            
            // Target label
            const targetLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLabel.setAttribute('x', targetX + barWidth / 2);
            targetLabel.setAttribute('y', padding.top + chartHeight + 25);
            targetLabel.setAttribute('text-anchor', 'middle');
            targetLabel.setAttribute('font-size', isFullscreen ? '16' : '14');
            targetLabel.setAttribute('fill', '#666');
            targetLabel.textContent = 'TARGET';
            svg.appendChild(targetLabel);
            
            // Add performance indicator
            const performance = currentHourData.target > 0 ? 
                Math.round((currentHourData.production / currentHourData.target) * 100) : 0;
            
            const perfText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            perfText.setAttribute('x', svgWidth / 2);
            perfText.setAttribute('y', padding.top - 10);
            perfText.setAttribute('text-anchor', 'middle');
            perfText.setAttribute('font-size', isFullscreen ? '20' : '18');
            perfText.setAttribute('font-weight', 'bold');
            perfText.setAttribute('fill', performance >= 100 ? 'var(--success-color)' : 'var(--danger-color)');
            perfText.textContent = `${performance}% of Target`;
            svg.appendChild(perfText);
        }

        // Function to show chart
        function showChart(type) {
            const cumulativeChart = document.getElementById('cumulative-chart');
            const hourlyChart = document.getElementById('hourly-chart');
            const dots = document.querySelectorAll('.chart-nav-dot');
            
            if (type === 'cumulative') {
                cumulativeChart.style.display = 'flex';
                hourlyChart.style.display = 'none';
                document.getElementById('chart-title').textContent = 'Production Progress';
                currentChartIndex = 0;
                dots[0].classList.add('active');
                dots[1].classList.remove('active');
            } else {
                cumulativeChart.style.display = 'none';
                hourlyChart.style.display = 'flex';
                document.getElementById('chart-title').textContent = 'Current Hour Performance';
                currentChartIndex = 1;
                dots[0].classList.remove('active');
                dots[1].classList.add('active');
            }
            
            updateDashboard();
        }

        // Function to toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('Error attempting to enable fullscreen:', err);
                });
            } else {
                document.exitFullscreen().catch(err => {
                    console.error('Error attempting to exit fullscreen:', err);
                });
            }
        }

        // Handle fullscreen change
        function handleFullscreenChange() {
            isFullscreen = !!document.fullscreenElement;
            if (isFullscreen) {
                body.classList.add('fullscreen-active');
                fullscreenButton.querySelector('span').textContent = 'Exit Fullscreen';
            } else {
                body.classList.remove('fullscreen-active');
                fullscreenButton.querySelector('span').textContent = 'Fullscreen';
            }
            
            // Redraw charts with new dimensions
            setTimeout(() => {
                updateDashboard();
            }, 100);
        }

        // Handle window resize
        function handleResize() {
            // Debounce resize events
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                updateDashboard();
            }, 250);
        }

        // Function to show no data message
        function showNoDataMessage() {
            document.getElementById('current-units').textContent = '0';
            document.getElementById('target-units').textContent = '0';
            document.getElementById('units-progress').textContent = '0%';
            document.getElementById('current-boxes').textContent = '0';
            document.getElementById('target-boxes').textContent = '0';
            document.getElementById('actual-cycle-time').textContent = '0';
            document.getElementById('target-cycle-time').textContent = '0';
            document.getElementById('supervisor-name').textContent = '-';
            document.getElementById('product-name').textContent = '-';
            document.getElementById('variant-chain').innerHTML = '-';
            
            const chartContainers = ['cumulative-chart', 'hourly-chart'];
            chartContainers.forEach(id => {
                const container = document.getElementById(id);
                container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;">No data available for selected filters</div>';
            });
            
            document.getElementById('batch-info-body').innerHTML = 
                '<tr><td colspan="5" style="text-align:center;padding:2rem;">No batch information available</td></tr>';
        }

        // Function to show error message
        function showError(message) {
            console.error(message);
            // You can implement a more user-friendly error display here
        }

        // Function to update date/time
        function updateDateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('current-time').textContent = timeStr;
            
            // Calculate current hour period
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            let periodHour, periodStart;
            if (currentMinute < 30) {
                periodHour = currentHour;
                periodStart = `${(currentHour - 1).toString().padStart(2, '0')}:30`;
            } else {
                periodHour = currentHour + 1;
                periodStart = `${currentHour.toString().padStart(2, '0')}:30`;
            }
            
            const periodEnd = `${periodHour.toString().padStart(2, '0')}:30`;
            document.getElementById('current-hour-period').textContent = periodEnd;
            
            // Calculate time remaining
            const targetMinutes = periodHour * 60 + 30;
            const currentMinutes = currentHour * 60 + currentMinute;
            const remainingMinutes = targetMinutes - currentMinutes;
            
            document.getElementById('time-remaining').textContent = `${remainingMinutes} MIN LEFT`;
        }

        // Function to update viewport dimensions (for debugging)
        function updateViewportDimensions() {
            // This function is for debugging purposes
            // You can remove it in production
        }

        // Function to start chart rotation
        function startChartRotation() {
            if (chartRotationInterval) {
                clearInterval(chartRotationInterval);
            }
            
            chartRotationInterval = setInterval(() => {
                currentChartIndex = (currentChartIndex + 1) % 2;
                const chartType = currentChartIndex === 0 ? 'cumulative' : 'hourly';
                showChart(chartType);
            }, CHART_ROTATION_INTERVAL);
        }

        // Setup chart navigation
        function setupChartNavigation() {
            const navDots = document.querySelectorAll('.chart-nav-dot');
            navDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    const chartType = this.getAttribute('data-chart');
                    showChart(chartType);
                    
                    // Reset rotation interval when manually clicked
                    if (chartRotationInterval) {
                        clearInterval(chartRotationInterval);
                        startChartRotation();
                    }
                });
            });
            
            // Start automatic rotation
            startChartRotation();
        }

        // Get elapsed break minutes
        function getElapsedBreakMinutes(variant) {
            const now = new Date();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            let totalElapsedBreakMinutes = 0;
            
            const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
                if (!breakStartStr || !breakEndStr || breakStartStr === '-' || breakEndStr === '-') return 0;
                
                const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
                const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
                
                const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
                const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
                
                // If break hasn't started yet, return 0
                if (currentTime < breakStartMinutes) return 0;
                
                // If break is in progress, return elapsed portion
                if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
                
                // If break is complete, return full duration
                return breakEndMinutes - breakStartMinutes;
            };
            
            // Check each break
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
            }
            
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
            }
            
            if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
                totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
            }
            
            return totalElapsedBreakMinutes;
        }

        // Initialize dashboard
        function initDashboard() {
            updateDateTime();
            updateViewportDimensions();
            setInterval(updateDateTime, 1000);

            // Event listeners
            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            // Initialize supervisor selection
            initSupervisorSelection();
            
            // Chart rotation navigation setup
            setupChartNavigation();
            
            // Initialize data
            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            // Fullscreen event listeners
            fullscreenButton.addEventListener('click', toggleFullscreen);
            window.addEventListener('resize', handleResize);
            
            // Fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        // Initialize the dashboard when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initDashboard);

        // Make sure we cleanup on page unload
        window.addEventListener('beforeunload', function() {
            // Clear all intervals to prevent memory leaks
            if (cycleInterval) clearInterval(cycleInterval);
            if (chartRotationInterval) clearInterval(chartRotationInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        });
    </script>
</body>
</html>
