<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <link rel="icon" href="data:,">
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        /* ===== CSS CUSTOM PROPERTIES ===== */
        :root {
            /* Primary Colors */
            --primary-color: #2c3e50;
            --secondary-color: #3B82F6;
            --success-color: #10B981;
            --warning-color: #F59E0B;
            --danger-color: #e74c3c;
            --light-color: #f3f4f6;
            --dark-color: #1e293b;
            
            /* Supervisor Colors */
            --supervisor-luthando: #F9E79F;
            --supervisor-apelele: #e6e6e6;
            --supervisor-siyabonga: #FADBD8;
            --supervisor-nosi: #D6EAF8;
            --supervisor-mvokwe: #D5F5E3;
            --supervisor-michaela: #F9E79F;
            
            /* Chart Colors */
            --production-color: #e74c3c;
            --target-color: #10B981;
            --current-indicator: #F59E0B;
            
            /* Variant Status Colors */
            --completed-variant: #D1E7DD;
            --current-variant: #FFF3CD;
            --upcoming-variant: #F8D7DA;
            
            /* UI Colors */
            --legend-bg: #f8fafc;
            --status-met: #D1E7DD;
            --status-missed: #FECDD3;
            --status-current: #FEF9C3;
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        /* ===== CSS RESET ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: var(--light-color);
            color: var(--primary-color);
            transition: background-color var(--transition-normal);
        }

        /* ===== DASHBOARD CONTAINER ===== */
        .dashboard-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            padding: clamp(0.5rem, 1vw, 1rem);
            transition: all var(--transition-normal);
        }

        .dashboard-container.fullscreen-mode {
            padding: clamp(0.25rem, 0.5vw, 0.5rem);
        }

        /* ===== HEADER STYLES ===== */
        .supervisor-color-banner {
            width: 100%;
            height: clamp(0.5rem, 1vh, 1.25rem);
            border-radius: 3px;
            margin-bottom: clamp(0.15rem, 0.3vh, 0.3rem);
            transition: height var(--transition-normal);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: clamp(0.5rem, 1vw, 1rem);
            padding-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
            margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
            min-height: fit-content;
            flex-shrink: 0;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: clamp(0.5rem, 1vw, 1rem);
        }

        .title {
            font-size: clamp(1.4rem, 2.2vw, 2.8rem);
            font-weight: bold;
            color: var(--primary-color);
            white-space: nowrap;
        }

        .controls-section {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: clamp(0.5rem, 1vw, 1rem);
        }

        .filter-container {
            display: flex;
            gap: clamp(0.25rem, 0.5vw, 0.5rem);
            flex-wrap: wrap;
        }

        .filter-select {
            padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            font-size: clamp(0.85rem, 1.1vw, 1.2rem);
            min-width: clamp(120px, 10vw, 180px);
            background-color: white;
            cursor: pointer;
            transition: border-color var(--transition-fast);
        }

        .filter-select:hover {
            border-color: #2563eb;
        }

        .filter-select:focus {
            outline: 2px solid var(--secondary-color);
            outline-offset: 2px;
        }

        .buttons-container {
            display: flex;
            gap: clamp(0.25rem, 0.5vw, 0.5rem);
            flex-wrap: wrap;
        }

        .supervisor-select-btn {
            background-color: var(--secondary-color);
            color: white;
            padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
            font-size: clamp(0.85rem, 1.1vw, 1.2rem);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            min-width: clamp(100px, 8vw, 140px);
            white-space: nowrap;
            transition: all var(--transition-fast);
        }

        .supervisor-select-btn:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .supervisor-select-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .supervisor-select-btn.filtered {
            background-color: var(--warning-color);
        }

        .fullscreen-button {
            background-color: #e2e8f0;
            color: var(--dark-color);
            padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
            font-size: clamp(0.85rem, 1.1vw, 1.2rem);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            white-space: nowrap;
            transition: all var(--transition-fast);
        }

        .fullscreen-button:hover {
            background-color: #cbd5e1;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .fullscreen-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .date-time {
            text-align: right;
            white-space: nowrap;
        }

        .time {
            font-size: clamp(1.2rem, 1.8vw, 2.2rem);
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        /* ===== LEGEND SECTION ===== */
        .legend-section {
            width: 100%;
            background-color: var(--legend-bg);
            padding: clamp(0.5rem, 1vh, 1rem) clamp(0.75rem, 1.25vw, 1.25rem);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: clamp(0.5rem, 1vw, 1rem);
            margin-bottom: clamp(0.5rem, 1vh, 1rem);
            border-radius: 0.5rem;
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .legend-container {
            display: flex;
            flex-wrap: wrap;
            gap: clamp(1rem, 3vw, 3rem);
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: clamp(1.5rem, 2.2vw, 2.5rem);
            height: clamp(1.5rem, 2.2vw, 2.5rem);
            margin-right: clamp(0.25rem, 0.5vw, 0.5rem);
            border-radius: 5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .legend-label {
            font-size: clamp(1rem, 1.4vw, 1.6rem);
            font-weight: 700;
            white-space: nowrap;
        }

        .current-hour-info {
            font-size: clamp(1rem, 1.4vw, 1.6rem);
            color: var(--secondary-color);
            font-weight: 700;
            white-space: nowrap;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* ===== CONTENT CONTAINER ===== */
        .content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            gap: clamp(0.5rem, 1vh, 1rem);
        }

        .charts-row {
            display: flex;
            flex-direction: row;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            gap: clamp(0.5rem, 1vh, 1rem);
        }

        .main-content {
            display: flex;
            flex-direction: column;
            width: 100%;
            flex-shrink: 0;
            overflow: visible;
        }

        /* ===== TOP ROW WITH SUPERVISOR AND METRICS ===== */
        .top-row {
            display: flex;
            gap: clamp(0.5rem, 1vw, 1rem);
            width: 100%;
            flex-shrink: 0;
            overflow: visible;
        }

        /* ===== SUPERVISOR INFO PANEL ===== */
        .supervisor-panel {
            flex: 0 0 clamp(250px, 25vw, 450px);
            background-color: var(--supervisor-mvokwe);
            border-radius: 12px;
            padding: clamp(0.75rem, 1.5vh, 1.5rem);
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: background-color var(--transition-normal);
        }

        .supervisor-name {
            font-size: clamp(1.2rem, 1.7vw, 2rem);
            font-weight: bold;
            margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
            color: var(--dark-color);
        }

        .product-name {
            font-size: clamp(1.1rem, 1.5vw, 1.8rem);
            color: var(--dark-color);
            margin-bottom: clamp(0.5rem, 1vh, 1rem);
        }

        .variant-sequence {
            display: flex;
            align-items: center;
            font-size: clamp(0.9rem, 1.2vw, 1.4rem);
            flex-wrap: wrap;
            gap: clamp(0.25rem, 0.5vw, 0.5rem);
            margin-top: auto;
        }

        .variant-item {
            padding: clamp(0.35rem, 0.75vh, 0.75rem) clamp(0.5rem, 1vw, 1rem);
            border-radius: 8px;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-width: clamp(60px, 7vw, 100px);
            transition: all var(--transition-fast);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .variant-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        .variant-item.completed {
            background-color: var(--completed-variant);
            color: var(--dark-color);
        }

        .variant-item.current {
            background-color: var(--current-variant);
            color: var(--dark-color);
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 1px 8px rgba(245, 158, 11, 0.4); }
            100% { box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        }

        .variant-item.upcoming {
            background-color: var(--upcoming-variant);
            color: var(--dark-color);
        }

        .arrow-right {
            margin: 0 clamp(0.1rem, 0.25vw, 0.25rem);
            font-size: clamp(1.1rem, 1.45vw, 1.7rem);
            color: var(--dark-color);
        }

        /* ===== METRICS CARDS ===== */
        .metrics-container {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: clamp(0.5rem, 1vw, 1rem);
        }

        .metric-card {
            flex: 1 1 clamp(150px, 15vw, 300px);
            min-width: clamp(120px, 15vw, 200px);
            background-color: white;
            border-radius: 12px;
            padding: clamp(0.75rem, 1.5vh, 1.5rem);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .metric-title {
            font-size: clamp(1.1rem, 1.5vw, 1.8rem);
            font-weight: bold;
            margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
            color: var(--primary-color);
            text-align: center;
        }

        .metric-value {
            font-size: clamp(1.8rem, 2.8vw, 3.4rem);
            font-weight: bold;
            margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .metric-subvalue {
            font-size: clamp(0.9rem, 1.3vw, 1.6rem);
            text-align: center;
            color: #6b7280;
        }

        .current-value {
            color: var(--production-color);
        }

        .target-value {
            color: var(--target-color);
        }

        /* ===== CHARTS SECTION ===== */
        .charts-container {
            width: 100%;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            position: relative;
            background-color: white;
            border-radius: 12px;
            padding: clamp(0.75rem, 1.5vh, 1.5rem);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .chart-title {
            font-size: clamp(1.2rem, 1.7vw, 2rem);
            font-weight: 600;
            margin-bottom: clamp(0.5rem, 1vh, 1rem);
            color: var(--primary-color);
            flex-shrink: 0;
            text-align: center;
        }

        .chart-area {
            flex: 1;
            position: relative;
            min-height: 0;
            overflow: hidden;
        }

        .chart {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 1;
            transition: opacity var(--transition-slow);
        }

        .chart.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .chart-nav {
            display: flex;
            justify-content: center;
            gap: clamp(0.5rem, 1vw, 1rem);
            margin-top: clamp(0.5rem, 1vh, 1rem);
        }

        .chart-nav-dot {
            width: clamp(0.8rem, 1.3vw, 1.2rem);
            height: clamp(0.8rem, 1.3vw, 1.2rem);
            border-radius: 50%;
            background-color: #cbd5e1;
            cursor: pointer;
            transition: all var(--transition-normal);
        }

        .chart-nav-dot:hover {
            transform: scale(1.2);
            background-color: #94a3b8;
        }

        .chart-nav-dot.active {
            background-color: var(--secondary-color);
            transform: scale(1.2);
        }

        /* ===== BATCH INFO SECTION ===== */
        .batch-info-section {
            flex: 0 0 clamp(375px, 32vw, 650px);
            background-color: white;
            border-radius: 12px;
            padding: clamp(0.75rem, 1.5vh, 1.5rem);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: 100%;
        }

        .batch-info-title {
            font-size: clamp(1.2rem, 1.7vw, 2rem);
            font-weight: bold;
            margin-bottom: clamp(0.75rem, 1.5vh, 1.5rem);
            color: var(--primary-color);
            text-align: center;
        }

        .batch-info-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        .batch-info-table th {
            background-color: var(--primary-color);
            color: white;
            font-size: clamp(0.9rem, 1.3vw, 1.6rem);
            padding: clamp(0.5rem, 1vh, 1rem) clamp(0.25rem, 0.5vw, 0.5rem);
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .batch-info-table td {
            font-size: clamp(0.85rem, 1.2vw, 1.5rem);
            padding: clamp(0.4rem, 0.8vh, 0.8rem) clamp(0.25rem, 0.5vw, 0.5rem);
            border-bottom: 1px solid #e2e8f0;
        }

        .batch-info-table tr:nth-child(even) {
            background-color: #f8fafc;
        }

        .batch-info-table tr:hover {
            background-color: #e9f5fd;
        }

        .batch-info-table tr.current {
            background-color: var(--current-variant);
        }

        .batch-info-table tr.supervisor-header td {
            font-weight: bold;
            text-transform: uppercase;
            padding: clamp(0.6rem, 1.2vh, 1.2rem) clamp(0.25rem, 0.5vw, 0.5rem);
        }

        .batch-info-table tr.product-header td {
            font-weight: 600;
            background-color: #f3f4f6;
            padding: clamp(0.5rem, 1vh, 1rem) clamp(0.25rem, 0.5vw, 0.5rem);
        }

        .batch-number {
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        /* ===== FOOTER ===== */
        .footer {
            margin-top: clamp(0.25rem, 0.5vh, 0.5rem);
            font-size: clamp(0.85rem, 1.1vw, 1.3rem);
            color: var(--dark-color);
            width: 100%;
            flex-shrink: 0;
        }

        .update-info {
            text-align: left;
            opacity: 0.7;
        }

        /* ===== SUPERVISOR SELECTION MODAL ===== */
        .supervisor-select-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            animation: fadeIn var(--transition-normal);
        }

        @keyframes fadeIn {
            from {opacity: 0}
            to {opacity: 1}
        }

        .supervisor-select-content {
            position: relative;
            background-color: #fefefe;
            margin: 10vh auto;
            padding: 0;
            border-radius: 8px;
            width: clamp(300px, 80vw, 600px);
            max-height: 80vh;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            animation: slideIn var(--transition-normal);
            display: flex;
            flex-direction: column;
        }

        @keyframes slideIn {
            from {transform: translateY(-50px); opacity: 0}
            to {transform: translateY(0); opacity: 1}
        }

        .supervisor-select-header {
            padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .supervisor-select-header h3 {
            margin: 0;
            font-size: clamp(1.3rem, 1.7vw, 1.9rem);
            color: var(--dark-color);
        }

        .supervisor-select-close {
            color: #aaa;
            font-size: clamp(1.8rem, 2.5vw, 2.8rem);
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: color var(--transition-fast);
        }

        .supervisor-select-close:hover {
            color: var(--dark-color);
        }

        .supervisor-select-body {
            padding: clamp(1rem, 2vw, 2rem);
            overflow-y: auto;
            flex: 1;
        }

        .supervisor-checkboxes {
            display: flex;
            flex-direction: column;
            gap: clamp(0.5rem, 1vh, 1rem);
        }

        .supervisor-checkbox-item {
            display: flex;
            align-items: center;
            padding: clamp(0.5rem, 1vh, 1rem);
            border-radius: 6px;
            transition: background-color var(--transition-fast);
        }

        .supervisor-checkbox-item:hover {
            background-color: #f8fafc;
        }

        .supervisor-checkbox-item input[type="checkbox"] {
            width: clamp(18px, 1.7vw, 22px);
            height: clamp(18px, 1.7vw, 22px);
            margin-right: clamp(0.5rem, 1vw, 1rem);
            cursor: pointer;
        }

        .supervisor-checkbox-item label {
            font-size: clamp(1.1rem, 1.4vw, 1.6rem);
            font-weight: 500;
            cursor: pointer;
            flex: 1;
        }

        .supervisor-select-footer {
            padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
            border-top: 1px solid #f0f0f0;
            display: flex;
            justify-content: flex-end;
            gap: clamp(0.5rem, 1vw, 1rem);
            flex-shrink: 0;
        }

        .supervisor-select-btn.secondary {
            background-color: #e2e8f0;
            color: var(--dark-color);
        }

        .supervisor-select-btn.secondary:hover {
            background-color: #cbd5e1;
        }

        .supervisor-select-btn.primary {
            background-color: var(--secondary-color);
            color: white;
        }

        /* ===== LOADING STATES ===== */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6b7280;
            font-size: clamp(0.9rem, 1.2vw, 1.4rem);
        }

        .loading::after {
            content: '';
            animation: ellipsis 1.5s infinite;
        }

        @keyframes ellipsis {
            0% { content: ''; }
            33% { content: '.'; }
            66% { content: '..'; }
            100% { content: '...'; }
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media screen and (min-width: 2000px) {
            .chart-title {
                font-size: clamp(1.4rem, 2vw, 2.4rem);
            }
            
            .legend-label {
                font-size: clamp(1.2rem, 1.6vw, 1.8rem);
            }
            
            .current-hour-info {
                font-size: clamp(1.2rem, 1.6vw, 1.8rem);
            }
        }

        @media screen and (max-width: 1200px) {
            .charts-row {
                flex-direction: column;
            }
            
            .top-row {
                flex-direction: column;
            }
            
            .supervisor-panel {
                flex: 0 0 auto;
                width: 100%;
            }
            
            .metrics-container {
                width: 100%;
            }
            
            .batch-info-section {
                flex: 0 0 auto;
                width: 100%;
                max-height: 300px;
            }
        }

        @media screen and (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .controls-section {
                width: 100%;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .filter-container {
                width: 100%;
            }
            
            .filter-select {
                flex: 1;
            }
            
            .buttons-container {
                width: 100%;
            }
            
            .date-time {
                align-self: flex-end;
                margin-top: clamp(0.5rem, 1vh, 1rem);
            }
        }

        @media screen and (max-height: 768px) and (orientation: landscape) {
            .dashboard-container {
                padding: clamp(0.25rem, 0.5vw, 0.5rem);
            }
            
            .header {
                padding-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
                margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
            }
            
            .legend-section {
                margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
                padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 1vw, 1rem);
            }
        }

        /* ===== UTILITY CLASSES ===== */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        .fade-in {
            animation: fadeIn var(--transition-normal);
        }

        .fade-out {
            animation: fadeOut var(--transition-normal);
        }

        @keyframes fadeOut {
            from {opacity: 1}
            to {opacity: 0}
        }

        /* ===== ACCESSIBILITY IMPROVEMENTS ===== */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        :focus-visible {
            outline: 2px solid var(--secondary-color);
            outline-offset: 2px;
        }

        /* ===== HIGH CONTRAST MODE ===== */
        @media (prefers-contrast: high) {
            :root {
                --primary-color: #000000;
                --secondary-color: #0066cc;
                --production-color: #cc0000;
                --target-color: #008800;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container" role="main" aria-label="Production Dashboard">
        <!-- Supervisor color banner -->
        <div class="supervisor-color-banner" aria-hidden="true"></div>
        
        <!-- Header Section -->
        <header class="header">
            <div class="title-section">
                <h1 class="title">Sinapi Secondary Production Dashboard</h1>
            </div>
            
            <div class="controls-section">
                <div class="filter-container">
                    <select id="filter-type-select" class="filter-select" aria-label="Filter type">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select" aria-label="Filter value">
                        <option value="all">All</option>
                    </select>
                </div>
                
                <div class="buttons-container">
                    <button id="supervisor-select-btn" class="supervisor-select-btn" aria-label="Select supervisors">
                        Select Supervisors
                    </button>
                    <button id="fullscreen-button" class="fullscreen-button" aria-label="Toggle fullscreen">Fullscreen</button>
                </div>
            </div>
            
            <div class="date-time">
                <time class="time" id="current-time">Loading...</time>
            </div>
        </header>
        
        <!-- Legend Section -->
        <section class="legend-section" aria-label="Chart legend">
            <div class="legend-container">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--production-color);" aria-hidden="true"></div>
                    <div class="legend-label">PRODUCTION</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--target-color);" aria-hidden="true"></div>
                    <div class="legend-label">TARGET</div>
                </div>
            </div>
            <div class="current-hour-info" id="current-hour-info" aria-live="polite">CURRENT HOUR: --:-- (-- MIN LEFT)</div>
        </section>
        
        <!-- Content wrapper for main and batch info -->
        <div class="content">
            <!-- Main content area (top row section only) -->
            <div class="main-content">
                <!-- Top Row: Supervisor + Metrics -->
                <div class="top-row">
                    <!-- Supervisor Panel -->
                    <section class="supervisor-panel" aria-label="Supervisor information">
                        <div class="supervisor-name" id="supervisor-name">SUPERVISOR: Loading...</div>
                        <div class="product-name" id="product-name">PRODUCT: Loading...</div>
                        
                        <div class="variant-sequence" id="variant-sequence" aria-label="Variant sequence">
                            <div class="loading">Loading variants</div>
                        </div>
                    </section>
                    
                    <!-- Metrics Container -->
                    <section class="metrics-container" aria-label="Production metrics">
                        <!-- Units (renamed from Progress) -->
                        <div class="metric-card">
                            <h3 class="metric-title">UNITS</h3>
                            <div class="metric-value">
                                <span class="current-value" id="current-units">0</span>/<span class="target-value" id="target-units">0</span>
                            </div>
                            <div class="metric-subvalue" id="progress-percentage">0%</div>
                        </div>
                        
                        <!-- Boxes -->
                        <div class="metric-card">
                            <h3 class="metric-title">BOXES</h3>
                            <div class="metric-value">
                                <span class="current-value" id="current-boxes">0</span>/<span class="target-value" id="target-boxes">0</span>
                            </div>
                            <div class="metric-subvalue">completed</div>
                        </div>
                        
                        <!-- Cycle Time -->
                        <div class="metric-card">
                            <h3 class="metric-title">CYCLE TIME</h3>
                            <div class="metric-value">
                                <span class="current-value" id="actual-cycle-time">0</span>/<span class="target-value" id="target-cycle-time">0</span>
                            </div>
                            <div class="metric-subvalue">seconds</div>
                        </div>
                    </section>
                </div>
            </div>
            
            <!-- Charts Row: Charts + Batch Info -->
            <div class="charts-row">
                <!-- Charts Container -->
                <section class="charts-container" aria-label="Production charts">
                    <h2 class="chart-title" id="chart-title">Production Progress</h2>
                    <div class="chart-area">
                        <div class="chart" id="cumulative-chart" role="img" aria-label="Cumulative production chart"></div>
                        <div class="chart hidden" id="hourly-chart" role="img" aria-label="Hourly production chart"></div>
                    </div>
                    <nav class="chart-nav" aria-label="Chart navigation">
                        <button class="chart-nav-dot active" data-chart="cumulative" aria-label="View cumulative chart" aria-pressed="true"></button>
                        <button class="chart-nav-dot" data-chart="hourly" aria-label="View hourly chart" aria-pressed="false"></button>
                    </nav>
                </section>
                
                <!-- Batch Information Panel -->
                <section class="batch-info-section" aria-label="Batch information">
                    <h2 class="batch-info-title">BATCH INFORMATION</h2>
                    <table class="batch-info-table" id="batch-info-table">
                        <thead id="batch-info-thead">
                            <!-- Table headers will be dynamically generated -->
                        </thead>
                        <tbody id="batch-info-tbody">
                            <!-- Batch information will be populated dynamically -->
                            <tr>
                                <td colspan="5" class="loading">Loading batch information</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="footer">
            <div class="update-info" id="last-update">Last updated: Never</div>
        </footer>
        
        <!-- Supervisor Selection Modal -->
        <div id="supervisor-select-modal" class="supervisor-select-modal" role="dialog" aria-modal="true" aria-labelledby="supervisor-modal-title">
            <div class="supervisor-select-content">
                <div class="supervisor-select-header">
                    <h3 id="supervisor-modal-title">Select Supervisors to Display</h3>
                    <button class="supervisor-select-close" aria-label="Close modal">&times;</button>
                </div>
                <div class="supervisor-select-body">
                    <div id="supervisor-checkboxes" class="supervisor-checkboxes" role="group" aria-labelledby="supervisor-modal-title">
                        <!-- Checkboxes will be added dynamically -->
                    </div>
                </div>
                <div class="supervisor-select-footer">
                    <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                    <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                    <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        // ===== CONFIGURATION =====
        const CONFIG = {
            DATA_URL: 'https://opssinapi.github.io/production-dashboard/data.json',
            UPDATE_INTERVAL: 30000, // 30 seconds
            CYCLE_INTERVAL: 20000, // 20 seconds
            CHART_ROTATION_INTERVAL: 10000, // 10 seconds
            DEBOUNCE_DELAY: 250, // 250ms for resize events
            CACHE_EXPIRY: 5000, // 5 seconds for data cache
        };

        // ===== STATE MANAGEMENT =====
        const state = {
            productionData: { variants: [], supervisors: [] },
            selectedFilterType: 'supervisor',
            selectedFilterValue: 'all',
            selectedHour: 'current',
            lastUpdateTime: null,
            isLoading: true,
            isFullscreen: false,
            selectedSupervisors: [],
            supervisorFilterActive: false,
            currentProduct: null,
            currentSupervisor: null,
            currentProductVariants: [],
            currentVariantKey: null,
            productSupervisorGroups: {},
            cycleIndex: 0,
            currentChartIndex: 0,
            cache: new Map(),
        };

        // ===== INTERVALS MANAGEMENT =====
        const intervals = {
            countdown: null,
            cycle: null,
            chartRotation: null,
            dataUpdate: null,
            time: null,
        };

        // ===== DOM REFERENCES CACHE =====
        const elements = {};

        // ===== UTILITY FUNCTIONS =====
        const utils = {
            // Debounce function for performance optimization
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // Cache management
            getCached(key) {
                const cached = state.cache.get(key);
                if (cached && Date.now() - cached.timestamp < CONFIG.CACHE_EXPIRY) {
                    return cached.data;
                }
                return null;
            },

            setCache(key, data) {
                state.cache.set(key, { data, timestamp: Date.now() });
            },

            // Format time string to minutes
            timeToMinutes(timeStr) {
                if (!timeStr) return 0;
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            },

            // Get supervisor color
            getSupervisorColor(supervisorName) {
                const colorMap = {
                    'Luthando': 'var(--supervisor-luthando)',
                    'Apelele': 'var(--supervisor-apelele)',
                    'Siyabonga': 'var(--supervisor-siyabonga)',
                    'Nosi': 'var(--supervisor-nosi)',
                    'Mvokwe': 'var(--supervisor-mvokwe)',
                    'Michaela': 'var(--supervisor-michaela)'
                };
                return colorMap[supervisorName] || '#e2e8f0';
            },

            // Extract product from variant ID
            extractProductFromVariant(variantId) {
                if (!variantId) return '';
                
                if (variantId.includes('-')) {
                    const parts = variantId.split('-');
                    if (parts.length > 2) {
                        return parts.slice(0, -1).join('-');
                    } else if (parts.length === 2) {
                        return parts[0];
                    }
                }

                const parts = variantId.split(' ');
                if (parts.length === 1) return variantId;
                if (parts.length === 2) return parts[0];
                
                const match = variantId.match(/^([A-Za-z\s]+)[\d]/);
                if (match && match[1]) {
                    return match[1].trim();
                }
                
                return parts[0];
            },

            // Clear all intervals
            clearAllIntervals() {
                Object.values(intervals).forEach(interval => {
                    if (interval) clearInterval(interval);
                });
            }
        };

        // ===== DOM HELPERS =====
        const dom = {
            // Cache DOM elements
            cacheElements() {
                const selectors = {
                    dashboardContainer: '.dashboard-container',
                    supervisorPanel: '.supervisor-panel',
                    supervisorColorBanner: '.supervisor-color-banner',
                    fullscreenButton: '#fullscreen-button',
                    filterTypeSelect: '#filter-type-select',
                    filterValueSelect: '#filter-value-select',
                    supervisorSelectBtn: '#supervisor-select-btn',
                    supervisorSelectModal: '#supervisor-select-modal',
                    supervisorSelectClose: '.supervisor-select-close',
                    applySupSelection: '#apply-supervisor-selection',
                    selectAllSupervisors: '#select-all-supervisors',
                    deselectAllSupervisors: '#deselect-all-supervisors',
                    supervisorCheckboxes: '#supervisor-checkboxes',
                    currentTime: '#current-time',
                    currentHourInfo: '#current-hour-info',
                    lastUpdate: '#last-update',
                    supervisorName: '#supervisor-name',
                    productName: '#product-name',
                    variantSequence: '#variant-sequence',
                    currentUnits: '#current-units',
                    targetUnits: '#target-units',
                    progressPercentage: '#progress-percentage',
                    currentBoxes: '#current-boxes',
                    targetBoxes: '#target-boxes',
                    actualCycleTime: '#actual-cycle-time',
                    targetCycleTime: '#target-cycle-time',
                    chartTitle: '#chart-title',
                    cumulativeChart: '#cumulative-chart',
                    hourlyChart: '#hourly-chart',
                    batchInfoThead: '#batch-info-thead',
                    batchInfoTbody: '#batch-info-tbody',
                };

                Object.entries(selectors).forEach(([key, selector]) => {
                    elements[key] = document.querySelector(selector);
                });

                // Cache chart nav dots
                elements.chartNavDots = document.querySelectorAll('.chart-nav-dot');
            },

            // Update text content safely
            updateText(element, text) {
                if (element) element.textContent = text;
            },

            // Toggle class safely
            toggleClass(element, className, condition) {
                if (element) {
                    if (condition) {
                        element.classList.add(className);
                    } else {
                        element.classList.remove(className);
                    }
                }
            }
        };

        // ===== DATA MANAGEMENT =====
        const dataManager = {
            // Fetch production data
            async fetchProductionData() {
                try {
                    const cacheBuster = '?_=' + new Date().getTime();
                    const response = await fetch(CONFIG.DATA_URL + cacheBuster);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data) {
                        throw new Error('Empty data received from data.json');
                    }
                    
                    const transformedData = this.transformDataFormat(data);
                    
                    if (!transformedData.variants || !Array.isArray(transformedData.variants) || 
                        !transformedData.supervisors || !Array.isArray(transformedData.supervisors)) {
                        throw new Error('Failed to transform data into the required format');
                    }
                    
                    if (!state.lastUpdateTime || state.lastUpdateTime !== transformedData.timestamp) {
                        state.productionData = transformedData;
                        state.lastUpdateTime = transformedData.timestamp;
                        state.productionData.originalData = data;
                        
                        dom.updateText(elements.lastUpdate, 'Last updated: ' + transformedData.timestamp);
                        
                        this.processProductSupervisorGroups();
                        
                        if (state.selectedSupervisors.length === 0) {
                            state.selectedSupervisors = state.productionData.supervisors.map(supervisor => supervisor.name);
                            this.loadSelectedSupervisors();
                        }
                        
                        filterManager.updateFilterValueDropdown();
                        dashboardManager.updateDashboard();
                    }
                    
                    state.isLoading = false;
                } catch (error) {
                    console.error('Fetch failed:', error);
                    state.isLoading = false;
                    dashboardManager.showLoadingOrError(`Failed to load data: ${error.message}`);
                }
            },

            // Transform data format
            transformDataFormat(newData) {
                const transformedData = {
                    variants: [],
                    supervisors: [],
                    timestamp: newData.metadata.timestamp || new Date().toISOString()
                };
                
                if (newData.production && Array.isArray(newData.production)) {
                    // Transform production items to variants
                    newData.production.forEach(item => {
                        const transformedVariant = {
                            variant: item.id,
                            "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                            cycleTime: item.variant.cycleTime,
                            actualCycleTime: item.variant.actualCycleTime,
                            "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                            "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                            dailyBoxTarget: item.targets.boxes,
                            currentBoxTotal: item.actual.boxes,
                            hourlyTargets: [],
                            hourlyProduction: []
                        };
                        
                        if (item.timeline && Array.isArray(item.timeline)) {
                            item.timeline.forEach(hour => {
                                transformedVariant.hourlyTargets.push({
                                    hour: hour.hour,
                                    target: hour.target
                                });
                                
                                transformedVariant.hourlyProduction.push({
                                    hour: hour.hour,
                                    production: hour.actual
                                });
                            });
                        }
                        
                        transformedData.variants.push(transformedVariant);
                    });
                    
                    // Process supervisors from the summary section
                    if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                        newData.summary.supervisors.forEach(supervisor => {
                            const transformedSupervisor = {
                                name: supervisor.name,
                                variants: {}
                            };
                            
                            if (supervisor.variants && Array.isArray(supervisor.variants)) {
                                supervisor.variants.forEach(variantId => {
                                    const prodItem = newData.production.find(p => p.id === variantId);
                                    
                                    if (prodItem) {
                                        const assignment = prodItem.supervisors.find(s => s.id === supervisor.id);
                                        
                                        if (assignment) {
                                            transformedSupervisor.variants[variantId] = {
                                                variantStartTime: assignment.startTime,
                                                variantEndTime: assignment.endTime,
                                                dailyTarget: assignment.target,
                                                currentTotal: assignment.production,
                                                variance: assignment.production - assignment.target,
                                                percentage: assignment.progress
                                            };
                                        } else {
                                            transformedSupervisor.variants[variantId] = {
                                                variantStartTime: prodItem.supervisors[0]?.startTime || "07:30",
                                                variantEndTime: prodItem.supervisors[0]?.endTime || "18:30",
                                                dailyTarget: prodItem.targets.daily,
                                                currentTotal: prodItem.actual.total,
                                                variance: prodItem.actual.total - prodItem.targets.daily,
                                                percentage: prodItem.actual.progress
                                            };
                                        }
                                    }
                                });
                            }
                            
                            transformedData.supervisors.push(transformedSupervisor);
                        });
                    }
                } else if (newData.variants && Array.isArray(newData.variants)) {
                    transformedData.variants = newData.variants;
                    transformedData.supervisors = newData.supervisors;
                }
                
                return transformedData;
            },

            // Process product-supervisor groups
            processProductSupervisorGroups() {
                state.productSupervisorGroups = {};
                
                state.productionData.supervisors.forEach(supervisor => {
                    if (!supervisor.variants) return;
                    
                    const productVariants = {};
                    
                    Object.keys(supervisor.variants).forEach(variantKey => {
                        const product = utils.extractProductFromVariant(variantKey);
                        
                        if (!productVariants[product]) {
                            productVariants[product] = [];
                        }
                        
                        const variantData = state.productionData.variants.find(v => v.variant === variantKey);
                        
                        if (variantData) {
                            productVariants[product].push({
                                variantKey,
                                variantData,
                                supervisorVariant: supervisor.variants[variantKey]
                            });
                        }
                    });
                    
                    Object.keys(productVariants).forEach(product => {
                        const group = `${supervisor.name}:${product}`;
                        
                        const sortedVariants = productVariants[product].sort((a, b) => {
                            const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                            const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                            
                            return utils.timeToMinutes(timeA) - utils.timeToMinutes(timeB);
                        });
                        
                        state.productSupervisorGroups[group] = {
                            supervisor: supervisor.name,
                            product,
                            variants: sortedVariants.map(v => v.variantData),
                            supervisorData: supervisor
                        };
                    });
                });
            },

            // Load selected supervisors from localStorage
            loadSelectedSupervisors() {
                const stored = localStorage.getItem('selectedSupervisors');
                if (stored) {
                    try {
                        state.selectedSupervisors = JSON.parse(stored);
                        
                        if (state.productionData && state.productionData.supervisors) {
                            const validSupervisors = state.productionData.supervisors.map(s => s.name);
                            state.selectedSupervisors = state.selectedSupervisors.filter(s => validSupervisors.includes(s));
                            
                            if (state.selectedSupervisors.length === 0) {
                                state.selectedSupervisors = validSupervisors;
                            }
                        }
                        
                        state.supervisorFilterActive = state.selectedSupervisors.length < state.productionData.supervisors.length;
                        
                        if (state.supervisorFilterActive) {
                            dom.updateText(
                                elements.supervisorSelectBtn, 
                                `Supervisors (${state.selectedSupervisors.length}/${state.productionData.supervisors.length})`
                            );
                            dom.toggleClass(elements.supervisorSelectBtn, 'filtered', true);
                        }
                    } catch (e) {
                        console.error('Error parsing stored supervisors:', e);
                        if (state.productionData && state.productionData.supervisors) {
                            state.selectedSupervisors = state.productionData.supervisors.map(s => s.name);
                        }
                    }
                }
            }
        };

        // ===== FILTER MANAGEMENT =====
        const filterManager = {
            // Update filter value dropdown
            updateFilterValueDropdown() {
                const currentValue = elements.filterValueSelect.value;
                
                // Clear existing options (except 'all')
                while (elements.filterValueSelect.options.length > 1) {
                    elements.filterValueSelect.remove(1);
                }
                
                if (state.selectedFilterType === 'supervisor' && state.productionData.supervisors?.length > 0) {
                    state.productionData.supervisors.forEach(supervisor => {
                        const option = document.createElement('option');
                        option.value = supervisor.name;
                        option.textContent = supervisor.name;
                        elements.filterValueSelect.appendChild(option);
                    });
                } else if (state.selectedFilterType === 'product') {
                    const uniqueProducts = new Set();
                    
                    Object.keys(state.productSupervisorGroups).forEach(key => {
                        const group = state.productSupervisorGroups[key];
                        uniqueProducts.add(group.product);
                    });
                    
                    uniqueProducts.forEach(product => {
                        const option = document.createElement('option');
                        option.value = product;
                        option.textContent = product;
                        elements.filterValueSelect.appendChild(option);
                    });
                } else if (state.selectedFilterType === 'variant' && state.productionData.variants?.length > 0) {
                    const uniqueVariants = new Set(state.productionData.variants.map(v => v.variant));
                    uniqueVariants.forEach(variantName => {
                        const option = document.createElement('option');
                        option.value = variantName;
                        option.textContent = variantName;
                        elements.filterValueSelect.appendChild(option);
                    });
                }
                
                elements.filterValueSelect.value = Array.from(elements.filterValueSelect.options).some(opt => opt.value === currentValue) 
                    ? currentValue 
                    : 'all';
                    
                state.selectedFilterValue = elements.filterValueSelect.value;
            }
        };

        // ===== SUPERVISOR MANAGEMENT =====
        const supervisorManager = {
            // Initialize supervisor selection
            initSupervisorSelection() {
                // Open modal
                elements.supervisorSelectBtn.addEventListener('click', () => {
                    this.updateSupervisorCheckboxes();
                    elements.supervisorSelectModal.style.display = 'block';
                });
                
                // Close modal
                elements.supervisorSelectClose.addEventListener('click', () => {
                    elements.supervisorSelectModal.style.display = 'none';
                });
                
                // Close modal on outside click
                window.addEventListener('click', (event) => {
                    if (event.target === elements.supervisorSelectModal) {
                        elements.supervisorSelectModal.style.display = 'none';
                    }
                });
                
                // Apply selection
                elements.applySupSelection.addEventListener('click', () => {
                    this.applySupervisorSelection();
                    elements.supervisorSelectModal.style.display = 'none';
                });
                
                // Select all
                elements.selectAllSupervisors.addEventListener('click', () => {
                    const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                });
                
                // Deselect all
                elements.deselectAllSupervisors.addEventListener('click', () => {
                    const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                });
            },

            // Update supervisor checkboxes
            updateSupervisorCheckboxes() {
                elements.supervisorCheckboxes.innerHTML = '';
                
                if (!state.productionData || !state.productionData.supervisors || state.productionData.supervisors.length === 0) {
                    elements.supervisorCheckboxes.innerHTML = '<p>No supervisors available</p>';
                    return;
                }
                
                state.productionData.supervisors.forEach(supervisor => {
                    const item = document.createElement('div');
                    item.className = 'supervisor-checkbox-item';
                    
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'legend-color';
                    colorDiv.style.backgroundColor = utils.getSupervisorColor(supervisor.name);
                    colorDiv.style.width = '16px';
                    colorDiv.style.height = '16px';
                    item.appendChild(colorDiv);
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'supervisor-checkbox';
                    checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
                    checkbox.value = supervisor.name;
                    checkbox.checked = state.selectedSupervisors.includes(supervisor.name);
                    
                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = supervisor.name;
                    
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    elements.supervisorCheckboxes.appendChild(item);
                });
            },

            // Apply supervisor selection
            applySupervisorSelection() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                state.selectedSupervisors = [];
                
                checkboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        state.selectedSupervisors.push(checkbox.value);
                    }
                });
                
                localStorage.setItem('selectedSupervisors', JSON.stringify(state.selectedSupervisors));
                
                state.supervisorFilterActive = state.selectedSupervisors.length < state.productionData.supervisors.length;
                
                if (state.supervisorFilterActive) {
                    dom.updateText(
                        elements.supervisorSelectBtn,
                        `Supervisors (${state.selectedSupervisors.length}/${state.productionData.supervisors.length})`
                    );
                    dom.toggleClass(elements.supervisorSelectBtn, 'filtered', true);
                } else {
                    dom.updateText(elements.supervisorSelectBtn, 'Select Supervisors');
                    dom.toggleClass(elements.supervisorSelectBtn, 'filtered', false);
                }
                
                dashboardManager.updateDashboard();
            }
        };

        // ===== TIME MANAGEMENT =====
        const timeManager = {
            // Update date and time
            updateDateTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                dom.updateText(elements.currentTime, timeString);
                this.updateCurrentHourInfo();
                
                // Check if we need to update dashboard based on time changes
                if (state.currentProductVariants && state.currentProductVariants.length > 1) {
                    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                    let needsUpdate = false;
                    
                    state.currentProductVariants.forEach(variant => {
                        const supervisor = state.productionData.supervisors.find(s => s.name === state.currentSupervisor);
                        const supervisorVariant = supervisor?.variants[variant.variant];
                        
                        if (!supervisorVariant) return;
                        
                        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                        
                        if (!startTimeStr || !endTimeStr) return;
                        
                        const startTimeMinutes = utils.timeToMinutes(startTimeStr);
                        const endTimeMinutes = utils.timeToMinutes(endTimeStr);
                        
                        if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                            needsUpdate = true;
                        }
                    });
                    
                    if (needsUpdate) {
                        dashboardManager.updateDashboard();
                    }
                }
            },

            // Update current hour info
            updateCurrentHourInfo() {
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                
                const nextHourMinute = 30;
                const nextHour = currentMinute < nextHourMinute ? currentHour : currentHour + 1;
                
                let minutesRemaining;
                if (currentMinute < nextHourMinute) {
                    minutesRemaining = nextHourMinute - currentMinute;
                } else {
                    minutesRemaining = (60 - currentMinute) + nextHourMinute;
                }
                
                const hourStr = currentMinute < 30 ? 
                    `${currentHour.toString().padStart(2, '0')}:30` : 
                    `${(currentHour + 1).toString().padStart(2, '0')}:30`;
                
                dom.updateText(
                    elements.currentHourInfo,
                    `CURRENT HOUR: ${hourStr} (${minutesRemaining} MIN LEFT)`
                );
            },

            // Calculate elapsed break minutes
            calculateElapsedBreakMinutes(variant, startTimeStr, now) {
                let totalElapsedBreakMinutes = 0;
                const currentTime = now.getHours() * 60 + now.getMinutes();
                
                const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
                    if (!breakStartStr || !breakEndStr) return 0;
                    if (breakStartStr === "-" || breakEndStr === "-") return 0;
                    
                    const breakStartMinutes = utils.timeToMinutes(breakStartStr);
                    const breakEndMinutes = utils.timeToMinutes(breakEndStr);
                    
                    if (currentTime < breakStartMinutes) return 0;
                    if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
                    
                    return breakEndMinutes - breakStartMinutes;
                };
                
                if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
                    totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
                }
                
                if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
                    totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
                }
                
                if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
                    variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
                    totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
                }
                
                return totalElapsedBreakMinutes;
            }
        };

        // ===== CHART MANAGEMENT =====
        const chartManager = {
            // Setup chart navigation
            setupChartNavigation() {
                elements.chartNavDots.forEach(dot => {
                    dot.addEventListener('click', function() {
                        const chartType = this.getAttribute('data-chart');
                        chartManager.showChart(chartType);
                        
                        if (intervals.chartRotation) {
                            clearInterval(intervals.chartRotation);
                            chartManager.startChartRotation();
                        }
                    });
                });
                
                this.startChartRotation();
            },

            // Start chart rotation
            startChartRotation() {
                if (intervals.chartRotation) {
                    clearInterval(intervals.chartRotation);
                }
                
                intervals.chartRotation = setInterval(() => {
                    state.currentChartIndex = (state.currentChartIndex + 1) % 2;
                    const chartType = state.currentChartIndex === 0 ? 'cumulative' : 'hourly';
                    this.showChart(chartType);
                }, CONFIG.CHART_ROTATION_INTERVAL);
            },

            // Show specific chart
            showChart(chartType) {
                const navDots = elements.chartNavDots;
                
                navDots.forEach(dot => {
                    const isActive = dot.getAttribute('data-chart') === chartType;
                    dom.toggleClass(dot, 'active', isActive);
                    dot.setAttribute('aria-pressed', isActive);
                });
                
                if (chartType === 'cumulative') {
                    state.currentChartIndex = 0;
                    dom.toggleClass(elements.cumulativeChart, 'hidden', false);
                    dom.toggleClass(elements.hourlyChart, 'hidden', true);
                    dom.updateText(elements.chartTitle, "TODAY'S PRODUCTION PROGRESS");
                } else {
                    state.currentChartIndex = 1;
                    dom.toggleClass(elements.cumulativeChart, 'hidden', true);
                    dom.toggleClass(elements.hourlyChart, 'hidden', false);
                    
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    const displayHour = currentMinute < 30 ? currentHour : currentHour + 1;
                    const hourStr = `${displayHour.toString().padStart(2, '0')}:30`;
                    
                    dom.updateText(elements.chartTitle, `CURRENT HOUR: ${hourStr} PRODUCTION`);
                }
            },

            // Render cumulative chart
            renderCumulativeChart(group) {
                const chartContainer = elements.cumulativeChart;
                chartContainer.innerHTML = '';
                
                const currentSupervisor = group.supervisor;
                const supervisorTotalProduction = parseInt(elements.currentUnits.textContent, 10) || 0;
                const supervisorTotalTarget = parseInt(elements.targetUnits.textContent, 10) || 0;
                
                const supervisorProductionItems = [];
                
                if (state.productionData.originalData && state.productionData.originalData.production) {
                    state.productionData.originalData.production.forEach(prodItem => {
                        const supervisorData = prodItem.supervisors.find(s => s.name === currentSupervisor);
                        if (supervisorData) {
                            supervisorProductionItems.push({
                                prodItem,
                                supervisorData,
                                variantId: prodItem.id,
                                startTime: supervisorData.startTime,
                                endTime: supervisorData.endTime,
                                production: supervisorData.production
                            });
                        }
                    });
                }
                
                if (supervisorProductionItems.length === 0) {
                    chartContainer.innerHTML = '<div class="loading">No data available for this supervisor</div>';
                    return;
                }
                
                supervisorProductionItems.sort((a, b) => {
                    return utils.timeToMinutes(a.startTime) - utils.timeToMinutes(b.startTime);
                });
                
                let earliestStart = "23:59";
                let latestEnd = "00:00";
                
                supervisorProductionItems.forEach(item => {
                    if (item.startTime < earliestStart) earliestStart = item.startTime;
                    if (item.endTime > latestEnd) latestEnd = item.endTime;
                });
                
                const startTimeMinutes = utils.timeToMinutes(earliestStart);
                const endTimeMinutes = utils.timeToMinutes(latestEnd);
                
                const standardHourMarks = [];
                for (let hour = 7; hour <= 16; hour++) {
                    standardHourMarks.push(`${hour.toString().padStart(2, '0')}:30`);
                }
                
                const now = new Date();
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                
                const hourlyData = {};
                
                standardHourMarks.forEach(hour => {
                    hourlyData[hour] = {
                        hour,
                        production: 0,
                        minutes: utils.timeToMinutes(hour)
                    };
                });
                
                supervisorProductionItems.forEach(item => {
                    if (!item.prodItem.timeline) return;
                    
                    const variantStartMin = utils.timeToMinutes(item.startTime);
                    const variantEndMin = utils.timeToMinutes(item.endTime);
                    
                    const totalVariantProduction = item.prodItem.actual.total || 0;
                    const supervisorVariantProduction = item.supervisorData.production || 0;
                    const supervisorRatio = totalVariantProduction > 0 ? supervisorVariantProduction / totalVariantProduction : 0;
                    
                    item.prodItem.timeline.forEach(timeSlot => {
                        if (!timeSlot.hour || !timeSlot.actual) return;
                        
                        const slotMinutes = utils.timeToMinutes(timeSlot.hour);
                        
                        if (slotMinutes >= variantStartMin && slotMinutes <= variantEndMin) {
                            let productionPortion = 0;
                            
                            if (item.prodItem.supervisors.length === 1) {
                                productionPortion = timeSlot.actual;
                            } else {
                                productionPortion = Math.round(timeSlot.actual * supervisorRatio);
                            }
                            
                            if (hourlyData[timeSlot.hour]) {
                                hourlyData[timeSlot.hour].production += productionPortion;
                            }
                        }
                    });
                });
                
                const hourlyDataArray = Object.values(hourlyData)
                    .filter(item => item.minutes >= startTimeMinutes && item.minutes <= endTimeMinutes)
                    .sort((a, b) => a.minutes - b.minutes);
                
                let runningProduction = 0;
                const cumulativeData = [];
                
                cumulativeData.push({
                    hour: earliestStart,
                    minutes: startTimeMinutes,
                    production: 0,
                    target: 0
                });
                
                hourlyDataArray.forEach(hourData => {
                    runningProduction += hourData.production;
                    
                    cumulativeData.push({
                        hour: hourData.hour,
                        minutes: hourData.minutes,
                        production: runningProduction,
                        target: 0
                    });
                });
                
                if (cumulativeData.length > 1 && runningProduction !== supervisorTotalProduction) {
                    const difference = supervisorTotalProduction - runningProduction;
                    
                    cumulativeData[cumulativeData.length - 1].production = supervisorTotalProduction;
                    
                    if (Math.abs(difference) > 5 && hourlyDataArray.length > 0) {
                        const adjustment = difference / hourlyDataArray.length;
                        runningProduction = 0;
                        
                        for (let i = 1; i < cumulativeData.length; i++) {
                            const hourIndex = i - 1;
                            hourlyDataArray[hourIndex].production += adjustment;
                            runningProduction += hourlyDataArray[hourIndex].production;
                            cumulativeData[i].production = Math.round(runningProduction);
                        }
                        
                        cumulativeData[cumulativeData.length - 1].production = supervisorTotalProduction;
                    }
                }
                
                const workDuration = endTimeMinutes - startTimeMinutes;
                
                cumulativeData.forEach(dataPoint => {
                    const elapsedProportion = (dataPoint.minutes - startTimeMinutes) / workDuration;
                    dataPoint.target = Math.round(supervisorTotalTarget * elapsedProportion);
                });
                
                const currentTimePlusBuffer = currentTimeMinutes + 60;
                let filteredData = cumulativeData.filter(item => item.minutes <= currentTimePlusBuffer);
                
                const currentTimePoint = filteredData.find(item => item.minutes === currentTimeMinutes);
                if (!currentTimePoint && filteredData.length > 0) {
                    const prevPoints = filteredData.filter(item => item.minutes < currentTimeMinutes);
                    const nextPoints = filteredData.filter(item => item.minutes > currentTimeMinutes);
                    
                    let currentProduction = supervisorTotalProduction;
                    let currentTarget = Math.round(supervisorTotalTarget * ((currentTimeMinutes - startTimeMinutes) / workDuration));
                    
                    if (prevPoints.length > 0 && nextPoints.length > 0) {
                        const prevPoint = prevPoints[prevPoints.length - 1];
                        const nextPoint = nextPoints[0];
                        
                        const ratio = (currentTimeMinutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                        currentProduction = Math.round(prevPoint.production + (nextPoint.production - prevPoint.production) * ratio);
                    } else if (prevPoints.length > 0) {
                        currentProduction = prevPoints[prevPoints.length - 1].production;
                    }
                    
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    const currentHourStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
                    filteredData.push({
                        hour: currentHourStr,
                        minutes: currentTimeMinutes,
                        production: currentProduction,
                        target: currentTarget
                    });
                    
                    filteredData.sort((a, b) => a.minutes - b.minutes);
                }
                
                if (filteredData.length > 0) {
                    filteredData[filteredData.length - 1].production = supervisorTotalProduction;
                }
                
                if (filteredData.length === 0) {
                    chartContainer.innerHTML = '<div class="loading">No data available for current time period</div>';
                    return;
                }
                
                const chartArea = chartContainer.closest('.chart-area');
                const svgWidth = chartArea.clientWidth;
                const svgHeight = chartArea.clientHeight;
                
                if (svgWidth <= 0 || svgHeight <= 0) {
                    setTimeout(() => this.renderCumulativeChart(group), 100);
                    return;
                }
                
                const padding = {
                    top: Math.max(10, Math.floor(svgHeight * 0.05)),
                    right: Math.max(10, Math.floor(svgWidth * 0.05)),
                    bottom: Math.max(50, Math.floor(svgHeight * 0.18)),
                    left: Math.max(40, Math.floor(svgWidth * 0.12))
                };
                
                const chartWidth = svgWidth - padding.left - padding.right;
                const chartHeight = svgHeight - padding.top - padding.bottom;
                
                const maxValue = Math.max(
                    ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
                ) * 1.1;
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                chartContainer.appendChild(svg);
                
                // Add grid lines
                const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (chartHeight * i / 4);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', padding.left);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', svgWidth - padding.right);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#ddd');
                    line.setAttribute('stroke-width', '1');
                    gridGroup.appendChild(line);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', padding.left - 10);
                    text.setAttribute('y', y + 5);
                    text.setAttribute('text-anchor', 'end');
                    text.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = Math.round(maxValue * (4 - i) / 4);
                    gridGroup.appendChild(text);
                }
                
                // Add y-axis title
                const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yAxisTitle.setAttribute('x', padding.left - 35);
                yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
                yAxisTitle.setAttribute('text-anchor', 'middle');
                yAxisTitle.setAttribute('font-size', state.isFullscreen ? '16' : '14');
                yAxisTitle.setAttribute('font-weight', 'bold');
                yAxisTitle.setAttribute('fill', '#666');
                yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
                yAxisTitle.textContent = 'Units';
                gridGroup.appendChild(yAxisTitle);
                
                // Add axes
                const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                yAxis.setAttribute('x1', padding.left);
                yAxis.setAttribute('y1', padding.top);
                yAxis.setAttribute('x2', padding.left);
                yAxis.setAttribute('y2', svgHeight - padding.bottom);
                yAxis.setAttribute('stroke', '#666');
                yAxis.setAttribute('stroke-width', '1.5');
                gridGroup.appendChild(yAxis);
                
                const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                xAxis.setAttribute('x1', padding.left);
                xAxis.setAttribute('y1', svgHeight - padding.bottom);
                xAxis.setAttribute('x2', svgWidth - padding.right);
                xAxis.setAttribute('y2', svgHeight - padding.bottom);
                xAxis.setAttribute('stroke', '#666');
                xAxis.setAttribute('stroke-width', '1.5');
                gridGroup.appendChild(xAxis);
                
                svg.appendChild(gridGroup);
                
                // Create a mapping function to convert time to x position
                function timeToXPosition(minutes) {
                    const normalizedTime = (minutes - startTimeMinutes) / (endTimeMinutes - startTimeMinutes);
                    return padding.left + (chartWidth * normalizedTime);
                }
                
                const visibleHourMarks = standardHourMarks.filter(hourMark => {
                    const minutes = utils.timeToMinutes(hourMark);
                    return minutes >= startTimeMinutes && minutes <= endTimeMinutes;
                });
                
                // Add X-axis ticks and labels
                const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                visibleHourMarks.forEach(hourMark => {
                    const minutes = utils.timeToMinutes(hourMark);
                    const x = timeToXPosition(minutes);
                    const y = svgHeight - padding.bottom + 20;
                    
                    const tickLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tickLine.setAttribute('x1', x);
                    tickLine.setAttribute('y1', svgHeight - padding.bottom);
                    tickLine.setAttribute('x2', x);
                    tickLine.setAttribute('y2', svgHeight - padding.bottom + 5);
                    tickLine.setAttribute('stroke', '#666');
                    tickLine.setAttribute('stroke-width', '1.5');
                    xLabelsGroup.appendChild(tickLine);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = hourMark;
                    xLabelsGroup.appendChild(text);
                    
                    if (minutes < currentTimeMinutes) {
                        const hourProduction = hourlyData[hourMark] ? hourlyData[hourMark].production : 0;
                        const dataPoint = filteredData.find(dp => dp.hour === hourMark);
                        let hourTarget = 0;
                        
                        if (dataPoint) {
                            hourTarget = dataPoint.target;
                        } else {
                            const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                            const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                            
                            if (prevPoints.length > 0 && nextPoints.length > 0) {
                                const prevPoint = prevPoints[prevPoints.length - 1];
                                const nextPoint = nextPoints[0];
                                
                                const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                                hourTarget = Math.round(prevPoint.target + (nextPoint.target - prevPoint.target) * ratio);
                            } else if (prevPoints.length > 0) {
                                hourTarget = prevPoints[prevPoints.length - 1].target;
                            }
                        }
                        
                        let statusSymbol = '';
                        let fillColor = '#94a3b8';
                        
                        if (hourProduction >= hourTarget) {
                            statusSymbol = '';
                            fillColor = '#0d9488';
                        } else {
                            statusSymbol = '';
                            fillColor = '#e11d48';
                        }
                        
                        if (utils.timeToMinutes(hourMark) === (Math.floor(currentTimeMinutes / 60) * 60 + 30)) {
                            statusSymbol = '';
                            fillColor = '#ca8a04';
                        }
                        
                        const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        statusText.setAttribute('x', x);
                        statusText.setAttribute('y', y + 20);
                        statusText.setAttribute('text-anchor', 'middle');
                        statusText.setAttribute('font-size', state.isFullscreen ? '18' : '16');
                        statusText.setAttribute('font-weight', 'bold');
                        statusText.setAttribute('fill', fillColor);
                        statusText.textContent = statusSymbol;
                        xLabelsGroup.appendChild(statusText);
                    }
                });
                svg.appendChild(xLabelsGroup);
                
                // Draw production line
                const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                let productionPathD = '';
                const productionPoints = [];
                
                filteredData.forEach((dataPoint, index) => {
                    const x = timeToXPosition(dataPoint.minutes);
                    const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
                    
                    if (index === 0) {
                        productionPathD = `M ${x} ${y}`;
                    } else {
                        productionPathD += ` L ${x} ${y}`;
                    }
                    
                    productionPoints.push({
                        x, y,
                        production: dataPoint.production,
                        hour: dataPoint.hour
                    });
                });
                
                const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                productionPath.setAttribute('d', productionPathD);
                productionPath.setAttribute('stroke', 'var(--production-color)');
                productionPath.setAttribute('stroke-width', '3');
                productionPath.setAttribute('fill', 'none');
                productionLineGroup.appendChild(productionPath);
                
                visibleHourMarks.forEach(hourMark => {
                    const minutes = utils.timeToMinutes(hourMark);
                    
                    if (minutes > currentTimeMinutes) return;
                    
                    let productionValue = 0;
                    let x = timeToXPosition(minutes);
                    let y = padding.top + chartHeight;
                    
                    const exactMatch = filteredData.find(dp => dp.hour === hourMark);
                    if (exactMatch) {
                        productionValue = exactMatch.production;
                        y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                    } else {
                        const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                        const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                        
                        if (prevPoints.length > 0 && nextPoints.length > 0) {
                            const prevPoint = prevPoints[prevPoints.length - 1];
                            const nextPoint = nextPoints[0];
                            
                            const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                            productionValue = Math.round(prevPoint.production + (nextPoint.production - prevPoint.production) * ratio);
                            y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                        } else if (prevPoints.length > 0) {
                            productionValue = prevPoints[prevPoints.length - 1].production;
                            y = padding.top + chartHeight - (chartHeight * (productionValue / maxValue));
                        }
                    }
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', state.isFullscreen ? '5' : '4');
                    circle.setAttribute('fill', 'var(--production-color)');
                    productionLineGroup.appendChild(circle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y - 8);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('fill', 'var(--production-color)');
                    text.textContent = productionValue;
                    productionLineGroup.appendChild(text);
                });
                
                // Emphasize the final production point
                if (productionPoints.length > 0) {
                    const lastPoint = productionPoints[productionPoints.length - 1];
                    
                    const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    emphasizedCircle.setAttribute('cx', lastPoint.x);
                    emphasizedCircle.setAttribute('cy', lastPoint.y);
                    emphasizedCircle.setAttribute('r', state.isFullscreen ? '8' : '7');
                    emphasizedCircle.setAttribute('fill', 'var(--production-color)');
                    emphasizedCircle.setAttribute('stroke', '#ffffff');
                    emphasizedCircle.setAttribute('stroke-width', '2');
                    productionLineGroup.appendChild(emphasizedCircle);
                    
                    const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    emphasizedText.setAttribute('x', lastPoint.x);
                    emphasizedText.setAttribute('y', lastPoint.y - 12);
                    emphasizedText.setAttribute('text-anchor', 'middle');
                    emphasizedText.setAttribute('font-size', state.isFullscreen ? '18' : '16');
                    emphasizedText.setAttribute('font-weight', 'bold');
                    emphasizedText.setAttribute('fill', 'var(--production-color)');
                    emphasizedText.textContent = lastPoint.production;
                    productionLineGroup.appendChild(emphasizedText);
                }
                
                svg.appendChild(productionLineGroup);
                
                // Draw target line
                const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                let targetPathD = '';
                const targetPoints = [];
                
                filteredData.forEach((dataPoint, index) => {
                    const x = timeToXPosition(dataPoint.minutes);
                    const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
                    
                    if (index === 0) {
                        targetPathD = `M ${x} ${y}`;
                    } else {
                        targetPathD += ` L ${x} ${y}`;
                    }
                    
                    targetPoints.push({
                        x, y,
                        target: dataPoint.target,
                        hour: dataPoint.hour
                    });
                });
                
                const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                targetPath.setAttribute('d', targetPathD);
                targetPath.setAttribute('stroke', 'var(--target-color)');
                targetPath.setAttribute('stroke-width', '3');
                targetPath.setAttribute('fill', 'none');
                targetLineGroup.appendChild(targetPath);
                
                visibleHourMarks.forEach(hourMark => {
                    const minutes = utils.timeToMinutes(hourMark);
                    
                    if (minutes > currentTimeMinutes + 60) return;
                    
                    let targetValue = 0;
                    let x = timeToXPosition(minutes);
                    let y = padding.top + chartHeight;
                    
                    const exactMatch = filteredData.find(dp => dp.hour === hourMark);
                    if (exactMatch) {
                        targetValue = exactMatch.target;
                        y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                    } else {
                        const prevPoints = filteredData.filter(dp => dp.minutes <= minutes);
                        const nextPoints = filteredData.filter(dp => dp.minutes > minutes);
                        
                        if (prevPoints.length > 0 && nextPoints.length > 0) {
                            const prevPoint = prevPoints[prevPoints.length - 1];
                            const nextPoint = nextPoints[0];
                            
                            const ratio = (minutes - prevPoint.minutes) / (nextPoint.minutes - prevPoint.minutes);
                            targetValue = Math.round(prevPoint.target + (nextPoint.target - prevPoint.target) * ratio);
                            y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                        } else if (prevPoints.length > 0) {
                            targetValue = prevPoints[prevPoints.length - 1].target;
                            y = padding.top + chartHeight - (chartHeight * (targetValue / maxValue));
                        }
                    }
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', state.isFullscreen ? '5' : '4');
                    circle.setAttribute('fill', 'var(--target-color)');
                    targetLineGroup.appendChild(circle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y - 8);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('fill', 'var(--target-color)');
                    text.textContent = targetValue;
                    targetLineGroup.appendChild(text);
                });
                
                // Emphasize the final target point
                if (targetPoints.length > 0) {
                    const lastPoint = targetPoints[targetPoints.length - 1];
                    
                    const emphasizedCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    emphasizedCircle.setAttribute('cx', lastPoint.x);
                    emphasizedCircle.setAttribute('cy', lastPoint.y);
                    emphasizedCircle.setAttribute('r', state.isFullscreen ? '7' : '6');
                    emphasizedCircle.setAttribute('fill', 'var(--target-color)');
                    emphasizedCircle.setAttribute('stroke', '#ffffff');
                    emphasizedCircle.setAttribute('stroke-width', '2');
                    targetLineGroup.appendChild(emphasizedCircle);
                    
                    const emphasizedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    emphasizedText.setAttribute('x', lastPoint.x);
                    emphasizedText.setAttribute('y', lastPoint.y - 10);
                    emphasizedText.setAttribute('text-anchor', 'middle');
                    emphasizedText.setAttribute('font-size', state.isFullscreen ? '16' : '14');
                    emphasizedText.setAttribute('font-weight', 'bold');
                    emphasizedText.setAttribute('fill', 'var(--target-color)');
                    emphasizedText.textContent = lastPoint.target;
                    targetLineGroup.appendChild(emphasizedText);
                }
                
                svg.appendChild(targetLineGroup);
            },

            // Render hourly chart
            renderHourlyChart(group) {
                const chartContainer = elements.hourlyChart;
                chartContainer.innerHTML = '';
                
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                
                const currentPeriodHour = currentMinute < 30 ? currentHour : currentHour + 1;
                const currentPeriodMinute = 30;
                const currentPeriodStr = `${currentPeriodHour.toString().padStart(2, '0')}:${currentPeriodMinute.toString().padStart(2, '0')}`;
                
                const hourlyProductionMap = new Map();
                const hourlyTargetMap = new Map();
                
                group.variants.forEach(variant => {
                    const supervisorVariant = group.supervisorData.variants[variant.variant];
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const startTimeMinutes = utils.timeToMinutes(startTimeStr);
                    const endTimeMinutes = utils.timeToMinutes(endTimeStr);
                    
                    if (variant.hourlyProduction) {
                        variant.hourlyProduction.forEach(item => {
                            if (!item.hour || item.hour !== currentPeriodStr) return;
                            
                            const itemTimeMinutes = utils.timeToMinutes(item.hour);
                            
                            if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                                if (!hourlyProductionMap.has(item.hour)) {
                                    hourlyProductionMap.set(item.hour, 0);
                                }
                                hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                            }
                        });
                    }
                    
                    if (variant.hourlyTargets) {
                        variant.hourlyTargets.forEach(item => {
                            if (!item.hour || item.hour !== currentPeriodStr) return;
                            
                            const itemTimeMinutes = utils.timeToMinutes(item.hour);
                            
                            if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                                if (!hourlyTargetMap.has(item.hour)) {
                                    hourlyTargetMap.set(item.hour, 0);
                                }
                                hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                            }
                        });
                    }
                });
                
                const sortedHours = [currentPeriodStr];
                
                if (hourlyProductionMap.size === 0 && hourlyTargetMap.size === 0) {
                    chartContainer.innerHTML = '<div class="loading">No data available for current hour period</div>';
                    return;
                }
                
                const chartArea = chartContainer.closest('.chart-area');
                const svgWidth = chartArea.clientWidth;
                const svgHeight = chartArea.clientHeight;
                
                if (svgWidth <= 0 || svgHeight <= 0) {
                    setTimeout(() => this.renderHourlyChart(group), 100);
                    return;
                }
                
                const padding = {
                    top: Math.max(10, Math.floor(svgHeight * 0.05)),
                    right: Math.max(10, Math.floor(svgWidth * 0.05)),
                    bottom: Math.max(50, Math.floor(svgHeight * 0.1)),
                    left: Math.max(40, Math.floor(svgWidth * 0.12))
                };
                
                const chartWidth = svgWidth - padding.left - padding.right;
                const chartHeight = svgHeight - padding.top - padding.bottom;
                
                const maxValue = Math.max(
                    hourlyProductionMap.get(currentPeriodStr) || 0,
                    hourlyTargetMap.get(currentPeriodStr) || 0
                ) * 1.1 || 100;
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                chartContainer.appendChild(svg);
                
                // Add grid lines
                const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (chartHeight * i / 4);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', padding.left);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', svgWidth - padding.right);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#ddd');
                    line.setAttribute('stroke-width', '1');
                    gridGroup.appendChild(line);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', padding.left - 10);
                    text.setAttribute('y', y + 5);
                    text.setAttribute('text-anchor', 'end');
                    text.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = Math.round(maxValue * (4 - i) / 4);
                    gridGroup.appendChild(text);
                }
                
                // Add y-axis title
                const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yAxisTitle.setAttribute('x', padding.left - 35);
                yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
                yAxisTitle.setAttribute('text-anchor', 'middle');
                yAxisTitle.setAttribute('font-size', state.isFullscreen ? '16' : '14');
                yAxisTitle.setAttribute('font-weight', 'bold');
                yAxisTitle.setAttribute('fill', '#666');
                yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 35}, ${padding.top + chartHeight / 2})`);
                yAxisTitle.textContent = 'Units per Hour';
                gridGroup.appendChild(yAxisTitle);
                
                // Add axes
                const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                yAxis.setAttribute('x1', padding.left);
                yAxis.setAttribute('y1', padding.top);
                yAxis.setAttribute('x2', padding.left);
                yAxis.setAttribute('y2', svgHeight - padding.bottom);
                yAxis.setAttribute('stroke', '#666');
                yAxis.setAttribute('stroke-width', '1.5');
                gridGroup.appendChild(yAxis);
                
                const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                xAxis.setAttribute('x1', padding.left);
                xAxis.setAttribute('y1', svgHeight - padding.bottom);
                xAxis.setAttribute('x2', svgWidth - padding.right);
                xAxis.setAttribute('y2', svgHeight - padding.bottom);
                xAxis.setAttribute('stroke', '#666');
                xAxis.setAttribute('stroke-width', '1.5');
                gridGroup.appendChild(xAxis);
                
                svg.appendChild(gridGroup);
                
                const barGroupWidth = chartWidth * 0.3;
                const barWidth = barGroupWidth * 0.42;
                
                // Add X-axis label
                const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const x = padding.left + chartWidth / 2;
                const y = svgHeight - padding.bottom + 20;
                
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', svgHeight - padding.bottom);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', svgHeight - padding.bottom + 5);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1.5');
                xLabelsGroup.appendChild(tick);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', state.isFullscreen ? '16' : '14');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', '#666');
                text.textContent = currentPeriodStr;
                xLabelsGroup.appendChild(text);
                
                svg.appendChild(xLabelsGroup);
                
                // Create bar charts
                const barsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const barGroupX = padding.left + (chartWidth - barGroupWidth) / 2;
                
                // Production bar
                const productionValue = hourlyProductionMap.get(currentPeriodStr) || 0;
                const productionHeight = (productionValue / maxValue) * chartHeight;
                const productionY = svgHeight - padding.bottom - productionHeight;
                
                const productionBarX = barGroupX + (barGroupWidth * 0.08);
                
                const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                productionBar.setAttribute('x', productionBarX);
                productionBar.setAttribute('y', productionY);
                productionBar.setAttribute('width', barWidth);
                productionBar.setAttribute('height', productionHeight);
                productionBar.setAttribute('rx', '2');
                productionBar.setAttribute('ry', '2');
                productionBar.setAttribute('fill', 'var(--production-color)');
                barsGroup.appendChild(productionBar);
                
                const productionLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                productionLabel.setAttribute('x', productionBarX + (barWidth / 2));
                productionLabel.setAttribute('y', productionY - 5);
                productionLabel.setAttribute('text-anchor', 'middle');
                productionLabel.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                productionLabel.setAttribute('font-weight', 'bold');
                productionLabel.setAttribute('fill', 'var(--production-color)');
                productionLabel.textContent = productionValue;
                barsGroup.appendChild(productionLabel);
                
                // Target bar
                const targetValue = hourlyTargetMap.get(currentPeriodStr) || 0;
                const targetHeight = (targetValue / maxValue) * chartHeight;
                const targetY = svgHeight - padding.bottom - targetHeight;
                
                const targetBarX = barGroupX + (barGroupWidth * 0.5);
                
                const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                targetBar.setAttribute('x', targetBarX);
                targetBar.setAttribute('y', targetY);
                targetBar.setAttribute('width', barWidth);
                targetBar.setAttribute('height', targetHeight);
                targetBar.setAttribute('rx', '2');
                targetBar.setAttribute('ry', '2');
                targetBar.setAttribute('fill', 'var(--target-color)');
                barsGroup.appendChild(targetBar);
                
                const targetLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                targetLabel.setAttribute('x', targetBarX + (barWidth / 2));
                targetLabel.setAttribute('y', targetY - 5);
                targetLabel.setAttribute('text-anchor', 'middle');
                targetLabel.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                targetLabel.setAttribute('font-weight', 'bold');
                targetLabel.setAttribute('fill', 'var(--target-color)');
                targetLabel.textContent = targetValue;
                barsGroup.appendChild(targetLabel);
                
                svg.appendChild(barsGroup);
                
                // Add legend
                const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const prodLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                prodLegendRect.setAttribute('x', padding.left);
                prodLegendRect.setAttribute('y', padding.top - 25);
                prodLegendRect.setAttribute('width', 12);
                prodLegendRect.setAttribute('height', 12);
                prodLegendRect.setAttribute('fill', 'var(--production-color)');
                legendGroup.appendChild(prodLegendRect);
                
                const prodLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                prodLegendText.setAttribute('x', padding.left + 18);
                prodLegendText.setAttribute('y', padding.top - 15);
                prodLegendText.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                prodLegendText.setAttribute('fill', '#666');
                prodLegendText.textContent = 'Production';
                legendGroup.appendChild(prodLegendText);
                
                const targetLegendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                targetLegendRect.setAttribute('x', padding.left + 100);
                targetLegendRect.setAttribute('y', padding.top - 25);
                targetLegendRect.setAttribute('width', 12);
                targetLegendRect.setAttribute('height', 12);
                targetLegendRect.setAttribute('fill', 'var(--target-color)');
                legendGroup.appendChild(targetLegendRect);
                
                const targetLegendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                targetLegendText.setAttribute('x', padding.left + 118);
                targetLegendText.setAttribute('y', padding.top - 15);
                targetLegendText.setAttribute('font-size', state.isFullscreen ? '14' : '12');
                targetLegendText.setAttribute('fill', '#666');
                targetLegendText.textContent = 'Target';
                legendGroup.appendChild(targetLegendText);
                
                svg.appendChild(legendGroup);
            }
        };

        // ===== DASHBOARD MANAGEMENT =====
        const dashboardManager = {
            // Show loading or error message
            showLoadingOrError(message) {
                dom.updateText(elements.supervisorName, 'SUPERVISOR: Loading...');
                dom.updateText(elements.productName, 'PRODUCT: Loading...');
                elements.variantSequence.innerHTML = '<div class="loading">Loading variants</div>';
                
                const elementIds = [
                    'currentUnits', 'targetUnits', 'progressPercentage', 
                    'currentBoxes', 'targetBoxes', 'actualCycleTime', 'targetCycleTime'
                ];
                
                elementIds.forEach(id => {
                    if (elements[id]) {
                        dom.updateText(elements[id], id === 'progressPercentage' ? '0%' : '0');
                    }
                });
                
                const errorHtml = `<div class="loading">${message}</div>`;
                
                if (elements.cumulativeChart) {
                    elements.cumulativeChart.innerHTML = errorHtml;
                }
                
                if (elements.hourlyChart) {
                    elements.hourlyChart.innerHTML = errorHtml;
                }
                
                if (elements.batchInfoTbody) {
                    elements.batchInfoTbody.innerHTML = `<tr><td colspan="5">${message}</td></tr>`;
                }
            },

            // Update dashboard
            updateDashboard() {
                let filteredGroups = {};
                
                if (state.selectedFilterValue === 'all') {
                    Object.keys(state.productSupervisorGroups).forEach(key => {
                        if (state.selectedSupervisors.includes(state.productSupervisorGroups[key].supervisor)) {
                            filteredGroups[key] = state.productSupervisorGroups[key];
                        }
                    });
                } else if (state.selectedFilterType === 'supervisor') {
                    Object.keys(state.productSupervisorGroups).forEach(key => {
                        if (state.productSupervisorGroups[key].supervisor === state.selectedFilterValue &&
                            state.selectedSupervisors.includes(state.productSupervisorGroups[key].supervisor)) {
                            filteredGroups[key] = state.productSupervisorGroups[key];
                        }
                    });
                } else if (state.selectedFilterType === 'product') {
                    Object.keys(state.productSupervisorGroups).forEach(key => {
                        if (state.productSupervisorGroups[key].product === state.selectedFilterValue &&
                            state.selectedSupervisors.includes(state.productSupervisorGroups[key].supervisor)) {
                            filteredGroups[key] = state.productSupervisorGroups[key];
                        }
                    });
                } else if (state.selectedFilterType === 'variant') {
                    Object.keys(state.productSupervisorGroups).forEach(key => {
                        const group = state.productSupervisorGroups[key];
                        if (group.variants.some(v => v.variant === state.selectedFilterValue) &&
                            state.selectedSupervisors.includes(group.supervisor)) {
                            filteredGroups[key] = group;
                        }
                    });
                }
                
                if (Object.keys(filteredGroups).length === 0) {
                    this.showLoadingOrError('No data available for this filter or selected supervisors.');
                    if (intervals.cycle) clearInterval(intervals.cycle);
                    intervals.cycle = null;
                    return;
                }
                
                const groupKeys = Object.keys(filteredGroups);
                if (groupKeys.length > 1) {
                    if (intervals.cycle) clearInterval(intervals.cycle);
                    
                    state.cycleIndex = 0;
                    intervals.cycle = setInterval(() => {
                        state.cycleIndex = (state.cycleIndex + 1) % groupKeys.length;
                        this.displayGroup(filteredGroups[groupKeys[state.cycleIndex]]);
                    }, CONFIG.CYCLE_INTERVAL);
                } else {
                    if (intervals.cycle) clearInterval(intervals.cycle);
                    intervals.cycle = null;
                }
                
                this.displayGroup(filteredGroups[groupKeys[0]]);
                this.updateBatchInfoTable(filteredGroups);
            },

            // Display a group
            displayGroup(group) {
                state.currentProduct = group.product;
                state.currentSupervisor = group.supervisor;
                state.currentProductVariants = group.variants;
                
                const now = new Date();
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                
                const sortedVariants = [...state.currentProductVariants].sort((a, b) => {
                    const supervisorA = group.supervisorData.variants[a.variant];
                    const supervisorB = group.supervisorData.variants[b.variant];
                    
                    const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                    const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                    
                    return utils.timeToMinutes(timeA) - utils.timeToMinutes(timeB);
                });
                
                let currentVariantIndex = -1;
                
                for (let i = 0; i < sortedVariants.length; i++) {
                    const variant = sortedVariants[i];
                    const supervisorVariant = group.supervisorData.variants[variant.variant];
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) continue;
                    
                    const startTimeMinutes = utils.timeToMinutes(startTimeStr);
                    const endTimeMinutes = utils.timeToMinutes(endTimeStr);
                    
                    if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                        currentVariantIndex = i;
                        break;
                    }
                }
                
                if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                    currentVariantIndex = sortedVariants.length - 1;
                }
                
                state.currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
                
                this.applySupervisorStyling(state.currentSupervisor);
                this.updateSupervisorInfo(group);
                this.updateMetrics(group);
                
                setTimeout(() => {
                    chartManager.renderCumulativeChart(group);
                    chartManager.renderHourlyChart(group);
                }, 50);
            },

            // Apply supervisor styling
            applySupervisorStyling(supervisorName) {
                if (supervisorName) {
                    const color = utils.getSupervisorColor(supervisorName);
                    elements.supervisorColorBanner.style.backgroundColor = color;
                    elements.supervisorPanel.style.backgroundColor = color;
                }
            },

            // Update supervisor info
            updateSupervisorInfo(group) {
                dom.updateText(elements.supervisorName, `SUPERVISOR: ${group.supervisor}`);
                dom.updateText(elements.productName, `PRODUCT: ${group.product}`);
                
                elements.variantSequence.innerHTML = '';
                
                if (group.variants.length === 0) {
                    elements.variantSequence.innerHTML = '<div>No variants available</div>';
                    return;
                }
                
                const now = new Date();
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                
                group.variants.forEach((variant, index) => {
                    const supervisorVariant = group.supervisorData.variants[variant.variant];
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const startTimeMinutes = utils.timeToMinutes(startTimeStr);
                    const endTimeMinutes = utils.timeToMinutes(endTimeStr);
                    
                    let status = '';
                    if (currentTimeMinutes < startTimeMinutes) {
                        status = 'upcoming';
                    } else if (currentTimeMinutes > endTimeMinutes) {
                        status = 'completed';
                    } else {
                        status = 'current';
                    }
                    
                    let displayName = variant.variant;
                    
                    if (variant.variant.includes('-')) {
                        displayName = variant.variant.split('-').pop();
                    } else if (variant.variant.startsWith(group.product + ' ')) {
                        displayName = variant.variant.substring(group.product.length + 1);
                    }
                    
                    const variantElement = document.createElement('div');
                    variantElement.className = `variant-item ${status}`;
                    variantElement.textContent = displayName;
                    
                    elements.variantSequence.appendChild(variantElement);
                    
                    if (index < group.variants.length - 1) {
                        const arrow = document.createElement('div');
                        arrow.className = 'arrow-right';
                        arrow.textContent = '';
                        elements.variantSequence.appendChild(arrow);
                    }
                });
            },

            // Update metrics
            updateMetrics(group) {
                let totalTarget = 0;
                let totalProduction = 0;
                let totalBoxTarget = 0;
                let totalBoxProduction = 0;
                let weightedCycleTime = 0;
                let totalCycleTimeWeight = 0;
                
                const currentSupervisor = group.supervisor;
                
                group.variants.forEach(variant => {
                    const supervisorVariant = group.supervisorData.variants[variant.variant];
                    
                    if (supervisorVariant) {
                        const prodItem = state.productionData.originalData.production.find(p => p.id === variant.variant);
                        const supervisorData = prodItem?.supervisors.find(s => s.name === currentSupervisor);
                        
                        if (supervisorData) {
                            totalTarget += (supervisorVariant.dailyTarget || 0);
                            totalProduction += (supervisorVariant.currentTotal || 0);
                            
                            if (prodItem && prodItem.actual.total > 0) {
                                const supervisorRatio = supervisorData.production / prodItem.actual.total;
                                totalBoxProduction += Math.round((variant.currentBoxTotal || 0) * supervisorRatio);
                                totalBoxTarget += Math.round((variant.dailyBoxTarget || 0) * (supervisorVariant.dailyTarget / prodItem.targets.daily));
                            }
                            
                            const cycleTime = variant.cycleTime || 0;
                            const target = supervisorVariant.dailyTarget || 0;
                            
                            if (cycleTime > 0 && target > 0) {
                                weightedCycleTime += cycleTime * target;
                                totalCycleTimeWeight += target;
                            }
                        }
                    }
                });
                
                const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
                const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
                const actualCycleTime = this.calculateActualCycleTime(group.variants);
                
                dom.updateText(elements.currentUnits, totalProduction);
                dom.updateText(elements.targetUnits, totalTarget);
                dom.updateText(elements.progressPercentage, `${progressPercentage}%`);
                dom.updateText(elements.currentBoxes, totalBoxProduction);
                dom.updateText(elements.targetBoxes, totalBoxTarget);
                dom.updateText(elements.actualCycleTime, actualCycleTime === "N/A" ? "N/A" : actualCycleTime);
                dom.updateText(elements.targetCycleTime, avgCycleTime);
            },

            // Calculate actual cycle time
            calculateActualCycleTime(variants) {
                const variantsWithActualCycleTime = variants.filter(v => v.actualCycleTime !== undefined && v.actualCycleTime !== null);
                
                if (variantsWithActualCycleTime.length > 0) {
                    if (variantsWithActualCycleTime.length > 1) {
                        let totalWeight = 0;
                        let weightedSum = 0;
                        
                        variantsWithActualCycleTime.forEach(variant => {
                            const supervisor = state.productionData.supervisors.find(s => s.name === state.currentSupervisor);
                            if (supervisor && supervisor.variants[variant.variant]) {
                                const supervisorVariant = supervisor.variants[variant.variant];
                                if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                                    totalWeight += supervisorVariant.currentTotal;
                                    weightedSum += variant.actualCycleTime * supervisorVariant.currentTotal;
                                }
                            }
                        });
                        
                        if (totalWeight > 0) {
                            return Math.round(weightedSum / totalWeight);
                        } else {
                            const sum = variantsWithActualCycleTime.reduce((acc, v) => acc + v.actualCycleTime, 0);
                            return Math.round(sum / variantsWithActualCycleTime.length);
                        }
                    } else {
                        return variantsWithActualCycleTime[0].actualCycleTime;
                    }
                }
                
                let totalProduction = 0;
                let totalElapsedWorkingTime = 0;
                
                variants.forEach(variant => {
                    const supervisor = state.productionData.supervisors.find(s => s.name === state.currentSupervisor);
                    if (supervisor && supervisor.variants[variant.variant]) {
                        const supervisorVariant = supervisor.variants[variant.variant];
                        
                        if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                            
                            if (startTimeStr && variant.hourlyProduction) {
                                const hoursWithProduction = variant.hourlyProduction
                                    .filter(h => h.production > 0)
                                    .sort((a, b) => {
                                        return utils.timeToMinutes(b.hour) - utils.timeToMinutes(a.hour);
                                    });
                                
                                if (hoursWithProduction.length > 0) {
                                    const lastProductionHourData = hoursWithProduction[0];
                                    const lastTotalMinutes = utils.timeToMinutes(lastProductionHourData.hour);
                                    const startTotalMinutes = utils.timeToMinutes(startTimeStr);
                                    
                                    let elapsedMinutes = lastTotalMinutes - startTotalMinutes;
                                    if (elapsedMinutes < 0) {
                                        elapsedMinutes += 24 * 60;
                                    }
                                    
                                    const now = new Date();
                                    const [lastHours, lastMinutes] = lastProductionHourData.hour.split(':').map(Number);
                                    const lastProductionTime = new Date(now);
                                    lastProductionTime.setHours(lastHours);
                                    lastProductionTime.setMinutes(lastMinutes);
                                    
                                    const elapsedBreakMinutes = timeManager.calculateElapsedBreakMinutes(variant, startTimeStr, lastProductionTime);
                                    const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                                    
                                    totalProduction += supervisorVariant.currentTotal;
                                    totalElapsedWorkingTime += workingMinutes * 60;
                                }
                            }
                        }
                    }
                });
                
                if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
                
                return Math.round(totalElapsedWorkingTime / totalProduction);
            },

            // Update batch info table
            updateBatchInfoTable(filteredGroups) {
                if (!elements.batchInfoTbody || !elements.batchInfoThead) return;
                
                elements.batchInfoTbody.innerHTML = '';
                elements.batchInfoThead.innerHTML = '';
                
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <th>Product</th>
                    <th>Variant</th>
                    <th>Batch</th>
                    <th>Units</th>
                    <th>Boxes</th>
                `;
                elements.batchInfoThead.appendChild(headerRow);
                
                if (!state.productionData.originalData || !state.productionData.originalData.production) {
                    elements.batchInfoTbody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
                    return;
                }
                
                const now = new Date();
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                
                if (!state.selectedSupervisors || state.selectedSupervisors.length === 0) {
                    elements.batchInfoTbody.innerHTML = '<tr><td colspan="5">No supervisors selected</td></tr>';
                    return;
                }
                
                const processedBatches = [];
                
                state.selectedSupervisors.forEach(supervisorName => {
                    const supervisorOriginal = state.productionData.originalData.summary.supervisors.find(
                        s => s.name === supervisorName
                    );
                    
                    if (!supervisorOriginal) return;
                    
                    const supervisorVariantIds = supervisorOriginal.variants || [];
                    
                    supervisorVariantIds.forEach(variantId => {
                        const productionItem = state.productionData.originalData.production.find(p => p.id === variantId);
                        
                        if (!productionItem || !productionItem.batches || productionItem.batches.length === 0) return;
                        
                        const supervisorData = productionItem.supervisors.find(s => s.name === supervisorName);
                        
                        if (!supervisorData) return;
                        
                        const productName = productionItem.product?.name || '';
                        const variantName = productionItem.variant?.name || '';
                        
                        let isCurrentVariant = false;
                        const startTimeStr = supervisorData.startTime;
                        const endTimeStr = supervisorData.endTime;
                        
                        if (startTimeStr && endTimeStr) {
                            const startTimeMinutes = utils.timeToMinutes(startTimeStr);
                            const endTimeMinutes = utils.timeToMinutes(endTimeStr);
                            
                            isCurrentVariant = (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
                        }
                        
                        const totalProduction = productionItem.actual.total || 0;
                        const supervisorProduction = supervisorData.production || 0;
                        const supervisorRatio = totalProduction > 0 ? supervisorProduction / totalProduction : 0;
                        
                        productionItem.batches.forEach(batch => {
                            let batchBelongsToSupervisor = false;
                            let supervisorUnits = 0;
                            let supervisorBoxes = 0;
                            
                            const supervisorIndex = productionItem.supervisors.findIndex(s => s.name === supervisorName);
                            
                            if (supervisorIndex === 0 && productionItem.supervisors.length === 1) {
                                batchBelongsToSupervisor = true;
                                supervisorUnits = batch.quantity;
                                supervisorBoxes = batch.boxes;
                            } else if (supervisorIndex !== -1) {
                                if (supervisorIndex < productionItem.batches.length) {
                                    if (productionItem.batches[supervisorIndex].id === batch.id) {
                                        batchBelongsToSupervisor = true;
                                        supervisorUnits = batch.quantity;
                                        supervisorBoxes = batch.boxes;
                                    }
                                } else {
                                    supervisorUnits = Math.round(batch.quantity * supervisorRatio);
                                    supervisorBoxes = Math.round(batch.boxes * supervisorRatio);
                                    batchBelongsToSupervisor = supervisorUnits > 0 || supervisorBoxes > 0;
                                }
                            }
                            
                            if (batchBelongsToSupervisor) {
                                processedBatches.push({
                                    supervisor: supervisorName,
                                    product: productName,
                                    variant: variantName,
                                    batchId: batch.id,
                                    units: supervisorUnits,
                                    boxes: supervisorBoxes,
                                    isCurrent: isCurrentVariant,
                                    isAssembly: productName.toLowerCase().includes('assembly'),
                                    supervisorOrder: state.selectedSupervisors.indexOf(supervisorName),
                                    startTimeMinutes: startTimeStr ? utils.timeToMinutes(startTimeStr) : 0
                                });
                            }
                        });
                    });
                });
                
                if (processedBatches.length === 0) {
                    elements.batchInfoTbody.innerHTML = '<tr><td colspan="5">No batch information available for selected supervisors</td></tr>';
                    return;
                }
                
                processedBatches.sort((a, b) => {
                    if (a.supervisorOrder !== b.supervisorOrder) {
                        return a.supervisorOrder - b.supervisorOrder;
                    }
                    
                    if (a.startTimeMinutes !== b.startTimeMinutes) {
                        return a.startTimeMinutes - b.startTimeMinutes;
                    }
                    
                    if (a.product !== b.product) {
                        return a.product.localeCompare(b.product);
                    }
                    
                    if (a.variant !== b.variant) {
                        return a.variant.localeCompare(b.variant);
                    }
                    
                    return a.batchId - b.batchId;
                });
                
                let currentSupervisor = null;
                let currentProduct = null;
                
                processedBatches.forEach(batch => {
                    if (batch.supervisor !== currentSupervisor) {
                        currentSupervisor = batch.supervisor;
                        currentProduct = null;
                        
                        const supervisorRow = document.createElement('tr');
                        supervisorRow.className = 'supervisor-header';
                        supervisorRow.style.backgroundColor = utils.getSupervisorColor(batch.supervisor);
                        
                        const supervisorCell = document.createElement('td');
                        supervisorCell.colSpan = 5;
                        supervisorCell.textContent = `SUPERVISOR: ${batch.supervisor}`;
                        
                        supervisorRow.appendChild(supervisorCell);
                        elements.batchInfoTbody.appendChild(supervisorRow);
                    }
                    
                    if (batch.product !== currentProduct) {
                        currentProduct = batch.product;
                        
                        const productRow = document.createElement('tr');
                        productRow.className = 'product-header';
                        
                        const productCell = document.createElement('td');
                        productCell.colSpan = 5;
                        productCell.textContent = batch.product;
                        
                        productRow.appendChild(productCell);
                        elements.batchInfoTbody.appendChild(productRow);
                    }
                    
                    const row = document.createElement('tr');
                    if (batch.isCurrent) {
                        row.className = 'current';
                    }
                    
                    const productCell = document.createElement('td');
                    productCell.style.opacity = '0.5';
                    productCell.textContent = batch.product;
                    row.appendChild(productCell);
                    
                    const variantCell = document.createElement('td');
                    variantCell.textContent = batch.variant;
                    row.appendChild(variantCell);
                    
                    const batchCell = document.createElement('td');
                    batchCell.className = 'batch-number';
                    batchCell.textContent = batch.batchId;
                    row.appendChild(batchCell);
                    
                    const unitsCell = document.createElement('td');
                    unitsCell.textContent = batch.units;
                    row.appendChild(unitsCell);
                    
                    const containerCell = document.createElement('td');
                    if (batch.isAssembly) {
                        containerCell.textContent = `${batch.boxes} Bags`;
                    } else {
                        containerCell.textContent = batch.boxes;
                    }
                    row.appendChild(containerCell);
                    
                    elements.batchInfoTbody.appendChild(row);
                });
            }
        };

        // ===== FULLSCREEN MANAGEMENT =====
        const fullscreenManager = {
            // Toggle fullscreen
            toggleFullscreen() {
                if (!document.fullscreenElement && 
                    !document.mozFullScreenElement && 
                    !document.webkitFullscreenElement && 
                    !document.msFullscreenElement) {
                    
                    try {
                        dom.toggleClass(elements.dashboardContainer, 'fullscreen-mode', true);
                        state.isFullscreen = true;
                        dom.updateText(elements.fullscreenButton, 'Exit Fullscreen');
                        
                        if (elements.dashboardContainer.requestFullscreen) {
                            elements.dashboardContainer.requestFullscreen();
                        } else if (elements.dashboardContainer.msRequestFullscreen) {
                            elements.dashboardContainer.msRequestFullscreen();
                        } else if (elements.dashboardContainer.mozRequestFullScreen) {
                            elements.dashboardContainer.mozRequestFullScreen();
                        } else if (elements.dashboardContainer.webkitRequestFullscreen) {
                            elements.dashboardContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                        } else {
                            this.simulatedFullscreen();
                        }
                    } catch (error) {
                        console.error('Fullscreen API error:', error);
                        this.simulatedFullscreen();
                    }
                } else {
                    try {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else {
                            this.exitSimulatedFullscreen();
                        }
                    } catch (error) {
                        console.error('Exiting fullscreen error:', error);
                        this.exitSimulatedFullscreen();
                    }
                }
            },

            // Handle fullscreen change
            handleFullscreenChange() {
                if (!document.fullscreenElement && 
                    !document.webkitFullscreenElement && 
                    !document.mozFullScreenElement && 
                    !document.msFullscreenElement) {
                    
                    if (state.isFullscreen) {
                        this.exitFullscreenMode();
                    }
                } else {
                    this.enterFullscreenMode();
                }
            },

            // Enter fullscreen mode
            enterFullscreenMode() {
                if (!state.isFullscreen) {
                    dom.toggleClass(elements.dashboardContainer, 'fullscreen-mode', true);
                    state.isFullscreen = true;
                    dom.updateText(elements.fullscreenButton, 'Exit Fullscreen');
                    
                    setTimeout(() => {
                        dashboardManager.updateDashboard();
                    }, 100);
                }
            },

            // Exit fullscreen mode
            exitFullscreenMode() {
                dom.toggleClass(elements.dashboardContainer, 'fullscreen-mode', false);
                dom.toggleClass(elements.dashboardContainer, 'simulated-fullscreen', false);
                state.isFullscreen = false;
                dom.updateText(elements.fullscreenButton, 'Fullscreen');
                
                elements.dashboardContainer.style.position = '';
                elements.dashboardContainer.style.top = '';
                elements.dashboardContainer.style.left = '';
                elements.dashboardContainer.style.width = '';
                elements.dashboardContainer.style.height = '';
                elements.dashboardContainer.style.zIndex = '';
                document.body.style.overflow = '';
                
                setTimeout(() => {
                    dashboardManager.updateDashboard();
                }, 100);
            },

            // Simulated fullscreen
            simulatedFullscreen() {
                dom.toggleClass(elements.dashboardContainer, 'fullscreen-mode', true);
                dom.toggleClass(elements.dashboardContainer, 'simulated-fullscreen', true);
                state.isFullscreen = true;
                dom.updateText(elements.fullscreenButton, 'Exit Fullscreen');
                
                elements.dashboardContainer.style.position = 'fixed';
                elements.dashboardContainer.style.top = '0';
                elements.dashboardContainer.style.left = '0';
                elements.dashboardContainer.style.width = '100vw';
                elements.dashboardContainer.style.height = '100vh';
                elements.dashboardContainer.style.zIndex = '9999';
                document.body.style.overflow = 'hidden';
                
                setTimeout(() => {
                    dashboardManager.updateDashboard();
                }, 100);
            },

            // Exit simulated fullscreen
            exitSimulatedFullscreen() {
                this.exitFullscreenMode();
            }
        };

        // ===== INITIALIZATION =====
        const initDashboard = () => {
            // Cache DOM references
            dom.cacheElements();
            
            // Setup initial state
            timeManager.updateDateTime();
            intervals.time = setInterval(timeManager.updateDateTime, 1000);
            
            // Event listeners
            elements.filterTypeSelect.addEventListener('change', function() {
                state.selectedFilterType = this.value;
                filterManager.updateFilterValueDropdown();
            });

            elements.filterValueSelect.addEventListener('change', function() {
                state.selectedFilterValue = this.value;
                dashboardManager.updateDashboard();
            });
            
            // Initialize supervisor selection
            supervisorManager.initSupervisorSelection();
            
            // Setup chart navigation
            chartManager.setupChartNavigation();
            
            // Initialize data
            dataManager.fetchProductionData();
            intervals.dataUpdate = setInterval(dataManager.fetchProductionData, CONFIG.UPDATE_INTERVAL);
            
            // Fullscreen event listeners
            elements.fullscreenButton.addEventListener('click', () => fullscreenManager.toggleFullscreen());
            window.addEventListener('resize', utils.debounce(() => dashboardManager.updateDashboard(), CONFIG.DEBOUNCE_DELAY));
            
            // Fullscreen change events
            document.addEventListener('fullscreenchange', () => fullscreenManager.handleFullscreenChange());
            document.addEventListener('webkitfullscreenchange', () => fullscreenManager.handleFullscreenChange());
            document.addEventListener('mozfullscreenchange', () => fullscreenManager.handleFullscreenChange());
            document.addEventListener('MSFullscreenChange', () => fullscreenManager.handleFullscreenChange());
        };

        // Initialize the dashboard when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initDashboard);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            utils.clearAllIntervals();
        });
    </script>
</body>
</html>
