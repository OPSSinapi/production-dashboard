<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
       :root {
    --primary-color: #2c3e50;
    --secondary-color: #3B82F6;
    --success-color: #10B981;
    --warning-color: #F59E0B;
    --danger-color: #e74c3c;
    --light-color: #f3f4f6;
    --dark-color: #1e293b;
    --supervisor-luthando: #F9E79F;
    --supervisor-apelele: #e6e6e6; /* Light grey for Apelele */
    --supervisor-siyabonga: #FADBD8;
    --supervisor-nosi: #D6EAF8;
    --supervisor-mvokwe: #D5F5E3;
    --supervisor-ayanda: #D7BDE2; /* Light purple for Ayanda */
    --production-color: #e74c3c; /* Red for production */
    --target-color: #10B981; /* Green for target */
    --current-indicator: #F59E0B; /* Yellow for current time indicator */
    --completed-variant: #D1E7DD; /* Light green for completed variants */
    --current-variant: #FFF3CD; /* Light yellow for current variant */
    --upcoming-variant: #F8D7DA; /* Light red for upcoming variants */
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--light-color);
    color: var(--primary-color);
    overflow: auto;
    transition: background-color 0.5s ease;
}

.dashboard-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    padding: 12px; /* Reduced padding */
    box-sizing: border-box;
    max-width: 1400px;
    margin: 0 auto;
    transition: background-color 0.5s ease;
}

.fullscreen-mode {
    display: grid;
    grid-template-rows: auto auto auto 1fr auto;
    padding: 8px !important;
    height: 100vh !important;
    width: 100vw !important;
    max-width: 100% !important;
    margin: 0 !important;
    overflow: hidden !important;
    box-sizing: border-box;
    background-color: var(--light-color) !important; /* Add this line */
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px; /* Reduced margin */
    padding-bottom: 5px; /* Reduced padding */
    border-bottom: 1px solid #e2e8f0;
    width: 100%;
}

.supervisor-color-banner {
    width: 100%;
    height: 10px;
    border-radius: 3px;
    margin-bottom: 5px;
}

.title-section {
    display: flex;
    align-items: center;
    gap: 15px; /* Reduced gap */
    flex-wrap: wrap;
}

.title {
    font-size: clamp(1.6rem, 2.4vw, 2.4rem);
    font-weight: bold;
    color: var(--primary-color);
}

.subtitle {
    font-size: clamp(1.2rem, 1.8vw, 1.8rem);
    color: var(--secondary-color);
    font-weight: 500;
}

.date-time {
    text-align: right;
    font-size: clamp(1rem, 1.4vw, 1.4rem);
}

.date {
    font-weight: bold;
}

.time {
    font-size: clamp(1.3rem, 1.8vw, 1.8rem);
    margin-top: 3px; /* Reduced margin */
}

.content {
    display: flex;
    flex-direction: column;
    width: 100%;
    overflow: hidden;
    flex: 1; /* Make sure content takes up available space */
}

/* Supervisor Container - Reduced Height */
.supervisor-container {
    display: flex;
    width: 100%;
    margin-bottom: 5px; /* Reduced from 10px */
    max-height: 120px; /* Add maximum height constraint */
}

.supervisor-bar {
    flex: 0 0 40%;
    border-radius: 8px;
    padding: 6px 10px; /* Reduced padding */
    box-sizing: border-box;
    margin-right: 10px;
    margin-bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.supervisor-name {
    font-size: clamp(1.4rem, 2.4vw, 2.4rem);
    font-weight: bold;
    margin-bottom: 2px; /* Reduced margin */
    color: var(--dark-color);
}

.supervisor-info {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.supervisor-title {
    font-size: clamp(1.2rem, 2vw, 2rem); /* Slightly reduced */
    font-weight: bold;
    color: var(--dark-color);
    margin-bottom: 2px; /* Reduced margin */
}

.product-name {
    font-size: clamp(1.1rem, 1.8vw, 1.8rem); /* Slightly reduced */
    color: var(--dark-color);
}

.variant-sequence-container {
    margin-top: 5px; /* Reduced from 10px */
    width: 100%;
}

.variant-sequence {
    display: flex;
    align-items: center;
    font-size: clamp(0.9rem, 1.4vw, 1.4rem); /* Slightly reduced */
    flex-wrap: wrap;
    gap: 6px; /* Reduced from 8px */
}

.variant-item {
    padding: 4px 10px; /* Reduced padding */
    border-radius: 4px;
    white-space: nowrap;
    position: relative;
    font-weight: 500;
}

.variant-time {
    font-size: clamp(0.7rem, 1.1vw, 1.1rem); /* Slightly reduced */
    display: block;
    text-align: center;
}

.variant-status {
    font-size: clamp(0.7rem, 1.1vw, 1.1rem);
    display: block;
    text-align: center;
    font-weight: bold;
}

.variant-item.completed {
    background-color: var(--completed-variant);
    color: var(--dark-color);
}

.variant-item.current {
    background-color: var(--current-variant);
    color: var(--dark-color);
    font-weight: bold;
}

.variant-item.upcoming {
    background-color: var(--upcoming-variant);
    color: var(--dark-color);
}

.arrow-right {
    margin: 0 4px;
    font-size: clamp(1.2rem, 2vw, 2rem);
    color: var(--dark-color);
}

/* Hourly targets wrapper - Reduced Height */
.hourly-targets-wrapper {
    flex: 0 0 58%;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    padding: 6px; /* Reduced from 10px */
    height: 100%;
    box-sizing: border-box;
    overflow: hidden;
}

.totals-display {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    margin-bottom: 10px;
    font-size: clamp(1rem, 1.3vw, 1.3rem);
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
    align-items: start;
}

.total-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 15px;
    width: 100%;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.total-label {
    font-weight: bold;
    margin-bottom: 4px;
    font-size: clamp(1.1rem, 1.8vw, 1.8rem);
    color: var(--dark-color);
    display: flex;
    align-items: center;
    gap: 8px;
    padding-bottom: 4px;
}

.total-percentage {
    color: var(--warning-color);
    font-size: 1em;
}

.total-value {
    font-size: clamp(1.6rem, 2.4vw, 2.4rem);
    font-weight: bold;
}

.total-subvalue {
    font-size: clamp(1rem, 1.6vw, 1.6rem);
    margin-top: 5px;
}

.current-value {
    color: var(--production-color);
}

.target-value {
    color: var(--target-color);
}

.total-hourly {
    color: var(--dark-color);
}

.chart-container {
    flex: 1; /* Takes all available space */
    background-color: white;
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    overflow: hidden;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    min-height: 0; /* Important for flex container */
    margin-top: 5px; /* Added small margin */
}

.charts-row {
    display: flex;
    gap: 10px;
    flex: 1;
    min-height: 0; /* Important for flex container */
    height: calc(80vh - 180px); /* Increased to use space gained from reduced supervisor section */
}

.chart {
    flex: 1;
    background-color: white;
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0; /* Important for flex container */
}

.chart-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    flex-wrap: nowrap;
    border-bottom: 1px solid #e2e8f0;
    padding-bottom: 10px;
}

/* Chart title and labels - Enlarged fonts */
.chart-title {
    font-size: clamp(1.5rem, 2.4vw, 2.4rem); /* Increased from 1.3rem */
    font-weight: 600;
    margin-right: 15px;
    color: var(--dark-color);
    white-space: nowrap;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.chart-title-select {
    background: none;
    border: none;
    color: var(--dark-color);
    font-weight: 600;
    font-size: clamp(1.5rem, 2.4vw, 2.4rem); /* Increased from 1.3rem */
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    cursor: pointer;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    display: inline-block;
}

.chart-title-select:focus {
    outline: none;
}

.chart-title-text {
    font-size: clamp(1.5rem, 2.4vw, 2.4rem); /* Increased from 1.3rem */
    font-weight: 600;
    color: var(--dark-color);
    white-space: nowrap;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.hour-info {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 10px;
    font-weight: 500;
    white-space: nowrap;
    margin-left: 10px;
}

.hour-countdown {
    font-size: clamp(1.2rem, 1.8vw, 1.8rem); /* Increased from 1rem */
    color: var(--secondary-color);
    font-style: normal;
}

.hour-select-container {
    margin-left: auto;
}

.hour-select {
    padding: 6px 12px;
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-family: inherit;
    background-color: white;
    height: 38px; /* Slightly increased */
    font-size: clamp(1.1rem, 1.6vw, 1.6rem); /* Increased from 0.9rem */
    font-weight: 500;
    color: var(--dark-color);
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.chart-area {
    flex: 1;
    position: relative;
    height: 100%;
    min-height: 0;
}

.line-chart, .bar-chart {
    height: 100%;
    width: 100%;
    min-height: 0; /* Important for SVG content */
}

.legend {
    display: flex;
    justify-content: center;
    margin-top: 8px;
    font-size: clamp(1.2rem, 1.8vw, 1.8rem); /* Increased from 1rem */
}

.legend-item {
    display: flex;
    align-items: center;
    margin: 0 12px;
}

.legend-color {
    width: 18px; /* Increased from 15px */
    height: 18px; /* Increased from 15px */
    margin-right: 8px;
    border-radius: 3px;
}

.production-color {
    background-color: var(--production-color);
}

.target-color {
    background-color: var(--target-color);
}

.footer {
    margin-top: 10px;
    text-align: center;
    font-size: clamp(1rem, 1.4vw, 1.4rem);
    color: var(--dark-color);
    width: 100%;
    display: flex;
    justify-content: flex-start;
    align-items: center;
}

.update-info {
    font-size: clamp(0.9rem, 1.4vw, 1.4rem);
    color: var(--dark-color);
    text-align: left;
}

.hourly-targets-container {
    height: 100%;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    margin-top: 0;
    position: relative;
}

.hourly-targets-svg {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    overflow: visible;
    height: 90px; /* Reduced fixed height */
}

.hourly-circle {
    fill: white;
    stroke: #999;
    stroke-width: 4;
    r: 25; /* Reduced from 40 */
}

.time-label {
    font-size: clamp(0.7rem, 1vw, 1rem); /* Smaller font */
    text-anchor: middle;
    dominant-baseline: hanging;
    fill: #333;
    font-weight: 600;
}

.current-arrow {
    fill: var(--warning-color);
    transform: scale(4.0); /* Reduced from 6.0 */
}

.status-icon {
    stroke-width: 4; /* Thinner lines for smaller circles */
}

.status-success {
    stroke: var(--target-color);
}

.status-fail {
    stroke: var(--production-color);
}

.filter-section {
    display: flex;
    gap: 10px;
    align-items: center;
}

.filter-select {
    padding: 8px 15px;
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-size: clamp(1rem, 1.6vw, 1.6rem);
    font-family: inherit;
    min-width: 180px;
    background-color: white;
}

.loading {
    text-align: center;
    padding: 20px;
    color: var(--dark-color);
    font-size: clamp(1.2rem, 1.8vw, 1.8rem);
}

.error {
    text-align: center;
    padding: 20px;
    color: var(--danger-color);
    font-weight: bold;
    font-size: clamp(1.2rem, 1.8vw, 1.8rem);
}

/* Chart axes labels applied via JS */
.chart-axis-label {
    font-size: 16px; /* Larger font for axis labels */
    font-weight: 500;
    fill: var(--dark-color);
}

.chart-data-label {
    font-size: 18px; /* Larger font for data point values */
    font-weight: 600;
}

/* Chart axis tick labels (the numbers on the axes) */
.chart-tick-label {
    font-size: 14px; /* Larger font for tick labels */
    fill: var(--dark-color);
}

/* Supervisor Selection Button and Modal */
.supervisor-selection-container {
    display: flex;
    align-items: center;
    margin-left: 15px;
}

.supervisor-select-btn {
    background-color: var(--secondary-color);
    color: white;
    padding: 8px 12px;
    font-size: clamp(0.9rem, 1.4vw, 1.4rem);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    font-family: inherit;
    transition: background-color 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.supervisor-select-btn:hover {
    background-color: #2563eb;
}

.supervisor-select-btn.secondary {
    background-color: #e2e8f0;
    color: var(--dark-color);
    margin-right: 10px;
}

.supervisor-select-btn.secondary:hover {
    background-color: #cbd5e1;
}

.supervisor-select-btn.primary {
    background-color: var(--success-color);
}

.supervisor-select-btn.primary:hover {
    background-color: #059669;
}

.supervisor-select-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
    animation-name: fadeIn;
    animation-duration: 0.3s;
}

@keyframes fadeIn {
    from {opacity: 0}
    to {opacity: 1}
}

.supervisor-select-content {
    position: relative;
    background-color: #fefefe;
    margin: 10% auto;
    padding: 0;
    border-radius: 8px;
    width: 80%;
    max-width: 600px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    animation-name: slideIn;
    animation-duration: 0.3s;
}

@keyframes slideIn {
    from {top: -300px; opacity: 0}
    to {top: 0; opacity: 1}
}

.supervisor-select-header {
    padding: 15px 20px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.supervisor-select-header h3 {
    margin: 0;
    font-size: 1.5rem;
    color: var(--dark-color);
}

.supervisor-select-close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.supervisor-select-close:hover {
    color: var(--dark-color);
}

.supervisor-select-body {
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

.supervisor-checkboxes {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.supervisor-checkbox-item {
    display: flex;
    align-items: center;
    padding: 10px;
    border-radius: 6px;
    transition: background-color 0.2s;
}

.supervisor-checkbox-item:hover {
    background-color: #f8fafc;
}

.supervisor-checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 15px;
    cursor: pointer;
}

.supervisor-checkbox-item label {
    font-size: 1.2rem;
    font-weight: 500;
    cursor: pointer;
    flex: 1;
}

.supervisor-select-footer {
    padding: 15px 20px;
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

/* Color indicators for supervisors */
.supervisor-color-indicator {
    width: 20px;
    height: 20px;
    display: inline-block;
    border-radius: 4px;
    margin-right: 15px;
}

.supervisor-active-badge {
    margin-left: auto;
    background-color: var(--success-color);
    color: white;
    font-size: 0.8rem;
    padding: 3px 8px;
    border-radius: 10px;
}

/* Make button more visible when supervisors are filtered */
.supervisor-select-btn.filtered {
    background-color: var(--warning-color);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
    70% { box-shadow: 0 0 0 5px rgba(245, 158, 11, 0); }
    100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
}

/* Dynamic supervisor color classes */
.dashboard-container.supervisor-luthando .supervisor-color-banner,
.dashboard-container.supervisor-luthando .supervisor-bar {
    background-color: var(--supervisor-luthando);
}

.dashboard-container.supervisor-apelele .supervisor-color-banner,
.dashboard-container.supervisor-apelele .supervisor-bar {
    background-color: var(--supervisor-apelele);
}

.dashboard-container.supervisor-siyabonga .supervisor-color-banner,
.dashboard-container.supervisor-siyabonga .supervisor-bar {
    background-color: var(--supervisor-siyabonga);
}

.dashboard-container.supervisor-nosi .supervisor-color-banner,
.dashboard-container.supervisor-nosi .supervisor-bar {
    background-color: var(--supervisor-nosi);
}

.dashboard-container.supervisor-mvokwe .supervisor-color-banner,
.dashboard-container.supervisor-mvokwe .supervisor-bar {
    background-color: var(--supervisor-mvokwe);
}

/* Responsive design */
@media (max-width: 1200px) {
    .supervisor-container {
        flex-direction: column;
    }
    
    .supervisor-bar {
        flex: 0 0 auto;
        width: 100%;
        margin-right: 0;
        margin-bottom: 10px;
    }
    
    .hourly-targets-wrapper {
        flex: 0 0 auto;
        width: 100%;
    }
    
    .hourly-circle {
        r: 35;
    }
    
    .supervisor-selection-container {
        margin-left: 10px;
    }
}

@media (max-width: 1024px) {
    .charts-row {
        flex-direction: column;
        height: auto;
    }
    
    .chart {
        height: 50vh; /* Increased from 45vh */
        min-height: 350px;
    }
    
    .dashboard-container {
        padding: 8px;
    }
}

@media (max-width: 768px) {
    .header {
        flex-direction: column;
        text-align: center;
    }
    
    .title-section {
        flex-direction: column;
        align-items: center;
        width: 100%;
    }
    
    .filter-section {
        flex-direction: column;
        width: 100%;
        margin-top: 10px;
    }
    
    .filter-select {
        width: 100%;
    }
    
    .date-time {
        text-align: center;
        margin-top: 10px;
    }
    
    .chart {
        height: 40vh;
        min-height: 300px;
    }
    
    .chart-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .hour-select-container {
        margin-left: 0;
        margin-top: 10px;
        width: 100%;
    }
    
    .hour-select {
        width: 100%;
    }
    
    .hourly-circle {
        r: 30;
    }
    
    .status-icon {
        stroke-width: 6;
    }
    
    .supervisor-selection-container {
        margin-top: 10px;
        margin-left: 0;
        width: 100%;
    }
    
    .supervisor-select-btn {
        width: 100%;
    }
    
    .supervisor-select-content {
        width: 95%;
        margin: 5% auto;
    }
}
    </style>
    </head>
<body>
    <div class="dashboard-container">
        <!-- Supervisor color banner -->
        <div class="supervisor-color-banner"></div>
        
        <div class="header">
            <div class="title-section">
                <div>
                    <div class="title">Production Dashboard</div>
                    <div class="subtitle" id="facility-name">Main Plant</div>
                </div>
                <div class="supervisor-color-banner"></div>
                <div class="filter-section">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
            </div>
            
            <div class="date-time">
                <div class="date" id="current-date">Loading...</div>
                <div class="time" id="current-time">Loading...</div>
                <button id="toggle-fullscreen-btn" class="fullscreen-button">Fullscreen</button>
            </div>
        </div>

        <div class="supervisor-selection-container">
            <button id="supervisor-filter-btn" class="supervisor-select-btn">
                Select Supervisors
            </button>
            <div id="supervisor-select-modal" class="supervisor-select-modal">
                <div class="supervisor-select-content">
                    <div class="supervisor-select-header">
                        <h3>Select Supervisors to Display</h3>
                        <span class="supervisor-select-close">&times;</span>
                    </div>
                    <div class="supervisor-select-body">
                        <div id="supervisor-checkboxes" class="supervisor-checkboxes">
                            <!-- Checkboxes will be added dynamically -->
                        </div>
                    </div>
                    <div class="supervisor-select-footer">
                        <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                        <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                        <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="content">
            
<!-- Modified Consolidated Supervisor Bar -->
<div class="supervisor-bar">
    <div class="supervisor-info">
        <span class="supervisor-title" id="supervisor-name">SUPERVISOR: Loading...</span>
        <span class="supervisor-title product-name" id="product-name">Product: Loading...</span>
    </div>
    <div class="variant-sequence-container">
        <div class="variant-sequence" id="variant-sequence">
            <div class="loading">Loading variants...</div>
        </div>
    </div>
</div>
            

            <div class="totals-display" id="totals-display">
                <div class="loading">Loading data...</div>
            </div>

            <div class="chart-container">
                <div class="charts-row">
                    <div class="chart">
                        <div class="chart-title" id="cumulative-chart-title">Loading...</div>
                        <div class="chart-area">
                            <div class="line-chart" id="cumulative-chart"></div>
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-color production-color"></div>
                                    <div>Cumulative Production</div>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color target-color"></div>
                                    <div>Cumulative Target</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chart">
                        <div class="chart-header">
                            <div class="chart-title-text">
                                <select id="hour-range-select" class="chart-title-select">
                                    <!-- Time slots will be added dynamically -->
                                </select>
                                <span> Production Progress</span>
                            </div>
                            <div class="hour-info" id="hour-info">
                                <div class="hour-countdown"></div>
                            </div>
                        </div>
                        <div class="chart-area">
                            <div class="bar-chart" id="hourly-chart"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div class="update-info" id="last-update2">Last updated: Never</div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 60 * 1000; // 1 minute update interval
        const CYCLE_INTERVAL = 20000; // 20 seconds cycle interval

        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        
        // Variables for product-supervisor grouping
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;
        let selectedSupervisors = []; // Array to hold selected supervisors    
        let supervisorFilterActive = false; // Track if supervisor filter is active
        
        // Cycling variables
        let cycleInterval = null;
        let cycleIndex = 0;

        // Add to initDashboard function
function initDashboard() {
    updateDateTime();
    setInterval(updateDateTime, 1000);

    document.getElementById('filter-type-select').addEventListener('change', function() {
        selectedFilterType = this.value;
        updateFilterValueDropdown();
    });

    document.getElementById('filter-value-select').addEventListener('change', function() {
        selectedFilterValue = this.value;
        updateDashboard();
    });

    document.getElementById('hour-range-select').addEventListener('change', function() {
        selectedHour = this.value;
        updateHourlyChart();
    });

    // Initialize supervisor selection
    initSupervisorSelection();
    
    fetchProductionData();
    setInterval(fetchProductionData, UPDATE_INTERVAL);

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
}

        function toggleFullscreen() {
            const container = document.querySelector('.dashboard-container');
            if (!container) return;
            
            if (!document.fullscreenElement &&
                !document.mozFullScreenElement &&
                !document.webkitFullscreenElement &&
                !document.msFullscreenElement) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            const container = document.querySelector('.dashboard-container');
            if (!container) return;
            
            if (document.fullscreenElement || 
                document.webkitFullscreenElement || 
                document.mozFullScreenElement || 
                document.msFullscreenElement) {
                container.classList.add('fullscreen-mode');
            } else {
                container.classList.remove('fullscreen-mode');
            }
        }

        // Add this function to initialize the supervisor selection UI
function initSupervisorSelection() {
    const selectBtn = document.getElementById('supervisor-filter-btn');
    if (!selectBtn) {
        console.error('supervisor-filter-btn not found in DOM');
        return; // Exit the function if the button doesn't exist
    }
    
    const modal = document.getElementById('supervisor-select-modal');
    if (!modal) {
        console.error('supervisor-select-modal not found in DOM');
        return;
    }
    
    const closeBtn = document.querySelector('.supervisor-select-close');
    const applyBtn = document.getElementById('apply-supervisor-selection');
    const selectAllBtn = document.getElementById('select-all-supervisors');
    const deselectAllBtn = document.getElementById('deselect-all-supervisors');
    
    // Check that all elements exist before adding event listeners
    if (!closeBtn || !applyBtn || !selectAllBtn || !deselectAllBtn) {
        console.error('One or more supervisor selection elements not found in DOM');
        return;
    }
    
    // Open modal when button is clicked
    selectBtn.addEventListener('click', function() {
        updateSupervisorFilter(); // Updated function name
        modal.style.display = 'block';
    });
    
    // Close modal when X is clicked
    closeBtn.addEventListener('click', function() {
        modal.style.display = 'none';
    });
    
    // Close modal when clicking outside of it
    window.addEventListener('click', function(event) {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    // Apply selection and close modal
    applyBtn.addEventListener('click', function() {
        applySupervisorSelection();
        modal.style.display = 'none';
    });
    
    // Select all supervisors
    selectAllBtn.addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('.supervisor-checkbox');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
    });
    
    // Deselect all supervisors
    deselectAllBtn.addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('.supervisor-checkbox');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
    });
    
    // Initialize with all supervisors selected
    if (productionData && productionData.personnel && productionData.personnel.supervisors) {
        selectedSupervisors = productionData.personnel.supervisors.map(supervisor => supervisor.id);
    }
}

        // Add this function to update the supervisor checkboxes
function updateSupervisorCheckboxes() {
    const checkboxContainer = document.getElementById('supervisor-checkboxes');
    checkboxContainer.innerHTML = '';
    
    if (!productionData || !productionData.supervisors || productionData.supervisors.length === 0) {
        checkboxContainer.innerHTML = '<p>No supervisors available</p>';
        return;
    }
    
    // Create a checkbox for each supervisor
    productionData.supervisors.forEach(supervisor => {
        const item = document.createElement('div');
        item.className = 'supervisor-checkbox-item';
        
        // Add supervisor color indicator
        const colorDiv = document.createElement('div');
        colorDiv.className = 'supervisor-color-indicator';
        colorDiv.style.backgroundColor = getSupervisorColor(supervisor.name);
        item.appendChild(colorDiv);
        
        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'supervisor-checkbox';
        checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
        checkbox.value = supervisor.name;
        checkbox.checked = selectedSupervisors.includes(supervisor.name);
        
        // Create label
        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = supervisor.name;
        
        // Add badge for active supervisor (currently displayed)
        if (currentSupervisor === supervisor.name) {
            const badge = document.createElement('span');
            badge.className = 'supervisor-active-badge';
            badge.textContent = 'Current';
            item.appendChild(badge);
        }
        
        item.appendChild(checkbox);
        item.appendChild(label);
        checkboxContainer.appendChild(item);
    });
}

// Add this function to apply supervisor selection
function applySupervisorSelection() {
    const checkboxes = document.querySelectorAll('.supervisor-checkbox');
    selectedSupervisors = [];
    
    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            selectedSupervisors.push(checkbox.value);
        }
    });
    
    // Store selection in localStorage for persistence
    localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
    
    // Update the selection button style based on whether filtering is active
    const supervisorFilterActive = productionData.personnel && productionData.personnel.supervisors ? 
        selectedSupervisors.length < productionData.personnel.supervisors.length : false;
    
    const selectBtn = document.getElementById('supervisor-filter-btn');
    if (!selectBtn) return;
    
    if (supervisorFilterActive) {
        const totalSupervisors = productionData.personnel?.supervisors?.length || 0;
        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${totalSupervisors})`;
        selectBtn.classList.add('filtered');
    } else {
        selectBtn.textContent = 'Select Supervisors';
        selectBtn.classList.remove('filtered');
    }
    
    // Update the dashboard with the new selection
    updateDashboard();
}

// Add this function to get the supervisor color
function getSupervisorColor(supervisorName) {
    const colorMap = {
        'Luthando': 'var(--supervisor-luthando)',
        'Apelele': 'var(--supervisor-apelele)',
        'Siyabonga': 'var(--supervisor-siyabonga)',
        'Nosi': 'var(--supervisor-nosi)',
        'Mvokwe': 'var(--supervisor-mvokwe)',
        'Ayanda': 'var(--supervisor-ayanda)' // Reusing Ayanda's color for Ayanda or add a new one
    };
    
    return colorMap[supervisorName] || '#e2e8f0'; // Default color if not found
}

// Add this to load selected supervisors from localStorage
function loadSelectedSupervisors() {
    const stored = localStorage.getItem('selectedSupervisors');
    if (stored) {
        try {
            selectedSupervisors = JSON.parse(stored);
            
            // Validate against current supervisors
            if (productionData && productionData.supervisors) {
                const validSupervisors = productionData.supervisors.map(s => s.name);
                selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                
                // If none valid, select all
                if (selectedSupervisors.length === 0) {
                    selectedSupervisors = validSupervisors;
                }
            }
            
            // Update UI
            supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (supervisorFilterActive) {
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                selectBtn.classList.add('filtered');
            }
        } catch (e) {
            console.error('Error parsing stored supervisors:', e);
            if (productionData && productionData.supervisors) {
                selectedSupervisors = productionData.supervisors.map(s => s.name);
            }
        }
    }
}

        function setupConsolidatedLayout() {
    // Check if the structure is already created
    if (!document.querySelector('.supervisor-container')) {
        const content = document.querySelector('.content');
        const supervisorBar = document.querySelector('.supervisor-bar');
        const totalsDisplay = document.getElementById('totals-display');
        
        // Create container for supervisor and hourly targets
        const supervisorContainer = document.createElement('div');
        supervisorContainer.className = 'supervisor-container';
        
        // Move supervisor bar into container
        if (supervisorBar) {
            supervisorBar.parentNode.removeChild(supervisorBar);
            supervisorContainer.appendChild(supervisorBar);
        }
        
        // Create wrapper for hourly targets
        const hourlyTargetsWrapper = document.createElement('div');
        hourlyTargetsWrapper.className = 'hourly-targets-wrapper';
        hourlyTargetsWrapper.innerHTML = '<div class="total-label">Hourly Targets</div><div id="hourly-targets-container" class="hourly-targets-container"></div>';
        supervisorContainer.appendChild(hourlyTargetsWrapper);
        
        // Insert the new container before totals display
        content.insertBefore(supervisorContainer, totalsDisplay);
    }
}
        
        function applySupervisorStyling(supervisorId) {
    const dashboardContainer = document.querySelector('.dashboard-container');
    dashboardContainer.classList.remove('supervisor-luthando', 'supervisor-apelele', 'supervisor-siyabonga', 'supervisor-nosi', 'supervisor-mvokwe', 'supervisor-ayanda');
    if (supervisorId) {
        const supervisorClass = 'supervisor-' + supervisorId.toLowerCase();
        dashboardContainer.classList.add(supervisorClass);
    }
}

        function updateHourDropdown() {
            const hourSelect = document.getElementById('hour-range-select');
            
            // Clear existing options
            while (hourSelect.options.length > 0) hourSelect.remove(0);
            
            // Get all production hours from the current product
            const productionHours = new Set();
            
            if (currentProductVariants.length > 0) {
                const product = currentProductVariants[0]; // Only one product now, not multiple variants
                
                if (product.timeline && product.timeline.byHour) {
                    product.timeline.byHour.forEach(item => {
                        if (item.hour) productionHours.add(item.hour);
                    });
                }
            }
            
            // Use default hours if no production hours available
            if (productionHours.size === 0) {
                const defaultHours = ["08:30", "09:30", "10:30", "11:30", "12:30", "13:30", "14:30", "15:30", "16:30", "17:30", "18:30"];
                defaultHours.forEach(hour => productionHours.add(hour));
            }
            
            // Sort the hours
            const sortedHours = Array.from(productionHours).sort((a, b) => {
                const [ha, ma] = a.split(':').map(Number);
                const [hb, mb] = b.split(':').map(Number);
                return (ha * 60 + ma) - (hb * 60 + mb);
            });
            
            // Get current hour for "current" option
            const nextHour = getNextProductionHour(sortedHours);
            let currentHourOption = null;
            
            // Add time ranges as options
            sortedHours.forEach((hour, index) => {
                const [hourVal, minuteVal] = hour.split(':').map(Number);
                
                // Calculate previous hour (for start of range)
                let prevHour, prevMinute;
                
                if (index > 0) {
                    // If not the first hour, use the previous hour from our sorted list
                    const prevTimeStr = sortedHours[index - 1];
                    [prevHour, prevMinute] = prevTimeStr.split(':').map(Number);
                } else {
                    // For the first hour, calculate 1 hour before
                    prevHour = hourVal - 1;
                    prevMinute = minuteVal;
                    
                    // Handle the case when the first hour is before 1:00
                    if (prevHour < 0) {
                        prevHour = 23; // Wrap to previous day
                    }
                }
                
                // Format for option text
                const timeRange = `${prevHour.toString().padStart(2, '0')}:${prevMinute.toString().padStart(2, '0')}-${hourVal.toString().padStart(2, '0')}:${minuteVal.toString().padStart(2, '0')}`;
                
                const option = document.createElement('option');
                option.value = hour; // Store the end hour as value
                option.textContent = timeRange;
                
                // If this is the current hour range, save it for "current" option
                if (hour === nextHour) {
                    currentHourOption = { value: "current", text: timeRange };
                }
                
                hourSelect.appendChild(option);
            });
            
            // Add the "current" hour option at the top if it exists
            if (currentHourOption) {
                const currentOption = document.createElement('option');
                currentOption.value = currentHourOption.value;
                currentOption.textContent = currentHourOption.text;
                hourSelect.insertBefore(currentOption, hourSelect.firstChild);
            }
            
            // Set the selected hour in the dropdown
            if (selectedHour === "current" && currentHourOption) {
                hourSelect.value = "current";
            } else if (Array.from(hourSelect.options).some(opt => opt.value === selectedHour)) {
                hourSelect.value = selectedHour;
            } else if (hourSelect.options.length > 0) {
                selectedHour = hourSelect.options[0].value; // Default to first option
                hourSelect.value = selectedHour;
            }
        }

        function getNextProductionHour(productionHours) {
            const now = new Date();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            
            if (!productionHours || productionHours.length === 0) {
                productionHours = ["08:30", "09:30", "10:30", "11:30", "12:30", "13:30", "14:30", "15:30", "16:30", "17:30", "18:30"];
            }
            
            // Sort the production hours
            productionHours.sort((a, b) => {
                const [ha, ma] = a.split(':').map(Number);
                const [hb, mb] = b.split(':').map(Number);
                return (ha * 60 + ma) - (hb * 60 + mb);
            });
            
            // If current time is before the first production hour, return the first hour
            if (productionHours.length > 0) {
                const [firstHour, firstMinute] = productionHours[0].split(':').map(Number);
                const firstHourInMinutes = firstHour * 60 + firstMinute;
                
                if (currentTime < firstHourInMinutes) {
                    return productionHours[0];
                }
            }
            
            // Original logic for when we're within production hours
            for (const hourStr of productionHours) {
                const [hours, minutes] = hourStr.split(':').map(Number);
                const hourInMinutes = hours * 60 + minutes;
                if (hourInMinutes > currentTime) return hourStr;
            }
            
            // If current time is after all production hours, return the last hour
            return productionHours[productionHours.length - 1];
        }

        function calculateTimeToNextHour(hourStr) {
            const now = new Date();
            const [hours, minutes] = hourStr.split(':').map(Number);
            const targetTime = new Date(now);
            targetTime.setHours(hours, minutes, 0, 0);
            if (targetTime <= now) targetTime.setDate(targetTime.getDate() + 1);
            const diffMs = targetTime - now;
            const diffMinutes = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMinutes / 60);
            const remainingMinutes = diffMinutes % 60;
            return diffHours > 0 ? `Countdown: ${diffHours}h ${remainingMinutes}m` : `Countdown: ${remainingMinutes}m`;
        }

        function startCountdown(hourStr) {
            if (countdownInterval) clearInterval(countdownInterval);
            updateCountdown(hourStr);
            countdownInterval = setInterval(() => updateCountdown(hourStr), 60000);
        }

        function updateCountdown(hourStr) {
            document.querySelector('.hour-countdown').textContent = calculateTimeToNextHour(hourStr);
        }

        function calculateActualCycleTime(variants) {
    // Get current time to calculate elapsed time
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTimeMinutes = currentHour * 60 + currentMinute;
    
    let totalProduction = 0;
    let totalElapsedWorkingTime = 0;
    
    variants.forEach(variant => {
        const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
        if (supervisor && supervisor.variants[variant.variant]) {
            const supervisorVariant = supervisor.variants[variant.variant];
            
            if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                
                if (startTimeStr) {
                    const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                    const startTotalMinutes = startHours * 60 + startMinutes;
                    
                    // Calculate elapsed time in minutes (from start until now)
                    let elapsedMinutes = currentTimeMinutes - startTotalMinutes;
                    if (elapsedMinutes < 0) {
                        elapsedMinutes += 24 * 60; // Handle case where start was yesterday
                    }
                    
                    // Calculate elapsed break time
                    const elapsedBreakMinutes = calculateElapsedBreakMinutes(variant, startTimeStr, now);
                    
                    // Calculate actual working time
                    const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                    
                    // Add to totals
                    totalProduction += supervisorVariant.currentTotal;
                    totalElapsedWorkingTime += workingMinutes * 60; // Convert to seconds
                }
            }
        }
    });
    
    if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
    
    // Calculate overall cycle time
    return Math.round(totalElapsedWorkingTime / totalProduction);
}

function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
    let totalElapsedBreakMinutes = 0;
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    // Function to check if a break has already occurred or is occurring
    const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
        if (!breakStartStr || !breakEndStr) return 0;
        if (breakStartStr === "-" || breakEndStr === "-") return 0;
        
        const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
        const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
        
        const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
        const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
        
        // If break hasn't started yet, return 0
        if (currentTime < breakStartMinutes) return 0;
        
        // If break is in progress, return elapsed portion
        if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
        
        // If break is complete, return full duration
        return breakEndMinutes - breakStartMinutes;
    };
    
    // Check each break
    if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
    }
    
    if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
    }
    
    if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
        variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
    }
    
    return totalElapsedBreakMinutes;
}

// New helper function to calculate only elapsed break time
function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
    let totalElapsedBreakMinutes = 0;
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    // Function to check if a break has already occurred or is occurring
    const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
        if (!breakStartStr || !breakEndStr) return 0;
        if (breakStartStr === "-" || breakEndStr === "-") return 0;
        
        const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
        const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
        
        const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
        const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
        
        // If break hasn't started yet, return 0
        if (currentTime < breakStartMinutes) return 0;
        
        // If break is in progress, return elapsed portion
        if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
        
        // If break is complete, return full duration
        return breakEndMinutes - breakStartMinutes;
    };
    
    // Check each break
    if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
    }
    
    if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
    }
    
    if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
        variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
    }
    
    return totalElapsedBreakMinutes;
}

        function calculateBreakMinutes(variant, startTimeStr, endTimeStr) {
            let totalBreakMinutes = 0;
            
            // Function to check if break is within working period
            const isBreakInWorkPeriod = (breakStartStr, breakEndStr) => {
                if (!breakStartStr || !breakEndStr) return false;
                
                const [workStartHour, workStartMinute] = startTimeStr.split(':').map(Number);
                const [workEndHour, workEndMinute] = endTimeStr.split(':').map(Number);
                const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
                const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
                
                const workStartMinutes = workStartHour * 60 + workStartMinute;
                const workEndMinutes = workEndHour * 60 + workEndMinute;
                const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
                const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
                
                // Check if break overlaps with work period
                return (breakStartMinutes >= workStartMinutes && breakStartMinutes < workEndMinutes) ||
                       (breakEndMinutes > workStartMinutes && breakEndMinutes <= workEndMinutes) ||
                       (breakStartMinutes <= workStartMinutes && breakEndMinutes >= workEndMinutes);
            };
            
            // Check each break
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"] &&
                isBreakInWorkPeriod(variant["Break Start (Lunch)"], variant["Break End (Lunch)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
            }
            
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"] &&
                isBreakInWorkPeriod(variant["Break Start (Tea)"], variant["Break End (Tea)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
            }
            
            if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-" &&
                isBreakInWorkPeriod(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"])) {
                totalBreakMinutes += getTimeDifferenceInMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
            }
            
            return totalBreakMinutes;
        }

        function getTimeDifferenceInMinutes(startTimeStr, endTimeStr) {
            const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
            const [endHours, endMinutes] = endTimeStr.split(':').map(Number);
            
            let startTotalMinutes = startHours * 60 + startMinutes;
            let endTotalMinutes = endHours * 60 + endMinutes;
            
            // Handle if break ends next day
            if (endTotalMinutes < startTotalMinutes) {
                endTotalMinutes += 24 * 60;
            }
            
            return endTotalMinutes - startTotalMinutes;
        }

        function extractProductFromVariant(variantName) {
            // Simple product extraction - assumes format "ProductName VariantName"
            const parts = variantName.split(' ');
            
            // Handle different formats
            if (parts.length === 1) return variantName; // No space, use as is
            if (parts.length === 2) return parts[0]; // Simple "Product Variant"
            
            // For more complex formats, try to find a pattern
            // Example: "LEVO XL1150SCi" -> "LEVO XL"
            const match = variantName.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            // Fallback: use first word
            return parts[0];
        }
        // Add to fetchProductionData function after data is loaded
async function fetchProductionData() {
    try {
        console.log(`Attempting to fetch data from: ${DATA_URL}`);
        const cacheBuster = '?_=' + new Date().getTime();
        const response = await fetch(DATA_URL + cacheBuster);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        
        if (!data.metadata || !data.products || !Array.isArray(data.products) || !data.personnel || !data.personnel.supervisors) {
            throw new Error('Invalid data structure in data.json');
        }
        
        if (!lastUpdateTime || lastUpdateTime !== data.metadata.timestamp) {
            productionData = data;
            lastUpdateTime = data.metadata.timestamp;
            
            // Update only the footer timestamp
            document.getElementById('last-update2').textContent = 'Last updated: ' + data.metadata.timestamp;
            
            // Process product-supervisor groups from the new data
            processProductSupervisorGroups();
            
            // Load saved supervisor selections or initialize all selected
            if (selectedSupervisors.length === 0) {
                selectedSupervisors = productionData.personnel.supervisors.map(supervisor => supervisor.id);
                loadSelectedSupervisors(); // Load any saved preferences
            }
            
            updateFilterValueDropdown();
            updateDashboard();
            updateHourDropdown();
        }
        
        isLoading = false;
    } catch (error) {
        console.error(`Fetch failed:`, error);
        isLoading = false;
        showLoadingOrError(`Failed to load data: ${error.message}`);
    }
}

        function processProductSupervisorGroups() {
            // Reset groups
            productSupervisorGroups = {};
            
            // First, create supervisor-product mapping from assignments
            productionData.personnel.supervisors.forEach(supervisor => {
                if (!supervisor.assignments || !Array.isArray(supervisor.assignments)) return;
                
                // Process each assignment
                supervisor.assignments.forEach(assignment => {
                    const productId = assignment.productId;
                    
                    // Find the product in the products array
                    const product = productionData.products.find(p => p.id === productId);
                    
                    if (product) {
                        const group = `${supervisor.id}:${product.id}`;
                        
                        // Store in groups
                        productSupervisorGroups[group] = {
                            supervisor: supervisor.id,
                            product: product.name,
                            productId: product.id,
                            variants: [product], // Use product directly instead of variants
                            supervisorData: supervisor,
                            productData: product,
                            assignment: assignment,
                            shiftData: productionData.schedule.shifts.find(s => s.id === product.shiftRef)
                        };
                    }
                });
            });
            
            console.log('Product-Supervisor Groups:', productSupervisorGroups);
        }

        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear existing options (except 'all')
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.personnel?.supervisors?.length > 0) {
                // Add all supervisors
                productionData.personnel.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.id;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                // Add all unique products
                const uniqueProducts = new Set();
                
                // Extract products from all variants
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.productId);
                });
                
                // Add options
                uniqueProducts.forEach(productId => {
                    const product = productionData.products.find(p => p.id === productId);
                    if (product) {
                        const option = document.createElement('option');
                        option.value = product.id;
                        option.textContent = product.name;
                        filterValueSelect.appendChild(option);
                    }
                });
            }
            
            // Try to restore previous selection if it exists
            for (let i = 0; i < filterValueSelect.options.length; i++) {
                if (filterValueSelect.options[i].value === currentValue) {
                    filterValueSelect.selectedIndex = i;
                    break;
                }
            }
        }

        function showLoadingOrError(message) {
            const totalsDisplay = document.getElementById('totals-display');
            totalsDisplay.innerHTML = `<div class="${isLoading ? 'loading' : 'error'}">${message}</div>`;
            
            document.getElementById('supervisor-name').textContent = 'SUPERVISOR: Loading...';
            document.getElementById('product-name').textContent = 'Product: Loading...';
            document.getElementById('variant-sequence').innerHTML = '<div class="loading">Loading variants...</div>';
            
            document.querySelectorAll('.line-chart, .bar-chart').forEach(chart => {
                chart.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
            });
        }

        function updateDateTime() {
            const now = new Date();
            document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', {
                month: 'long', day: 'numeric', year: 'numeric'
            });
            
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            
            // Check if we need to update dashboard based on time changes (variant transitions)
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                // Check if we crossed a variant boundary
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if we just crossed this boundary
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }
        // Modify the updateDashboard function to filter by selected supervisors
function updateDashboard() {
    // Filter groups based on selection and selected supervisors
    let filteredGroups = {};
    
    // Start with selected filter type/value
    if (selectedFilterValue === 'all') {
        // When "all" is selected, still respect supervisor selection
        Object.keys(productSupervisorGroups).forEach(key => {
            if (selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                filteredGroups[key] = productSupervisorGroups[key];
            }
        });
    } else if (selectedFilterType === 'supervisor') {
        // When filtering by specific supervisor, also check if it's in selected supervisors
        Object.keys(productSupervisorGroups).forEach(key => {
            if (productSupervisorGroups[key].supervisor === selectedFilterValue &&
                selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                filteredGroups[key] = productSupervisorGroups[key];
            }
        });
    } else if (selectedFilterType === 'product') {
        // Filter by product but only for selected supervisors
        Object.keys(productSupervisorGroups).forEach(key => {
            if (productSupervisorGroups[key].productId === selectedFilterValue &&
                selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                filteredGroups[key] = productSupervisorGroups[key];
            }
        });
    }
    
    // If no groups after filtering, show error and return
    if (Object.keys(filteredGroups).length === 0) {
        showLoadingOrError("No production data available for the selected filter");
        return;
    }
    
    // Sort groups by supervisor and product
    const sortedGroupKeys = Object.keys(filteredGroups).sort((a, b) => {
        const groupA = filteredGroups[a];
        const groupB = filteredGroups[b];
        
        // First sort by supervisor
        if (groupA.supervisor !== groupB.supervisor) {
            return groupA.supervisor.localeCompare(groupB.supervisor);
        }
        
        // Then by product name
        return groupA.product.localeCompare(groupB.product);
    });
    
    // Display the first group
    displayGroup(filteredGroups[sortedGroupKeys[0]]);
    
    // Show dashboard, hide loading message
    hideLoadingMessage();
}

        function displayGroup(group) {
    // Set current product and supervisor
    currentProduct = group.productId;
    currentSupervisor = group.supervisor;
    currentProductVariants = group.variants;
    
    // Apply supervisor styling
    applySupervisorStyling(group.supervisor);
    
    // Supervisor info section
    document.getElementById('supervisor-name').textContent = group.supervisorData.name;
    document.getElementById('product-name').textContent = group.product;
    
    // Update supervisor color banner
    const banner = document.querySelector('.supervisor-color-banner');
    banner.classList.remove('supervisor-luthando', 'supervisor-apelele', 'supervisor-siyabonga', 'supervisor-nosi', 'supervisor-mvokwe');
    banner.classList.add('supervisor-' + group.supervisor.toLowerCase());
    
    // Update variant sequence - now showing assignment times
    const sequenceContainer = document.getElementById('variant-sequence');
    sequenceContainer.innerHTML = '';
    
    const assignment = group.assignment;
    const product = group.productData;
    
    if (assignment) {
        // Add assignment time info
        const startTime = assignment.startTime;
        const endTime = assignment.endTime;
        
        // Get current time to determine status
        const now = new Date();
        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
        
        // Parse start and end times
        const [startHour, startMinute] = startTime.split(':').map(Number);
        const [endHour, endMinute] = endTime.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Determine assignment status
        let status = '';
        if (currentTimeMinutes < startTimeMinutes) {
            status = 'upcoming';
        } else if (currentTimeMinutes > endTimeMinutes) {
            status = 'completed';
        } else {
            status = 'current';
        }
        
        // Create the variant item with start/end times
        const variantItem = document.createElement('div');
        variantItem.className = `variant-item ${status}`;
        
        // Add time spans
        const timeSpan = document.createElement('span');
        timeSpan.className = 'variant-time';
        timeSpan.textContent = `${startTime} - ${endTime}`;
        variantItem.appendChild(timeSpan);
        
        // Add progress status
        const statusSpan = document.createElement('span');
        statusSpan.className = 'variant-status';
        statusSpan.textContent = `${assignment.progress}%`;
        variantItem.appendChild(statusSpan);
        
        sequenceContainer.appendChild(variantItem);
    } else {
        sequenceContainer.innerHTML = '<div>No assignment information</div>';
    }
    
    // Update totals
    updateTotals(group);
    
    // Update time-series chart for production vs targets
    updateProductionChart(group);
    
    // Update hour dropdown
    updateHourDropdown();
}

        function updateSupervisorInfo(group) {
    document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${group.supervisor}`;
    document.getElementById('product-name').textContent = `${group.product}`;
    
    // Update variant sequence
    const sequenceContainer = document.getElementById('variant-sequence');
    sequenceContainer.innerHTML = '';
    
    if (group.variants.length === 0) {
        sequenceContainer.innerHTML = '<div>No variants available</div>';
        return;
    }
    
    // Get current time to determine variant status
    const now = new Date();
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    
    // Add each variant to the sequence with simplified display
    group.variants.forEach((variant, index) => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Determine variant status
        let status = '';
        if (currentTimeMinutes < startTimeMinutes) {
            status = 'upcoming';
        } else if (currentTimeMinutes > endTimeMinutes) {
            status = 'completed';
        } else {
            status = 'current';
        }
        
        // Extract variant name from full variant string
        let displayName = variant.variant;
        
        // Try to extract just the variant part
        if (variant.variant.startsWith(group.product + ' ')) {
            displayName = variant.variant.substring(group.product.length + 1);
        }
        
        // Create simplified variant element
        const variantElement = document.createElement('div');
        variantElement.className = `variant-item ${status}`;
        variantElement.innerHTML = `
            <span>${displayName}</span>
            <span class="variant-time">${startTimeStr}-${endTimeStr}</span>
        `;
        
        sequenceContainer.appendChild(variantElement);
        
        // Add arrow if not the last variant
        if (index < group.variants.length - 1) {
            const arrow = document.createElement('div');
            arrow.className = 'arrow-right';
            arrow.textContent = '→';
            sequenceContainer.appendChild(arrow);
        }
    });
}

        function updateTotals(group) {
    const totalsDisplay = document.querySelector('.totals-display');
    totalsDisplay.innerHTML = '';
    
    const product = group.productData;
    const assignment = group.assignment;
    
    // Product information
    const totalItem1 = document.createElement('div');
    totalItem1.className = 'total-item';
    totalItem1.innerHTML = `
        <div class="total-label">Device Type</div>
        <div class="total-value">${product.name}</div>
        <div class="total-subvalue">Cycle Time: ${product.cycleTime}s</div>
        <div class="total-subvalue">${product.devicesPerBox} per box</div>
    `;
    totalsDisplay.appendChild(totalItem1);
    
    // Production targets
    const totalItem2 = document.createElement('div');
    totalItem2.className = 'total-item';
    totalItem2.innerHTML = `
        <div class="total-label">Targets</div>
        <div class="total-value target-value">${product.targets.daily}</div>
        <div class="total-subvalue">Hourly: ${product.targets.hourly}</div>
        <div class="total-subvalue">Boxes: ${product.targets.boxes}</div>
    `;
    totalsDisplay.appendChild(totalItem2);
    
    // Current production
    const totalItem3 = document.createElement('div');
    totalItem3.className = 'total-item';
    totalItem3.innerHTML = `
        <div class="total-label">Production <span class="total-percentage">${product.production.progress}%</span></div>
        <div class="total-value current-value">${product.production.total}</div>
        <div class="total-subvalue">Boxes: ${product.production.boxes}</div>
        <div class="total-subvalue">Batch: ${product.production.batches[0]?.id || 'N/A'}</div>
    `;
    totalsDisplay.appendChild(totalItem3);
    
    // Supervisor metrics
    const totalItem4 = document.createElement('div');
    totalItem4.className = 'total-item';
    totalItem4.innerHTML = `
        <div class="total-label">Supervisor Metrics</div>
        <div class="total-value">${assignment ? assignment.progress + '%' : 'N/A'}</div>
        <div class="total-subvalue">Target: ${assignment ? assignment.target : 'N/A'}</div>
        <div class="total-subvalue">Actual: ${assignment ? assignment.actual : 'N/A'}</div>
    `;
    totalsDisplay.appendChild(totalItem4);
    
    // Shift information
    if (group.shiftData) {
        const totalItem5 = document.createElement('div');
        totalItem5.className = 'total-item';
        totalItem5.innerHTML = `
            <div class="total-label">Shift</div>
            <div class="total-value">${group.shiftData.id}</div>
            <div class="total-subvalue">${group.shiftData.startTime} - ${group.shiftData.endTime}</div>
            <div class="total-subvalue">Work Hours: ${group.shiftData.availableWorkHours}</div>
        `;
        totalsDisplay.appendChild(totalItem5);
    }
}

function updateProductionChart(group) {
    const product = group.productData;
    
    // Clear previous chart
    const chartArea = document.querySelector('.chart-area');
    if (!chartArea) {
        console.error('Chart area element not found');
        return;
    }
    chartArea.innerHTML = '';
    
    // Set chart title
    const chartTitle = document.querySelector('.chart-title');
    if (chartTitle) {
        chartTitle.textContent = `${product.name} Production`;
    }
    
    // Check if Chart.js is loaded
    if (typeof Chart === 'undefined') {
        console.error('Chart.js is not loaded. Unable to create chart.');
        // Create a fallback display
        const fallbackDiv = document.createElement('div');
        fallbackDiv.className = 'chart-fallback';
        fallbackDiv.innerHTML = `
            <h3>Chart Could Not Be Loaded</h3>
            <p>Production: ${product.production.total} / ${product.targets.daily} (${product.production.progress}%)</p>
            <p>Boxes: ${product.production.boxes} / ${product.targets.boxes}</p>
        `;
        chartArea.appendChild(fallbackDiv);
        return;
    }
    
    // Create canvas for Chart.js
    const canvas = document.createElement('canvas');
    canvas.className = 'line-chart';
    chartArea.appendChild(canvas);
    
    // Extract timeline data
    const hours = product.timeline.byHour.map(item => item.hour);
    const targets = product.timeline.byHour.map(item => item.target);
    const actuals = product.timeline.byHour.map(item => item.actual);
    const cumTargets = product.timeline.byHour.map(item => item.cumTarget);
    const cumActuals = product.timeline.byHour.map(item => item.cumActual);
    
    try {
        // Create chart
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: hours,
                datasets: [
                    {
                        label: 'Cum. Target',
                        data: cumTargets,
                        borderColor: 'rgba(16, 185, 129, 1)', // Green
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        borderWidth: 3
                    },
                    {
                        label: 'Cum. Actual',
                        data: cumActuals,
                        borderColor: 'rgba(231, 76, 60, 1)', // Red
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        borderWidth: 3
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                size: 14
                            }
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                }
            }
        });
        
        // Update hour countdown based on current time
        updateHourCountdown(hours);
    } catch (error) {
        console.error('Error creating chart:', error);
        // Provide a fallback display
        chartArea.innerHTML = '';
        const errorDiv = document.createElement('div');
        errorDiv.className = 'chart-error';
        errorDiv.textContent = 'Unable to create chart. Please check console for details.';
        chartArea.appendChild(errorDiv);
    }
}

function updateHourCountdown(hours) {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTimeMinutes = currentHour * 60 + currentMinute;
    
    // Find next production hour
    let nextHourStr = null;
    let minutesToNext = null;
    
    for (const hourStr of hours) {
        const [hour, minute] = hourStr.split(':').map(Number);
        const hourTimeMinutes = hour * 60 + minute;
        
        if (hourTimeMinutes > currentTimeMinutes) {
            nextHourStr = hourStr;
            minutesToNext = hourTimeMinutes - currentTimeMinutes;
            break;
        }
    }
    
    // Update countdown display
    const countdownEl = document.querySelector('.hour-countdown');
    if (nextHourStr && minutesToNext !== null) {
        countdownEl.textContent = `Next: ${nextHourStr} (${minutesToNext} min)`;
    } else {
        countdownEl.textContent = 'Completed';
    }
}

        function renderCumulativeChart(group) {
    const chartContainer = document.getElementById('cumulative-chart');
    const chartTitle = document.getElementById('cumulative-chart-title');
    chartContainer.innerHTML = '';
    
    const currentDay = new Date().toLocaleDateString('en-US', { weekday: 'long' });
    chartTitle.textContent = `${currentDay}'s Production Progress`;
    
    // Collect all hours across all variants
    const allHoursSet = new Set();
    const hourlyProductionMap = new Map(); // Map to store production by hour
    const hourlyTargetMap = new Map();     // Map to store targets by hour
    
    // Process each variant and collect unique hours
    group.variants.forEach(variant => {
        // Get variant time window
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Collect hourly production data
        if (variant.hourlyProduction) {
            variant.hourlyProduction.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly production map
                    if (!hourlyProductionMap.has(item.hour)) {
                        hourlyProductionMap.set(item.hour, 0);
                    }
                    hourlyProductionMap.set(item.hour, hourlyProductionMap.get(item.hour) + (item.production || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
        
        // Collect hourly target data
        if (variant.hourlyTargets) {
            variant.hourlyTargets.forEach(item => {
                if (!item.hour) return;
                
                const [itemHour, itemMinute] = item.hour.split(':').map(Number);
                const itemTimeMinutes = itemHour * 60 + itemMinute;
                
                if (itemTimeMinutes >= startTimeMinutes && itemTimeMinutes <= endTimeMinutes) {
                    // Add to hourly target map
                    if (!hourlyTargetMap.has(item.hour)) {
                        hourlyTargetMap.set(item.hour, 0);
                    }
                    hourlyTargetMap.set(item.hour, hourlyTargetMap.get(item.hour) + (item.target || 0));
                    
                    allHoursSet.add(item.hour);
                }
            });
        }
    });
    
    // Convert to sorted array of hours
    const sortedHours = Array.from(allHoursSet).sort((a, b) => {
        const [hourA, minuteA] = a.split(':').map(Number);
        const [hourB, minuteB] = b.split(':').map(Number);
        return (hourA * 60 + minuteA) - (hourB * 60 + minuteB);
    });
    
    if (sortedHours.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
        return;
    }
    
    // Build cumulative data arrays - modified to maintain continuity across variants
    const cumulativeData = [];
    let runningProductionTotal = 0;
    let runningTargetTotal = 0;
    
    // Generate time-based data points - this is where the continuity between variants is maintained
    sortedHours.forEach(hour => {
        const hourProduction = hourlyProductionMap.get(hour) || 0;
        const hourTarget = hourlyTargetMap.get(hour) || 0;
        
        // Add to running totals - this ensures continuity across variant changes
        runningProductionTotal += hourProduction;
        runningTargetTotal += hourTarget;
        
        const [hourVal, minuteVal] = hour.split(':').map(Number);
        const timeMinutes = hourVal * 60 + minuteVal;
        
        cumulativeData.push({
            hour: hour,
            production: runningProductionTotal,
            target: runningTargetTotal,
            timeMinutes: timeMinutes
        });
    });
    
    // Filter data to only show up to current time plus buffer
    const now = new Date();
    const currentMinuteOfDay = now.getHours() * 60 + now.getMinutes();
    const currentTimePlusBuffer = currentMinuteOfDay + 30;
    
    const filteredData = cumulativeData.filter(item => item.timeMinutes <= currentTimePlusBuffer);
    
    if (filteredData.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available for current time period</div>';
        return;
    }
    
    // Find max value for chart scaling
    const maxValue = Math.max(
        ...filteredData.map(item => Math.max(item.target || 0, item.production || 0))
    ) * 1.1;
    
    // Set up chart dimensions
    const svgWidth = chartContainer.clientWidth || 600;
    const svgHeight = chartContainer.clientHeight || 370;
    const padding = commonChartPadding;
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.style.display = 'block';
    svg.style.margin = '0 auto';
    chartContainer.appendChild(svg);
    
    // Add grid lines with enlarged fonts
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 15);
        text.setAttribute('y', y + 6);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title with enlarged font
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 50);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', '18');
    yAxisTitle.setAttribute('class', 'chart-axis-label');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 50}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add y-axis line
    const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    startLine.setAttribute('x1', padding.left);
    startLine.setAttribute('y1', padding.top);
    startLine.setAttribute('x2', padding.left);
    startLine.setAttribute('y2', svgHeight - padding.bottom);
    startLine.setAttribute('stroke', '#666');
    startLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(startLine);
    
    // Add x-axis line
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', padding.left);
    xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
    xAxisLine.setAttribute('x2', svgWidth - padding.right);
    xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
    xAxisLine.setAttribute('stroke', '#666');
    xAxisLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxisLine);
    svg.appendChild(gridGroup);
    
    // Add x-axis labels
    const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    // Find earliest start time and latest end time across all variants
    let earliestStartMinutes = 24 * 60; // Initialize to end of day
    let latestEndMinutes = 0;

    group.variants.forEach(variant => {
        const supervisorVariant = group.supervisorData.variants[variant.variant];
        if (supervisorVariant) {
            const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
            const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
            
            if (startTimeStr && endTimeStr) {
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const startTimeMinutes = startHour * 60 + startMinute;
                
                if (startTimeMinutes < earliestStartMinutes) {
                    earliestStartMinutes = startTimeMinutes;
                }
                
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                const endTimeMinutes = endHour * 60 + endMinute;
                
                if (endTimeMinutes > latestEndMinutes) {
                    latestEndMinutes = endTimeMinutes;
                }
            }
        }
    });

    // Format the start time for display (first tick)
    const startTimeHour = Math.floor(earliestStartMinutes / 60);
    const startTimeMinute = earliestStartMinutes % 60;
    const startTimeFormatted = `${startTimeHour.toString().padStart(2, '0')}:${startTimeMinute.toString().padStart(2, '0')}`;

    // Generate hourly intervals from start time to current time
    const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
    const endTimeMinutes = Math.min(latestEndMinutes, currentTimeMinutes + 60); // Show up to 1 hour ahead

    // Create hourly ticks (standard hour endings after start time)
    const allHours = [];
    
    // Add the start time as the first tick
    allHours.push(startTimeFormatted);
    
    // Calculate the first full hour after start time
    const firstFullHourMinutes = Math.ceil(earliestStartMinutes / 60) * 60 + 30;
    
    // Then add standard hour markers (8:30, 9:30, etc.)
    for (let minutes = firstFullHourMinutes; minutes <= endTimeMinutes; minutes += 60) {
        const hour = Math.floor(minutes / 60);
        const formattedHour = `${hour.toString().padStart(2, '0')}:30`;
        allHours.push(formattedHour);
    }

    // Draw X-axis ticks and labels with larger fonts
    allHours.forEach((hour, index) => {
        const x = padding.left + (chartWidth * index / (allHours.length - 1 || 1));
        const y = svgHeight - padding.bottom + 25;
        
        // Add tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', x);
        tick.setAttribute('y1', svgHeight - padding.bottom);
        tick.setAttribute('x2', x);
        tick.setAttribute('y2', svgHeight - padding.bottom + 8);
        tick.setAttribute('stroke', '#666');
        tick.setAttribute('stroke-width', '1.5');
        xLabelsGroup.appendChild(tick);
        
        // Add hour label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = hour;
        xLabelsGroup.appendChild(text);
    });
    
    svg.appendChild(xLabelsGroup);
    
    // Draw production line - starting from the first tick (start time) with zero production
    const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let productionPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const productionPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        production: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for production line with proper cumulative totals
    filteredData.forEach((dataPoint, index) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.production / maxValue));
        
        productionPoints.push({ 
            x, 
            y, 
            production: dataPoint.production, 
            hour: dataPoint.hour 
        });
        productionPathD += ` L ${x} ${y}`;
    });
    
    // Add production line
    const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    productionPath.setAttribute('d', productionPathD);
    productionPath.setAttribute('stroke', 'var(--production-color)');
    productionPath.setAttribute('stroke-width', '3');
    productionPath.setAttribute('fill', 'none');
    productionLineGroup.appendChild(productionPath);
    
    // Add production points and labels with larger fonts
    productionPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '6');
        circle.setAttribute('fill', 'var(--production-color)');
        productionLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 12);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '18');
        text.setAttribute('class', 'chart-data-label');
        text.setAttribute('fill', 'var(--production-color)');
        text.textContent = point.production;
        productionLineGroup.appendChild(text);
    });
    svg.appendChild(productionLineGroup);
    
    // Draw target line - starting from the first tick (start time) with zero target
    const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Start with a point at zero (at the start time)
    let targetPathD = `M ${padding.left} ${padding.top + chartHeight}`;
    const targetPoints = [{
        x: padding.left,
        y: padding.top + chartHeight,
        target: 0,
        hour: startTimeFormatted
    }];
    
    // Get data points for target line with proper cumulative totals
    filteredData.forEach((dataPoint, index) => {
        // Find the x position based on the hour
        const hourIndex = allHours.indexOf(dataPoint.hour);
        let x;
        if (hourIndex >= 0) {
            x = padding.left + (chartWidth * hourIndex / (allHours.length - 1 || 1));
        } else {
            // If hour not in allHours, interpolate
            const timeRatio = (dataPoint.timeMinutes - earliestStartMinutes) / 
                          ((endTimeMinutes - earliestStartMinutes) || 1);
            x = padding.left + (chartWidth * timeRatio);
        }
        
        const y = padding.top + chartHeight - (chartHeight * (dataPoint.target / maxValue));
        
        targetPoints.push({ 
            x, 
            y, 
            target: dataPoint.target, 
            hour: dataPoint.hour 
        });
        targetPathD += ` L ${x} ${y}`;
    });
    
    // Add target line
    const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    targetPath.setAttribute('d', targetPathD);
    targetPath.setAttribute('stroke', 'var(--target-color)');
    targetPath.setAttribute('stroke-width', '3');
    targetPath.setAttribute('fill', 'none');
    targetLineGroup.appendChild(targetPath);
    
    // Add target points and labels with larger fonts
    targetPoints.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '6');
        circle.setAttribute('fill', 'var(--target-color)');
        targetLineGroup.appendChild(circle);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', point.x);
        text.setAttribute('y', point.y - 12);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '18');
        text.setAttribute('class', 'chart-data-label');
        text.setAttribute('fill', 'var(--target-color)');
        text.textContent = point.target;
        targetLineGroup.appendChild(text);
    });
    svg.appendChild(targetLineGroup);
}

function updateHourlyChart() {
    const chartContainer = document.getElementById('hourly-chart');
    chartContainer.innerHTML = '';
    
    if (!currentProductVariants || currentProductVariants.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
        return;
    }
    
    // Determine which hour to display
    let displayHour;
    if (selectedHour === 'current') {
        // For current hour option, get next production hour
        const allHours = new Set();
        currentProductVariants.forEach(variant => {
            if (variant.hourlyTargets) {
                variant.hourlyTargets.forEach(item => {
                    if (item.hour) allHours.add(item.hour);
                });
            }
        });
        
        displayHour = getNextProductionHour(Array.from(allHours));
    } else {
        // For specific hour selection
        displayHour = selectedHour;
    }
    
    // Find all variants active during this hour
    const activeVariants = [];
    const hourlyData = { target: 0, production: 0 };
    
    // Get the hour's time in minutes
    const [hourVal, minuteVal] = displayHour.split(':').map(Number);
    const hourTimeMinutes = hourVal * 60 + minuteVal;
    
    // Show countdown for current hour if appropriate
    if (selectedHour === 'current') {
        startCountdown(displayHour);
    } else {
        if (countdownInterval) clearInterval(countdownInterval);
        document.querySelector('.hour-countdown').textContent = '';
    }
    
    // Process all variants to find those active during this hour
    currentProductVariants.forEach(variant => {
        const supervisorVariant = currentSupervisor ? 
            productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
        
        if (!supervisorVariant) return;
        
        const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
        const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
        
        if (!startTimeStr || !endTimeStr) return;
        
        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
        
        const startTimeMinutes = startHour * 60 + startMinute;
        const endTimeMinutes = endHour * 60 + endMinute;
        
        // Check if this hour falls within this variant's window
        if (hourTimeMinutes >= startTimeMinutes && hourTimeMinutes <= endTimeMinutes) {
            activeVariants.push(variant);
            
            // Add target and production data
            if (variant.hourlyTargets) {
                const targetData = variant.hourlyTargets.find(item => item.hour === displayHour);
                if (targetData) {
                    hourlyData.target += targetData.target || 0;
                }
            }
            
            if (variant.hourlyProduction) {
                const productionData = variant.hourlyProduction.find(item => item.hour === displayHour);
                if (productionData) {
                    hourlyData.production += productionData.production || 0;
                }
            }
        }
    });
    
    // If no variants are active during this hour, show message
    if (activeVariants.length === 0) {
        chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No variants active during this hour</div>';
        return;
    }
    
    // Draw hourly chart
    const svgWidth = chartContainer.clientWidth || 600;
    const svgHeight = chartContainer.clientHeight || 370;
    const padding = commonChartPadding;
    const chartWidth = svgWidth - padding.left - padding.right;
    const chartHeight = svgHeight - padding.top - padding.bottom;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.style.display = 'block';
    svg.style.margin = '0 auto';
    chartContainer.appendChild(svg);
    
    const maxValue = Math.max(hourlyData.production, hourlyData.target, 1) * 1.2;
    
    // Add grid with larger fonts
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartHeight * i / 4);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', svgWidth - padding.right);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ddd');
        line.setAttribute('stroke-width', '1');
        gridGroup.appendChild(line);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding.left - 15);
        text.setAttribute('y', y + 6);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '16');
        text.setAttribute('class', 'chart-tick-label');
        text.setAttribute('fill', '#666');
        text.textContent = Math.round(maxValue * (4 - i) / 4);
        gridGroup.appendChild(text);
    }
    
    // Add y-axis title with larger font
    const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisTitle.setAttribute('x', padding.left - 50);
    yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
    yAxisTitle.setAttribute('text-anchor', 'middle');
    yAxisTitle.setAttribute('font-size', '18');
    yAxisTitle.setAttribute('class', 'chart-axis-label');
    yAxisTitle.setAttribute('font-weight', 'bold');
    yAxisTitle.setAttribute('fill', '#666');
    yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 50}, ${padding.top + chartHeight / 2})`);
    yAxisTitle.textContent = 'Units';
    gridGroup.appendChild(yAxisTitle);
    
    // Add axes
    const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    vLine.setAttribute('x1', padding.left);
    vLine.setAttribute('y1', padding.top);
    vLine.setAttribute('x2', padding.left);
    vLine.setAttribute('y2', svgHeight - padding.bottom);
    vLine.setAttribute('stroke', '#666');
    vLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(vLine);
    
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', padding.left);
    xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
    xAxisLine.setAttribute('x2', svgWidth - padding.right);
    xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
    xAxisLine.setAttribute('stroke', '#666');
    xAxisLine.setAttribute('stroke-width', '1.5');
    gridGroup.appendChild(xAxisLine);
    svg.appendChild(gridGroup);
    
    // Draw bars
    const barWidth = 80;
    const barSpacing = 60;
    const startX = svgWidth / 2 - barWidth - barSpacing / 2;
    
    // Production bar
    const productionBarHeight = (hourlyData.production / maxValue) * chartHeight;
    const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    productionBar.setAttribute('x', startX);
    productionBar.setAttribute('y', padding.top + chartHeight - productionBarHeight);
    productionBar.setAttribute('width', barWidth);
    productionBar.setAttribute('height', productionBarHeight);
    productionBar.setAttribute('fill', 'var(--production-color)');
    productionBar.setAttribute('rx', '5');
    svg.appendChild(productionBar);
    
    // Target bar
    const targetBarHeight = (hourlyData.target / maxValue) * chartHeight;
    const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    targetBar.setAttribute('x', startX + barWidth + barSpacing);
    targetBar.setAttribute('y', padding.top + chartHeight - targetBarHeight);
    targetBar.setAttribute('width', barWidth);
    targetBar.setAttribute('height', targetBarHeight);
    targetBar.setAttribute('fill', 'var(--target-color)');
    targetBar.setAttribute('rx', '5');
    svg.appendChild(targetBar);
    
    // Add production value text with larger font
    const productionValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    productionValueText.setAttribute('x', startX + barWidth / 2);
    productionValueText.setAttribute('y', padding.top + chartHeight - productionBarHeight - 20);
    productionValueText.setAttribute('text-anchor', 'middle');
    productionValueText.setAttribute('font-size', '22');
    productionValueText.setAttribute('class', 'chart-data-label');
    productionValueText.setAttribute('font-weight', '600');
    productionValueText.setAttribute('fill', 'var(--production-color)');
    productionValueText.textContent = hourlyData.production;
    svg.appendChild(productionValueText);
    
    // Add target value text with larger font
    const targetValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetValueText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
    targetValueText.setAttribute('y', padding.top + chartHeight - targetBarHeight - 20);
    targetValueText.setAttribute('text-anchor', 'middle');
    targetValueText.setAttribute('font-size', '22');
    targetValueText.setAttribute('class', 'chart-data-label');
    targetValueText.setAttribute('font-weight', '600');
    targetValueText.setAttribute('fill', 'var(--target-color)');
    targetValueText.textContent = hourlyData.target;
    svg.appendChild(targetValueText);
    
    // Add labels with larger font
    const productionLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    productionLabelText.setAttribute('x', startX + barWidth / 2);
    productionLabelText.setAttribute('y', svgHeight - padding.bottom + 35);
    productionLabelText.setAttribute('text-anchor', 'middle');
    productionLabelText.setAttribute('font-size', '18');
    productionLabelText.setAttribute('font-weight', '500');
    productionLabelText.setAttribute('fill', 'var(--production-color)');
    productionLabelText.textContent = 'Production';
    svg.appendChild(productionLabelText);
    
    const targetLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    targetLabelText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
    targetLabelText.setAttribute('y', svgHeight - padding.bottom + 35);
    targetLabelText.setAttribute('text-anchor', 'middle');
    targetLabelText.setAttribute('font-size', '18');
    targetLabelText.setAttribute('font-weight', '500');
    targetLabelText.setAttribute('fill', 'var(--target-color)');
    targetLabelText.textContent = 'Target';
    svg.appendChild(targetLabelText);
    
    // X axis line
    const xAxisLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine2.setAttribute('x1', padding.left);
    xAxisLine2.setAttribute('y1', padding.top + chartHeight);
    xAxisLine2.setAttribute('x2', svgWidth - padding.right);
    xAxisLine2.setAttribute('y2', padding.top + chartHeight);
    xAxisLine2.setAttribute('stroke', '#666');
    xAxisLine2.setAttribute('stroke-width', '1.5');
    svg.appendChild(xAxisLine2);
    
    // Update hour select dropdown
    const select = document.getElementById('hour-range-select');
    select.value = selectedHour === 'current' ? 'current' : displayHour;
    
    // Add active variants list with larger font
    if (activeVariants.length > 1) {
        const activeVariantsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        activeVariantsText.setAttribute('x', svgWidth / 2);
        activeVariantsText.setAttribute('y', padding.top + chartHeight + 50);
        activeVariantsText.setAttribute('text-anchor', 'middle');
        activeVariantsText.setAttribute('font-size', '16');
        activeVariantsText.setAttribute('fill', '#666');
        
        const variantNames = activeVariants.map(v => {
            // Extract variant name from full string
            let displayName = v.variant;
            if (v.variant.startsWith(currentProduct + ' ')) {
                displayName = v.variant.substring(currentProduct.length + 1);
            }
            return displayName;
        });
        
        activeVariantsText.textContent = `Active variants: ${variantNames.join(', ')}`;
        svg.appendChild(activeVariantsText);
    }
}

        // Initialize the dashboard when the window loads
        window.onload = initDashboard;
        
        // Update charts on window resize
        window.addEventListener('resize', function() {
            if (currentProduct && currentSupervisor) {
                const group = productSupervisorGroups[`${currentSupervisor}:${currentProduct}`];
                if (group) {
                    renderCumulativeChart(group);
                    updateHourlyChart();
                }
            }
        });

        function updateSupervisorFilter() {
            const checkboxContainer = document.getElementById('supervisor-checkboxes');
            checkboxContainer.innerHTML = '';
            
            if (productionData && productionData.personnel && productionData.personnel.supervisors) {
                productionData.personnel.supervisors.forEach(supervisor => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'supervisor-checkbox-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `supervisor-${supervisor.id}`;
                    checkbox.value = supervisor.id;
                    checkbox.checked = selectedSupervisors.includes(supervisor.id);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `supervisor-${supervisor.id}`;
                    label.textContent = supervisor.name;
                    
                    // Add supervisor color indicator
                    const colorIndicator = document.createElement('span');
                    colorIndicator.className = `color-indicator supervisor-${supervisor.id.toLowerCase()}-bg`;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(colorIndicator);
                    checkboxDiv.appendChild(label);
                    
                    checkboxContainer.appendChild(checkboxDiv);
                });
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the dashboard
            initDashboard();
            
            // Set the facility name from metadata
            const facilityNameElement = document.getElementById('facility-name');
            if (facilityNameElement) {
                fetch(DATA_URL)
                    .then(response => response.json())
                    .then(data => {
                        if (data.metadata && data.metadata.facility) {
                            facilityNameElement.textContent = data.metadata.facility;
                        }
                    })
                    .catch(error => console.error('Failed to load facility name:', error));
            }
            
            // Update date and time
            updateDateTime();
            setInterval(updateDateTime, 1000);
            
            // Set up event listeners for filter controls if they exist
            const filterTypeSelect = document.getElementById('filter-type-select');
            if (filterTypeSelect) {
                filterTypeSelect.addEventListener('change', changeFilterType);
            }
            
            const filterValueSelect = document.getElementById('filter-value-select');
            if (filterValueSelect) {
                filterValueSelect.addEventListener('change', changeFilterValue);
            }
            
            const hourRangeSelect = document.getElementById('hour-range-select');
            if (hourRangeSelect) {
                hourRangeSelect.addEventListener('change', changeHourRange);
            }
            
            const supervisorFilterBtn = document.getElementById('supervisor-filter-btn');
            if (supervisorFilterBtn) {
                supervisorFilterBtn.addEventListener('click', openSupervisorFilter);
            }
            
            const toggleFullscreenBtn = document.getElementById('toggle-fullscreen-btn');
            if (toggleFullscreenBtn) {
                toggleFullscreenBtn.addEventListener('click', toggleFullscreen);
            }
            
            // Set up refresh interval
            setInterval(fetchProductionData, REFRESH_INTERVAL);
        });

        function openSupervisorFilter() {
            const modal = document.getElementById('supervisor-select-modal');
            if (modal) {
                updateSupervisorFilter();
                modal.style.display = 'block';
            }
        }

        function changeFilterType() {
            selectedFilterType = this.value;
            updateFilterValueDropdown();
        }

        function changeFilterValue() {
            selectedFilterValue = this.value;
            updateDashboard();
        }

        function changeHourRange() {
            selectedHour = this.value;
            // Update hour-specific chart if needed
        }
    </script>
</body>
</html>
