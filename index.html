<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3B82F6; /* Blue color from screenshot */
            --success-color: #10B981;   /* Green color from screenshot */
            --warning-color: #F59E0B;   /* Amber color from screenshot */
            --danger-color: #e74c3c;
            --light-color: #f3f4f6;     /* Light gray from screenshot */
            --dark-color: #1e293b;      /* Dark blue-gray from screenshot */
            
            /* Supervisor colors */
            --supervisor-luthando: #F9E79F; /* Yellow */
            --supervisor-aphele: #121212;   /* Black */
            --supervisor-siyabonga: #FADBD8; /* Pink */
            --supervisor-nosi: #D6EAF8;     /* Blue */
            --supervisor-mvokwe: #D5F5E3;   /* Green */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light-color);
            color: var(--primary-color);
            overflow: auto; /* Allow scrolling if content overflows */
            transition: background-color 0.5s ease;
        }

        .dashboard-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            max-width: 1400px; /* Limit max width for larger screens */
            margin: 0 auto; /* Center the dashboard */
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
            width: 100%;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .title {
            font-size: clamp(1.5rem, 2.5vw, 2.5rem); /* Responsive font size */
            font-weight: bold;
            color: var(--primary-color);
        }

        .subtitle {
            font-size: clamp(1.2rem, 1.8vw, 1.8rem);
            color: var(--secondary-color);
            font-weight: 500;
        }

        .date-time {
            text-align: right;
            font-size: clamp(1rem, 1.4vw, 1.4rem);
        }

        .date {
            font-weight: bold;
        }

        .time {
            font-size: clamp(1.2rem, 1.8vw, 1.8rem);
            margin-top: 5px;
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .variant-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            background-color: var(--dark-color);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            width: 100%;
        }

        .variant-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .variant-name {
            font-size: clamp(1.2rem, 1.8vw, 1.8rem);
            font-weight: bold;
        }

        .supervisor-name {
            font-size: clamp(1rem, 1.4vw, 1.4rem);
            font-style: italic;
        }

        .cycle-time-container {
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: clamp(1.2rem, 1.8vw, 1.8rem);
        }

        .target-cycle-time {
            color: var(--success-color);
        }

        .actual-cycle-time {
            color: var(--secondary-color);
        }

        .debug-button {
            padding: 8px 16px;
            border-radius: 5px;
            border: none;
            color: white;
            font-weight: bold;
            cursor: pointer;
            background-color: var(--danger-color);
            margin-left: 10px;
        }

        .debug-button:hover {
            background-color: #c0392b;
        }

        .chart-container {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 100%;
            max-width: 100%;
        }

        .charts-row {
            display: flex;
            flex: 1;
            gap: 20px;
            margin-bottom: 0; /* Removed margin since key metrics are gone */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .chart {
            flex: 1;
            min-width: 0; /* Prevent overflow */
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            min-height: 430px; /* Adjusted for better proportions */
        }

        .chart-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: nowrap;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 8px;
        }
        
        .chart-title {
            font-size: clamp(1.2rem, 1.5vw, 1.5rem);
            font-weight: 600;
            margin-right: 20px;
            color: var(--dark-color);
            white-space: nowrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .hour-info {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            white-space: nowrap;
        }

        .hour-time {
            font-size: 15px;
            color: var(--dark-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .hour-countdown {
            font-size: 15px;
            color: var(--secondary-color);
            font-style: normal;
        }
        
        .hour-select-container {
            margin-left: auto; /* Push to the right side */
        }

        .hour-select {
            padding: 6px 12px;
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            font-family: inherit;
            background-color: white;
            height: 35px;
            font-size: 14px;
            font-weight: 500;
            color: var(--dark-color);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .chart-area {
            flex: 1;
            position: relative;
            min-height: 350px;
            margin-top: 0; /* No top margin */
        }

        /* Line Chart Styling (Cumulative Daily Production Progress) */
        .line-chart {
            position: relative;
            height: 100%;
            width: 100%;
            margin: 0; /* Remove margin */
        }

        /* Bar Chart Styling (Hourly Production Progress) */
        .bar-chart {
            display: flex;
            height: 100%;
            align-items: flex-end;
            justify-content: center;
            gap: 20px;
            padding-top: 10px; /* Reduced padding */
            margin: 0; /* Remove margin */
        }

        .legend {
            display: flex;
            justify-content: center;
            margin: -10px 0 0 0; /* Negative top margin to move legend up */
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }

        .production-color {
            background-color: var(--secondary-color);
        }

        .target-color {
            background-color: var(--success-color);
        }

        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: clamp(1rem, 1.2vw, 1.2rem);
            color: var(--dark-color);
            width: 100%;
        }

        .progress-bar {
            height: 10px;
            background-color: var(--light-color);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
            width: 100%;
        }

        .progress {
            height: 100%;
            background-color: var(--secondary-color);
            transition: width 0.5s linear;
            width: 0%;
        }

        .update-info {
            font-size: 0.8rem;
            color: var(--dark-color);
            text-align: right;
            margin-top: 5px;
        }

        .totals-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            margin-bottom: 20px;
            font-size: clamp(1rem, 1.2vw, 1.2rem);
            gap: 20px;
            width: 100%;
        }

        .total-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            width: 100%;
        }

        .total-label {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: clamp(1rem, 1.4vw, 1.4rem);
            color: var(--dark-color);
        }

        .total-value {
            font-size: clamp(1.5rem, 2.5vw, 2.5rem);
            font-weight: bold;
        }

        .total-subvalue {
            font-size: clamp(1rem, 1.2vw, 1.2rem);
            margin-top: 5px;
        }

        .total-target {
            color: var(--success-color);
        }

        .total-actual {
            color: var(--secondary-color);
        }

        .total-progress {
            color: var(--warning-color);
        }

        .total-hourly {
            color: var(--dark-color);
        }

        .filter-section {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .filter-select {
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid var(--secondary-color);
            font-size: clamp(0.9rem, 1.1vw, 1.1rem);
            font-family: inherit;
            min-width: 180px;
            background-color: white;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--dark-color);
        }

        .error {
            text-align: center;
            padding: 20px;
            color: var(--danger-color);
            font-weight: bold;
        }

        /* Special styling for supervisor Aphele (black background) */
        .supervisor-aphele {
            color: white;
        }
        
        .supervisor-aphele .chart-container,
        .supervisor-aphele .chart,
        .supervisor-aphele .filter-select,
        .supervisor-aphele .hour-select {
            background-color: #222;
            color: white;
            border-color: #555;
        }
        
        .supervisor-aphele .chart-title,
        .supervisor-aphele .hour-time,
        .supervisor-aphele .total-label,
        .supervisor-aphele .total-hourly,
        .supervisor-aphele .legend {
            color: #ddd;
        }

        /* Debug Popup Styles */
        .debug-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            width: 600px;
        }

        .debug-popup.show {
            display: block;
        }

        .debug-popup-content {
            font-size: 0.9rem;
        }

        .debug-popup table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .debug-popup th, .debug-popup td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .debug-popup th {
            background-color: var(--light-color);
            font-weight: bold;
        }

        .debug-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background-color: var(--danger-color);
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .debug-popup .close-btn:hover {
            background-color: #c0392b;
        }

        /* Overlay for popup */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 900;
        }

        .overlay.show {
            display: block;
        }

        /* Media queries for responsiveness */
        @media (max-width: 1200px) {
            .title-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .filter-section {
                margin-top: 10px;
            }
        }

        @media (max-width: 1024px) {
            .charts-row {
                flex-direction: column;
            }

            .chart {
                min-height: 350px; /* Reduce chart height on smaller screens */
            }

            .dashboard-container {
                padding: 10px;
            }

            .debug-popup {
                width: 90%;
                max-width: 90%;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                text-align: center;
            }

            .title-section {
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            .filter-section {
                flex-direction: column;
                width: 100%;
            }

            .filter-select {
                width: 100%;
            }

            .date-time {
                text-align: center;
                margin-top: 10px;
            }

            .chart {
                min-height: 250px;
            }

            .debug-popup {
                width: 95%;
                max-width: 95%;
            }
            
            .chart-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .hour-select-container {
                margin-left: 0;
                margin-top: 10px;
                width: 100%;
            }
            
            .hour-select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <div class="title-section">
                <div>
                    <div class="title">Sinapi Secondary Production Dashboard</div>
                    <div class="subtitle">Medical Device Assembly</div>
                </div>
                <div class="filter-section">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                        <!-- Options will be added dynamically -->
                    </select>
                </div>
            </div>
            <div class="date-time">
                <div class="date" id="current-date">Loading...</div>
                <div class="time" id="current-time">Loading...</div>
                <div class="update-info" id="last-update">Last updated: Never</div>
                <button class="debug-button" onclick="showDebugPopup()">Show Debug Data</button>
            </div>
        </div>

        <div class="content">
            <div class="variant-info">
                <div class="variant-details">
                    <div class="variant-name" id="variant-name">Product Variant: Loading...</div>
                    <div class="supervisor-name" id="supervisor-name">Line Supervisor: Loading...</div>
                </div>
                <div class="cycle-time-container">
                    <div class="target-cycle-time" id="target-cycle-time">Target: Loading...</div>
                    <div class="actual-cycle-time" id="actual-cycle-time">Actual: Loading...</div>
                </div>
            </div>

            <div class="totals-display" id="totals-display">
                <div class="loading">Loading data...</div>
            </div>

            <div class="chart-container">
                <div class="charts-row">
                    <div class="chart">
                        <div class="chart-title">Cumulative Daily Production Progress</div>
                        <div class="chart-area">
                            <div class="line-chart" id="cumulative-chart"></div>
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-color production-color"></div>
                                    <div>Cumulative Production</div>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color target-color"></div>
                                    <div>Cumulative Target</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chart">
                        <div class="chart-header">
                            <div class="chart-title">Hourly Production Progress</div>
                            <div class="hour-info" id="hour-info">
                                <div class="hour-time">Hour: Loading...</div>
                                <div class="hour-countdown"></div>
                            </div>
                            <div class="hour-select-container">
                                <select id="hour-select" class="hour-select">
                                    <option value="current">Current Hour</option>
                                    <!-- Hour options will be added dynamically -->
                                </select>
                            </div>
                        </div>
                        <div class="chart-area" style="margin-top: -15px;">
                            <div class="bar-chart" id="hourly-chart"></div>
                            <!-- Legend removed from hourly chart -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div>Cycling through variants: <span id="current-variant-index">0</span>/<span id="total-variants">0</span></div>
            <div class="progress-bar">
                <div class="progress" id="cycle-progress"></div>
            </div>
        </div>
    </div>

    <!-- Debug Popup -->
    <div class="overlay" id="overlay"></div>
    <div class="debug-popup" id="debugPopup">
        <button class="close-btn" onclick="hideDebugPopup()">Close</button>
        <div class="debug-popup-content" id="debugPopupContent">
            <!-- Tables will be inserted here dynamically -->
        </div>
    </div>

    <script>
        // Configuration
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 60 * 1000; // Check for updates every minute
        const CYCLE_INTERVAL = 10000; // Time to display each variant (10 seconds)

        // State variables
        let productionData = {
            variants: [],
            supervisors: []
        };
        let filteredVariants = [];
        let currentVariantIndex = 0;
        let lastUpdateTime = null;
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let isAutocycling = true;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 }; // Reduced top padding to minimize white space

        // Initialize the dashboard
        function initDashboard() {
            // Update clock
            updateDateTime();
            setInterval(updateDateTime, 1000);

            // Set up filter type change event
            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            // Set up filter value change event
            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                filterVariants();

                // Reset variant index
                currentVariantIndex = 0;
                if (filteredVariants.length > 0) {
                    displayVariant(currentVariantIndex);
                } else {
                    showLoadingOrError('No variants available for this filter.');
                }
            });

            // Set up hour select change event
            document.getElementById('hour-select').addEventListener('change', function() {
                selectedHour = this.value;
                const variant = filteredVariants[currentVariantIndex];
                if (variant) {
                    renderHourlyChart(variant);
                }
            });

            // Load initial data
            fetchProductionData();

            // Set up refresh interval
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            // Start cycling through variants
            setInterval(cycleVariants, CYCLE_INTERVAL);

            // Start progress bar animation
            animateProgress();
        }

        // Apply supervisor-specific styling
        function applySupervisorStyling(supervisorName) {
            // Remove any existing supervisor class
            document.body.classList.remove(
                'supervisor-luthando', 
                'supervisor-aphele', 
                'supervisor-siyabonga', 
                'supervisor-nosi', 
                'supervisor-mvokwe'
            );
            
            // Convert supervisor name to lowercase for class name
            if (supervisorName) {
                const supervisorClass = 'supervisor-' + supervisorName.toLowerCase();
                document.body.classList.add(supervisorClass);
                
                // Apply specific background colors
                switch(supervisorName.toLowerCase()) {
                    case 'luthando':
                        document.body.style.backgroundColor = 'var(--supervisor-luthando)';
                        break;
                    case 'aphele':
                        document.body.style.backgroundColor = 'var(--supervisor-aphele)';
                        break;
                    case 'siyabonga':
                        document.body.style.backgroundColor = 'var(--supervisor-siyabonga)';
                        break;
                    case 'nosi':
                        document.body.style.backgroundColor = 'var(--supervisor-nosi)';
                        break;
                    case 'mvokwe':
                        document.body.style.backgroundColor = 'var(--supervisor-mvokwe)';
                        break;
                    default:
                        document.body.style.backgroundColor = 'var(--light-color)';
                        break;
                }
            } else {
                document.body.style.backgroundColor = 'var(--light-color)';
            }
        }

        // Update the hour dropdown with all hours from the day
        function updateHourDropdown() {
            const hourSelect = document.getElementById('hour-select');
            
            // Clear existing options except the first one
            while (hourSelect.options.length > 1) {
                hourSelect.remove(1);
            }
            
            // Get production hours from the first variant (all variants should have same hours)
            const productionHours = [];
            if (filteredVariants.length > 0) {
                const variant = filteredVariants[0];
                if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                    variant.hourlyTargets.forEach(item => {
                        if (item.hour) {
                            productionHours.push(item.hour);
                        }
                    });
                }
            }
            
            // If no production hours found, use default hours
            if (productionHours.length === 0) {
                const defaultHours = [
                    "08:30", "09:30", "10:30", "11:30", "12:30", "13:30", 
                    "14:30", "15:30", "16:30", "17:30", "18:30"
                ];
                productionHours.push(...defaultHours);
            }
            
            // Add options for each production hour
            productionHours.sort().forEach(hour => {
                const option = document.createElement('option');
                option.value = hour;
                option.textContent = hour;
                hourSelect.appendChild(option);
            });
        }

        // Get the next hour in the production schedule based on the current time
        function getNextProductionHour() {
            const now = new Date();
            const currentTime = now.getHours() * 60 + now.getMinutes(); // Convert to minutes
            
            // Get production hours from the first variant
            let productionHours = [];
            if (filteredVariants.length > 0) {
                const variant = filteredVariants[0];
                if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                    productionHours = variant.hourlyTargets
                        .map(item => item.hour)
                        .filter(hour => hour)
                        .sort();
                }
            }
            
            // If no production hours found, use default hours
            if (productionHours.length === 0) {
                productionHours = [
                    "08:30", "09:30", "10:30", "11:30", "12:30", "13:30", 
                    "14:30", "15:30", "16:30", "17:30", "18:30"
                ];
            }
            
            // Find the next production hour
            for (const hourStr of productionHours) {
                const [hours, minutes] = hourStr.split(':').map(Number);
                const hourInMinutes = hours * 60 + minutes;
                
                if (hourInMinutes > currentTime) {
                    return hourStr;
                }
            }
            
            // If we're past all production hours, return the first hour of next day
            return productionHours[0];
        }

        // Calculate time to next hour in a readable format
        function calculateTimeToNextHour(hourStr) {
            const now = new Date();
            const [hours, minutes] = hourStr.split(':').map(Number);
            
            const targetTime = new Date(now);
            targetTime.setHours(hours, minutes, 0, 0);
            
            // If the target time is already passed today, set it for tomorrow
            if (targetTime <= now) {
                targetTime.setDate(targetTime.getDate() + 1);
            }
            
            const diffMs = targetTime - now;
            const diffMinutes = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMinutes / 60);
            const remainingMinutes = diffMinutes % 60;
            
            if (diffHours > 0) {
                return `in ${diffHours}h ${remainingMinutes}m`;
            } else {
                return `in ${remainingMinutes}m`;
            }
        }

        // Start countdown timer to next hour
        function startCountdown(hourStr) {
            // Clear any existing interval
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Update countdown immediately
            updateCountdown(hourStr);
            
            // Set interval to update countdown every minute
            countdownInterval = setInterval(() => {
                updateCountdown(hourStr);
            }, 60000); // Update every minute
        }

        // Update the countdown display
        function updateCountdown(hourStr) {
            const countdownElement = document.querySelector('.hour-countdown');
            countdownElement.textContent = calculateTimeToNextHour(hourStr);
        }

        // Calculate actual cycle time based on production data and breaks
        function calculateActualCycleTime(variant) {
            // Check if we have the necessary data
            if (!variant.currentTotal || variant.currentTotal <= 0) {
                return "N/A";
            }

            // Parse the start time from the data
            const startTimeStr = variant["Start Time"];
            if (!startTimeStr) {
                return calculateSimplifiedCycleTime(variant);
            }

            // Get current time and create a start time date object using today's date
            const now = new Date();
            const startDate = new Date(now);
            const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
            startDate.setHours(startHours, startMinutes, 0, 0);

            // Calculate total elapsed time in hours (from start time to current time)
            const elapsedTimeMs = now - startDate;
            const elapsedTimeHours = elapsedTimeMs / (1000 * 60 * 60);

            // Calculate allocated and elapsed break times
            const allocatedBreakTime = calculateAllocatedBreakTime(variant);
            const elapsedBreakTime = calculateElapsedBreakTime(variant, now);

            // Convert break time from minutes to hours
            const breakTimeHours = elapsedBreakTime / 60;

            // Calculate actual working time
            const actualWorkingTimeHours = elapsedTimeHours - breakTimeHours;

            // Check for negative or zero working time (could happen if current time is before start time)
            if (actualWorkingTimeHours <= 0) {
                return "N/A";
            }

            // Calculate cycle time in seconds per unit
            const cycleTimeSeconds = (actualWorkingTimeHours * 3600) / variant.currentTotal;

            // Return rounded value
            return Math.round(cycleTimeSeconds);
        }

        // Calculate the total allocated break time in minutes
        function calculateAllocatedBreakTime(variant) {
            let totalBreakTime = 0;

            // Add lunch break if available
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
                totalBreakTime += getTimeDifferenceInMinutes(
                    variant["Break Start (Lunch)"], 
                    variant["Break End (Lunch)"]
                );
            }

            // Add tea break if available
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
                totalBreakTime += getTimeDifferenceInMinutes(
                    variant["Break Start (Tea)"], 
                    variant["Break End (Tea)"]
                );
            }

            // Add OT tea break if available and not marked as "-"
            if (variant["OT Break Start (Tea)"] && 
                variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && 
                variant["OT Break End (Tea)"] !== "-") {
                
                totalBreakTime += getTimeDifferenceInMinutes(
                    variant["OT Break Start (Tea)"], 
                    variant["OT Break End (Tea)"]
                );
            }

            return totalBreakTime;
        }

        // Calculate the elapsed break time in minutes (breaks that have already happened)
        function calculateElapsedBreakTime(variant, currentTime) {
            let elapsedBreakTime = 0;
            const now = currentTime || new Date();

            // Check lunch break
            if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
                const lunchStartDate = createTimeDate(variant["Break Start (Lunch)"]);
                const lunchEndDate = createTimeDate(variant["Break End (Lunch)"]);
                
                // If lunch break has started
                if (now >= lunchStartDate) {
                    // If lunch break has ended, add full break time
                    if (now >= lunchEndDate) {
                        elapsedBreakTime += getTimeDifferenceInMinutes(
                            variant["Break Start (Lunch)"], 
                            variant["Break End (Lunch)"]
                        );
                    } 
                    // If lunch break is in progress, add elapsed portion
                    else {
                        elapsedBreakTime += (now - lunchStartDate) / (1000 * 60);
                    }
                }
            }

            // Check tea break
            if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
                const teaStartDate = createTimeDate(variant["Break Start (Tea)"]);
                const teaEndDate = createTimeDate(variant["Break End (Tea)"]);
                
                // If tea break has started
                if (now >= teaStartDate) {
                    // If tea break has ended, add full break time
                    if (now >= teaEndDate) {
                        elapsedBreakTime += getTimeDifferenceInMinutes(
                            variant["Break Start (Tea)"], 
                            variant["Break End (Tea)"]
                        );
                    } 
                    // If tea break is in progress, add elapsed portion
                    else {
                        elapsedBreakTime += (now - teaStartDate) / (1000 * 60);
                    }
                }
            }

            // Check OT tea break
            if (variant["OT Break Start (Tea)"] && 
                variant["OT Break End (Tea)"] && 
                variant["OT Break Start (Tea)"] !== "-" && 
                variant["OT Break End (Tea)"] !== "-") {
                
                const otTeaStartDate = createTimeDate(variant["OT Break Start (Tea)"]);
                const otTeaEndDate = createTimeDate(variant["OT Break End (Tea)"]);
                
                // If OT tea break has started
                if (now >= otTeaStartDate) {
                    // If OT tea break has ended, add full break time
                    if (now >= otTeaEndDate) {
                        elapsedBreakTime += getTimeDifferenceInMinutes(
                            variant["OT Break Start (Tea)"], 
                            variant["OT Break End (Tea)"]
                        );
                    } 
                    // If OT tea break is in progress, add elapsed portion
                    else {
                        elapsedBreakTime += (now - otTeaStartDate) / (1000 * 60);
                    }
                }
            }

            return elapsedBreakTime;
        }

        // Helper function to create a Date object for a time string using today's date
        function createTimeDate(timeStr) {
            const now = new Date();
            const [hours, minutes] = timeStr.split(':').map(Number);
            const timeDate = new Date(now);
            timeDate.setHours(hours, minutes, 0, 0);
            return timeDate;
        }

        // Helper function to calculate time difference in minutes between two time strings
        function getTimeDifferenceInMinutes(startTimeStr, endTimeStr) {
            const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
            const [endHours, endMinutes] = endTimeStr.split(':').map(Number);
            
            const startTotalMinutes = (startHours * 60) + startMinutes;
            const endTotalMinutes = (endHours * 60) + endMinutes;
            
            return endTotalMinutes - startTotalMinutes;
        }

        // Fallback calculation if we don't have start/break time data
        function calculateSimplifiedCycleTime(variant) {
            if (!variant.hourlyProduction || variant.hourlyProduction.length === 0) {
                return "N/A";
            }
            
            // Get total production and hours
            let totalProduction = 0;
            let validHours = 0;
            
            variant.hourlyProduction.forEach(item => {
                if (item.production > 0) {
                    totalProduction += item.production;
                    validHours++;
                }
            });
            
            if (validHours === 0 || totalProduction === 0) {
                return "N/A";
            }
            
            // Calculate average production per hour
            const avgProductionPerHour = totalProduction / validHours;
            
            // Calculate seconds per unit (cycle time)
            const secondsPerHour = 3600;
            const cycleTime = secondsPerHour / avgProductionPerHour;
            
            // Return rounded value
            return Math.round(cycleTime);
        }

        // Get supervisor name for a variant
        function getSupervisorForVariant(variant) {
            if (!variant || !productionData.supervisors) {
                return "Unknown";
            }
            
            // Look through supervisors to find which one is responsible for this variant
            for (const supervisor of productionData.supervisors) {
                if (supervisor.variants && supervisor.variants[variant.variant]) {
                    return supervisor.name;
                }
            }
            
            return "Unknown";
        }

        // Fetch production data
        async function fetchProductionData() {
            try {
                console.log(`Attempting to fetch data from: ${DATA_URL}`);
                const cacheBuster = '?_=' + new Date().getTime();
                const fullUrl = DATA_URL + cacheBuster;
                const response = await fetch(fullUrl);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Fetched data:', data);

                // Validate data structure
                if (!data.variants || !Array.isArray(data.variants) || !data.supervisors || !Array.isArray(data.supervisors)) {
                    throw new Error('Invalid data structure in data.json');
                }

                if (!lastUpdateTime || lastUpdateTime !== data.timestamp) {
                    productionData = data;
                    lastUpdateTime = data.timestamp;

                    const updateTime = new Date(data.timestamp);
                    document.getElementById('last-update').textContent = 
                        'Last updated: ' + updateTime.toLocaleTimeString('en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: true
                        });

                    updateFilterValueDropdown();
                    filterVariants();
                    updateHourDropdown();

                    document.getElementById('total-variants').textContent = filteredVariants.length;

                    if (currentVariantIndex >= filteredVariants.length) {
                        currentVariantIndex = 0;
                    }

                    if (filteredVariants.length > 0) {
                        displayVariant(currentVariantIndex);
                    } else {
                        showLoadingOrError('No data available.');
                    }
                }
                isLoading = false;
                updateLoadingState();
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
                // Use local data for demo purposes
                useLocalData();
            }
        }

        // Use local data for demo purposes when fetch fails
        function useLocalData() {
            // Check if we already parsed the local data
            if (document.querySelector('#local-data')) {
                const localData = JSON.parse(document.querySelector('#local-data').textContent);
                // Update timestamp to current time for local data
                localData.timestamp = new Date().toISOString();
                productionData = localData;
                lastUpdateTime = localData.timestamp;
                
                // Update the last update display with current time
                const updateTime = new Date();
                document.getElementById('last-update').textContent = 
                    'Last updated: ' + updateTime.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true
                    });
                
                updateFilterValueDropdown();
                filterVariants();
                updateHourDropdown();
                
                document.getElementById('total-variants').textContent = filteredVariants.length;
                
                if (filteredVariants.length > 0) {
                    displayVariant(0);
                }
            }
        }

        // Update filter value dropdown based on selected filter type
        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear previous options
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor') {
                // Add supervisor options
                if (productionData.supervisors && productionData.supervisors.length > 0) {
                    productionData.supervisors.forEach(supervisor => {
                        const option = document.createElement('option');
                        option.value = supervisor.name;
                        option.textContent = supervisor.name;
                        filterValueSelect.appendChild(option);
                    });
                }
            } else if (selectedFilterType === 'variant') {
                // Add variant options
                if (productionData.variants && productionData.variants.length > 0) {
                    // Create a Set to avoid duplicates
                    const uniqueVariants = new Set();
                    productionData.variants.forEach(variant => {
                        uniqueVariants.add(variant.variant);
                    });
                    
                    // Add each unique variant to the dropdown
                    uniqueVariants.forEach(variantName => {
                        const option = document.createElement('option');
                        option.value = variantName;
                        option.textContent = variantName;
                        filterValueSelect.appendChild(option);
                    });
                }
            }
            
            // Try to keep the previous selection if it exists in the new options
            if (Array.from(filterValueSelect.options).some(opt => opt.value === currentValue)) {
                filterValueSelect.value = currentValue;
                selectedFilterValue = currentValue;
            } else {
                filterValueSelect.value = 'all';
                selectedFilterValue = 'all';
            }
        }

        // Filter variants based on selected filter type and value
        function filterVariants() {
            if (selectedFilterValue === 'all') {
                filteredVariants = productionData.variants || [];
            } else if (selectedFilterType === 'supervisor') {
                const supervisor = productionData.supervisors.find(s => s.name === selectedFilterValue);
                
                if (supervisor && supervisor.variants) {
                    const supervisorVariantKeys = Object.keys(supervisor.variants);
                    filteredVariants = productionData.variants.filter(variant => 
                        supervisorVariantKeys.includes(variant.variant));
                } else {
                    filteredVariants = [];
                }
            } else if (selectedFilterType === 'variant') {
                filteredVariants = productionData.variants.filter(variant => 
                    variant.variant === selectedFilterValue);
            }
            
            // Sort variants by supervisor name alphabetically
            filteredVariants.sort((a, b) => {
                const supervisorA = getSupervisorForVariant(a);
                const supervisorB = getSupervisorForVariant(b);
                
                if (supervisorA < supervisorB) return -1;
                if (supervisorA > supervisorB) return 1;
                
                // If same supervisor, sort by variant name
                return a.variant.localeCompare(b.variant);
            });
            
            document.getElementById('total-variants').textContent = filteredVariants.length;
        }

        // Update date and time
        function updateDateTime() {
            const now = new Date();

            // Format: "March 2, 2025"
            document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            });

            // Format: "HH:MM:SS" (24-hour)
            document.getElementById('current-time').textContent = now.toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Display data for the specified variant
        function displayVariant(index) {
            if (!filteredVariants || filteredVariants.length === 0) {
                showLoadingOrError('No variants available.');
                return;
            }

            const variant = filteredVariants[index];
            isLoading = false;

            // Get supervisor name for this variant
            const supervisorName = getSupervisorForVariant(variant);
            
            // Apply supervisor-specific styling
            applySupervisorStyling(supervisorName);

            // Update the variant and supervisor display
            document.getElementById('variant-name').textContent = `Product Variant: ${variant.variant}`;
            document.getElementById('supervisor-name').textContent = `Line Supervisor: ${supervisorName}`;
            
            // Display target and actual cycle times
            document.getElementById('target-cycle-time').textContent = `Target: ${variant.cycleTime} sec/unit`;
            const actualCycleTime = calculateActualCycleTime(variant);
            document.getElementById('actual-cycle-time').textContent = `Actual: ${actualCycleTime} sec/unit`;
            
            document.getElementById('current-variant-index').textContent = (index + 1);

            updateTotalsDisplay(variant);
            renderCumulativeChart(variant);
            renderHourlyChart(variant);
            updateLoadingState();
        }

        // Update the totals display with new format
        function updateTotalsDisplay(variant) {
            const totalsDisplay = document.getElementById('totals-display');
            totalsDisplay.innerHTML = '';

            // Get the box data
            const boxesCompleted = variant.currentBoxTotal || 0;
            const totalBoxes = variant.dailyBoxTarget || 0;

            // Current Total (with units and boxes)
            const totalActual = document.createElement('div');
            totalActual.className = 'total-item';
            totalActual.innerHTML = `
                <div class="total-label">Current Total</div>
                <div class="total-value total-actual">${variant.currentTotal || 0}</div>
                <div class="total-subvalue">${boxesCompleted} boxes</div>
            `;
            totalsDisplay.appendChild(totalActual);

            // Daily Target (with units and boxes)
            const totalTarget = document.createElement('div');
            totalTarget.className = 'total-item';
            totalTarget.innerHTML = `
                <div class="total-label">Daily Target</div>
                <div class="total-value total-target">${variant.dailyTarget || 0}</div>
                <div class="total-subvalue">${totalBoxes} boxes</div>
            `;
            totalsDisplay.appendChild(totalTarget);

            // Progress Percentage
            const progress = variant.progressPercentage || 0;
            const totalProgress = document.createElement('div');
            totalProgress.className = 'total-item';
            totalProgress.innerHTML = `
                <div class="total-label">Progress</div>
                <div class="total-value total-progress">${progress}%</div>
                <div class="total-subvalue">${boxesCompleted} of ${totalBoxes} boxes</div>
            `;
            totalsDisplay.appendChild(totalProgress);

            // Hourly Targets Met
            // Calculate how many hourly targets have been met
            let hourlyTargetsMet = 0;
            let totalHourlyTargets = 0;
            
            if (variant.hourlyProduction && Array.isArray(variant.hourlyProduction) && 
                variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                
                // Create a map of hourly targets
                const hourlyTargetsMap = new Map();
                variant.hourlyTargets.forEach(item => {
                    hourlyTargetsMap.set(item.hour, item.target || 0);
                });
                
                // Count met targets
                variant.hourlyProduction.forEach(item => {
                    if (hourlyTargetsMap.has(item.hour)) {
                        totalHourlyTargets++;
                        if (item.production >= hourlyTargetsMap.get(item.hour)) {
                            hourlyTargetsMet++;
                        }
                    }
                });
            }
            
            const hourlyTargets = document.createElement('div');
            hourlyTargets.className = 'total-item';
            hourlyTargets.innerHTML = `
                <div class="total-label">Hourly Targets</div>
                <div class="total-value total-hourly">${hourlyTargetsMet} / ${totalHourlyTargets}</div>
                <div class="total-subvalue">targets met</div>
            `;
            totalsDisplay.appendChild(hourlyTargets);
        }

        // Get all sorted production hours from a variant
        function getSortedProductionHours(variant) {
            // Get all production hours from hourlyTargets
            const productionHours = [];
            if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                variant.hourlyTargets.forEach(item => {
                    if (item.hour) {
                        productionHours.push(item.hour);
                    }
                });
            }
            
            // Sort hours
            return [...productionHours].sort((a, b) => {
                const timeA = a.split(':').map(Number);
                const timeB = b.split(':').map(Number);
                if (timeA[0] !== timeB[0]) return timeA[0] - timeB[0];
                return timeA[1] - timeB[1];
            });
        }

        // Render the cumulative chart using SVG
        function renderCumulativeChart(variant) {
            const chartContainer = document.getElementById('cumulative-chart');
            chartContainer.innerHTML = '';

            // Prepare data by mapping cumulativeProduction and cumulativeTargets into a table
            const dataMap = new Map();

            // Map cumulative targets to include all hours
            if (variant.cumulativeTargets && Array.isArray(variant.cumulativeTargets)) {
                variant.cumulativeTargets.forEach(item => {
                    dataMap.set(item.hour, { hour: item.hour, target: item.target || 0, production: 0 });
                });
            }

            // Map cumulative production to include all hours
            if (variant.cumulativeProduction && Array.isArray(variant.cumulativeProduction)) {
                variant.cumulativeProduction.forEach(item => {
                    if (dataMap.has(item.hour)) {
                        dataMap.get(item.hour).production = item.production || 0;
                    } else {
                        dataMap.set(item.hour, { hour: item.hour, target: 0, production: item.production || 0 });
                    }
                });
            }

            // Get sorted production hours
            const sortedHours = getSortedProductionHours(variant);

            // Fill in missing hours with zeros
            sortedHours.forEach(hour => {
                if (!dataMap.has(hour)) {
                    dataMap.set(hour, { hour, target: 0, production: 0 });
                }
            });

            // Sort the data by hour
            const sortedData = Array.from(dataMap.values()).sort((a, b) => {
                const timeA = a.hour.split(':').map(Number);
                const timeB = b.hour.split(':').map(Number);
                if (timeA[0] !== timeB[0]) return timeA[0] - timeB[0];
                return timeA[1] - timeB[1];
            });

            if (sortedData.length === 0) {
                chartContainer.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
                return;
            }

            // Find max value for scaling
            let maxValue = 0;
            sortedData.forEach(item => {
                maxValue = Math.max(maxValue, item.target || 0, item.production || 0);
            });
            maxValue = maxValue * 1.1; // Add some headroom

            // Create SVG for line chart
            const svgWidth = chartContainer.clientWidth || 600;
            const svgHeight = 370; // Adjusted height
            const padding = commonChartPadding; // Use common padding for both charts
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;

            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            chartContainer.appendChild(svg);

            // Create grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Horizontal grid lines (5 lines including 0)
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                // Add value labels for grid lines
                if (i < 5) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', padding.left - 10);
                    text.setAttribute('y', y + 5);
                    text.setAttribute('text-anchor', 'end');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = Math.round(maxValue * (4 - i) / 4);
                    gridGroup.appendChild(text);
                }
            }
            
            // Add Y-axis title "Units"
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 45);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 45}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            gridGroup.appendChild(yAxisTitle);
            
            // Vertical grid line at the start
            const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            startLine.setAttribute('x1', padding.left);
            startLine.setAttribute('y1', padding.top);
            startLine.setAttribute('x2', padding.left);
            startLine.setAttribute('y2', svgHeight - padding.bottom);
            startLine.setAttribute('stroke', '#666'); // Darker color for axis line
            startLine.setAttribute('stroke-width', '1.5'); // Slightly thicker for axis
            gridGroup.appendChild(startLine);
            
            // Horizontal axis line (x-axis)
            const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine.setAttribute('x1', padding.left);
            xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
            xAxisLine.setAttribute('x2', svgWidth - padding.right);
            xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
            xAxisLine.setAttribute('stroke', '#666');
            xAxisLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxisLine);
            
            svg.appendChild(gridGroup);
            
            // Create x-axis labels
            const xLabelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            sortedData.forEach((item, index) => {
                const x = padding.left + (chartWidth * index / (sortedData.length - 1));
                const y = svgHeight - padding.bottom + 20;
                
                // Add axis tick
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', svgHeight - padding.bottom);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', svgHeight - padding.bottom + 5);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                xLabelsGroup.appendChild(tick);
                
                // Add hour label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#666');
                text.textContent = item.hour;
                xLabelsGroup.appendChild(text);
            });
            svg.appendChild(xLabelsGroup);

            // Create production line (blue)
            const productionLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Create production path
            const productionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let productionPathD = '';
            
            // Points for production line
            const productionPoints = [];
            sortedData.forEach((item, index) => {
                const x = padding.left + (chartWidth * index / (sortedData.length - 1));
                const y = padding.top + chartHeight - (chartHeight * (item.production / maxValue));
                productionPoints.push({ x, y });
                
                if (index === 0) {
                    productionPathD = `M ${x} ${y}`;
                } else {
                    productionPathD += ` L ${x} ${y}`;
                }
            });
            
            productionPath.setAttribute('d', productionPathD);
            productionPath.setAttribute('stroke', 'var(--secondary-color)');
            productionPath.setAttribute('stroke-width', '3');
            productionPath.setAttribute('fill', 'none');
            productionLineGroup.appendChild(productionPath);
            
            // Add points for production line
            productionPoints.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', 'var(--secondary-color)');
                productionLineGroup.appendChild(circle);
            });
            
            svg.appendChild(productionLineGroup);
            
            // Create target line (green)
            const targetLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Create target path
            const targetPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let targetPathD = '';
            
            // Points for target line
            const targetPoints = [];
            sortedData.forEach((item, index) => {
                const x = padding.left + (chartWidth * index / (sortedData.length - 1));
                const y = padding.top + chartHeight - (chartHeight * (item.target / maxValue));
                targetPoints.push({ x, y });
                
                if (index === 0) {
                    targetPathD = `M ${x} ${y}`;
                } else {
                    targetPathD += ` L ${x} ${y}`;
                }
            });
            
            targetPath.setAttribute('d', targetPathD);
            targetPath.setAttribute('stroke', 'var(--success-color)');
            targetPath.setAttribute('stroke-width', '3');
            targetPath.setAttribute('fill', 'none');
            targetLineGroup.appendChild(targetPath);
            
            // Add points for target line
            targetPoints.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '4');
                circle.setAttribute('fill', 'var(--success-color)');
                targetLineGroup.appendChild(circle);
            });
            
            svg.appendChild(targetLineGroup);
        }

        // Render the hourly bar chart using SVG
        function renderHourlyChart(variant) {
            const chartContainer = document.getElementById('hourly-chart');
            chartContainer.innerHTML = '';

            // Prepare data by mapping hourlyProduction and hourlyTargets into a table
            const dataMap = new Map();

            // Map hourly targets to include all hours
            if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                variant.hourlyTargets.forEach(item => {
                    dataMap.set(item.hour, { hour: item.hour, target: item.target || 0, production: 0 });
                });
            }

            // Map hourly production to include all hours
            if (variant.hourlyProduction && Array.isArray(variant.hourlyProduction)) {
                variant.hourlyProduction.forEach(item => {
                    if (dataMap.has(item.hour)) {
                        dataMap.get(item.hour).production = item.production || 0;
                    } else {
                        dataMap.set(item.hour, { hour: item.hour, target: 0, production: item.production || 0 });
                    }
                });
            }

            // Get sorted production hours
            const sortedHours = getSortedProductionHours(variant);

            // Fill in missing hours with zeros
            sortedHours.forEach(hour => {
                if (!dataMap.has(hour)) {
                    dataMap.set(hour, { hour, target: 0, production: 0 });
                }
            });

            // Determine which hour to display
            let displayHour;
            
            if (selectedHour === 'current') {
                // Get the next production hour for "current" selection
                displayHour = getNextProductionHour();
            } else {
                // Use the selected hour
                displayHour = selectedHour;
            }
            
            // Update the hour info display
            document.querySelector('.hour-time').textContent = `Hour: ${displayHour}`;
            
            // Start countdown if showing the current/next hour
            if (selectedHour === 'current') {
                startCountdown(displayHour);
            } else {
                // Clear countdown for historical hours
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                document.querySelector('.hour-countdown').textContent = '';
            }
            
            // Get data for the display hour
            const hourData = dataMap.get(displayHour) || { hour: displayHour, production: 0, target: 0 };
            const production = hourData.production || 0;
            const target = hourData.target || 0;

            // Create an SVG for the bar chart using same dimensions and padding as line chart
            const svgWidth = chartContainer.clientWidth || 600;
            const svgHeight = 370; // Adjusted height to match line chart
            const padding = commonChartPadding; // Use common padding for both charts
            const chartWidth = svgWidth - padding.left - padding.right;
            const chartHeight = svgHeight - padding.top - padding.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            chartContainer.appendChild(svg);
            
            // Find max value for scaling
            const maxValue = Math.max(production, target, 1) * 1.2; // Add some headroom
            
            // Add horizontal grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', padding.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', svgWidth - padding.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ddd');
                line.setAttribute('stroke-width', '1');
                gridGroup.appendChild(line);
                
                // Add value labels (for all 5 lines)
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', padding.left - 10);
                text.setAttribute('y', y + 5);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#666');
                text.textContent = Math.round(maxValue * (4 - i) / 4);
                gridGroup.appendChild(text);
            }
            
            // Add Y-axis title "Units"
            const yAxisTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisTitle.setAttribute('x', padding.left - 45);
            yAxisTitle.setAttribute('y', padding.top + chartHeight / 2);
            yAxisTitle.setAttribute('text-anchor', 'middle');
            yAxisTitle.setAttribute('font-size', '14');
            yAxisTitle.setAttribute('font-weight', 'bold');
            yAxisTitle.setAttribute('fill', '#666');
            yAxisTitle.setAttribute('transform', `rotate(-90, ${padding.left - 45}, ${padding.top + chartHeight / 2})`);
            yAxisTitle.textContent = 'Units';
            gridGroup.appendChild(yAxisTitle);
            
            // Add vertical grid line (y-axis)
            const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vLine.setAttribute('x1', padding.left);
            vLine.setAttribute('y1', padding.top);
            vLine.setAttribute('x2', padding.left);
            vLine.setAttribute('y2', svgHeight - padding.bottom);
            vLine.setAttribute('stroke', '#666'); // Darker color for axis line
            vLine.setAttribute('stroke-width', '1.5'); // Slightly thicker for axis
            gridGroup.appendChild(vLine);
            
            // Add horizontal x-axis line
            const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine.setAttribute('x1', padding.left);
            xAxisLine.setAttribute('y1', svgHeight - padding.bottom);
            xAxisLine.setAttribute('x2', svgWidth - padding.right);
            xAxisLine.setAttribute('y2', svgHeight - padding.bottom);
            xAxisLine.setAttribute('stroke', '#666');
            xAxisLine.setAttribute('stroke-width', '1.5');
            gridGroup.appendChild(xAxisLine);
            
            svg.appendChild(gridGroup);
            
            // Calculate bar positions and dimensions
            const barWidth = 60;
            const barSpacing = 40;
            const startX = svgWidth / 2 - barWidth - barSpacing / 2;
            
            // Create production bar (blue)
            const productionBarHeight = (production / maxValue) * chartHeight;
            const productionBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            productionBar.setAttribute('x', startX);
            productionBar.setAttribute('y', padding.top + chartHeight - productionBarHeight);
            productionBar.setAttribute('width', barWidth);
            productionBar.setAttribute('height', productionBarHeight);
            productionBar.setAttribute('fill', 'var(--secondary-color)');
            productionBar.setAttribute('rx', '4'); // Rounded corners
            svg.appendChild(productionBar);
            
            // Create target bar (green)
            const targetBarHeight = (target / maxValue) * chartHeight;
            const targetBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetBar.setAttribute('x', startX + barWidth + barSpacing);
            targetBar.setAttribute('y', padding.top + chartHeight - targetBarHeight);
            targetBar.setAttribute('width', barWidth);
            targetBar.setAttribute('height', targetBarHeight);
            targetBar.setAttribute('fill', 'var(--success-color)');
            targetBar.setAttribute('rx', '4'); // Rounded corners
            svg.appendChild(targetBar);
            
            // Add bar labels directly onto bars to replace legend
            // Production value
            const productionValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            productionValueText.setAttribute('x', startX + barWidth / 2);
            productionValueText.setAttribute('y', padding.top + chartHeight - productionBarHeight - 10);
            productionValueText.setAttribute('text-anchor', 'middle');
            productionValueText.setAttribute('font-size', '15');
            productionValueText.setAttribute('font-weight', '600');
            productionValueText.setAttribute('fill', 'var(--secondary-color)');
            productionValueText.textContent = production;
            // Add drop shadow for better readability
            const productionShadow = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            productionShadow.setAttribute('id', 'textShadow');
            const feDropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
            feDropShadow.setAttribute('dx', '0');
            feDropShadow.setAttribute('dy', '0');
            feDropShadow.setAttribute('stdDeviation', '1');
            feDropShadow.setAttribute('flood-opacity', '0.2');
            productionShadow.appendChild(feDropShadow);
            svg.appendChild(productionShadow);
            productionValueText.setAttribute('filter', 'url(#textShadow)');
            svg.appendChild(productionValueText);
            
            // Target value
            const targetValueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetValueText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
            targetValueText.setAttribute('y', padding.top + chartHeight - targetBarHeight - 10);
            targetValueText.setAttribute('text-anchor', 'middle');
            targetValueText.setAttribute('font-size', '15');
            targetValueText.setAttribute('font-weight', '600');
            targetValueText.setAttribute('fill', 'var(--success-color)');
            targetValueText.setAttribute('filter', 'url(#textShadow)');
            targetValueText.textContent = target;
            svg.appendChild(targetValueText);
            
            // Production label
            const productionLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            productionLabelText.setAttribute('x', startX + barWidth / 2);
            productionLabelText.setAttribute('y', svgHeight - padding.bottom + 25);
            productionLabelText.setAttribute('text-anchor', 'middle');
            productionLabelText.setAttribute('font-size', '13');
            productionLabelText.setAttribute('font-weight', '500');
            productionLabelText.setAttribute('fill', 'var(--secondary-color)');
            productionLabelText.textContent = 'Production';
            svg.appendChild(productionLabelText);
            
            // Target label
            const targetLabelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            targetLabelText.setAttribute('x', startX + barWidth + barSpacing + barWidth / 2);
            targetLabelText.setAttribute('y', svgHeight - padding.bottom + 25);
            targetLabelText.setAttribute('text-anchor', 'middle');
            targetLabelText.setAttribute('font-size', '13');
            targetLabelText.setAttribute('font-weight', '500');
            targetLabelText.setAttribute('fill', 'var(--success-color)');
            targetLabelText.textContent = 'Target';
            svg.appendChild(targetLabelText);
            
            // Add X-axis line at chart bottom for clarity
            const xAxisLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxisLine2.setAttribute('x1', padding.left);
            xAxisLine2.setAttribute('y1', padding.top + chartHeight);
            xAxisLine2.setAttribute('x2', svgWidth - padding.right);
            xAxisLine2.setAttribute('y2', padding.top + chartHeight);
            xAxisLine2.setAttribute('stroke', '#666');
            xAxisLine2.setAttribute('stroke-width', '1.5');
            svg.appendChild(xAxisLine2);
        }

        // Show loading or error message
        function showLoadingOrError(message) {
            const totalsDisplay = document.getElementById('totals-display');
            totalsDisplay.innerHTML = `<div class="${isLoading ? 'loading' : 'error'}">${message}</div>`;
            document.getElementById('variant-name').textContent = 'Loading...';
            document.getElementById('supervisor-name').textContent = 'Line Supervisor: Loading...';
            document.getElementById('target-cycle-time').textContent = 'Target: Loading...';
            document.getElementById('actual-cycle-time').textContent = 'Actual: Loading...';
            const charts = document.querySelectorAll('.line-chart, .bar-chart');
            charts.forEach(chart => {
                chart.innerHTML = '<div style="text-align:center;padding:20px;">No data available</div>';
            });
        }

        // Update loading state in UI
        function updateLoadingState() {
            const totalsDisplay = document.getElementById('totals-display');
            if (isLoading) {
                totalsDisplay.innerHTML = '<div class="loading">Loading data...</div>';
            } else if (!filteredVariants || filteredVariants.length === 0) {
                showLoadingOrError('No data available.');
            }
        }

        // Show debug popup
        function showDebugPopup() {
            const variant = filteredVariants[currentVariantIndex];
            if (!variant) return;

            const popupContent = document.getElementById('debugPopupContent');
            popupContent.innerHTML = '';

            // Add supervisor information
            const supervisorName = getSupervisorForVariant(variant);
            popupContent.innerHTML += `<h3>Supervisor: ${supervisorName}</h3>`;

            // Cycle Time Data
            popupContent.innerHTML += '<h3>Cycle Time Information</h3>';
            popupContent.innerHTML += `
                <table>
                    <tr>
                        <th>Target Cycle Time</th>
                        <td>${variant.cycleTime} sec/unit</td>
                    </tr>
                    <tr>
                        <th>Actual Cycle Time</th>
                        <td>${calculateActualCycleTime(variant)} sec/unit</td>
                    </tr>
                    <tr>
                        <th>Start Time</th>
                        <td>${variant["Start Time"] || 'N/A'}</td>
                    </tr>
                    <tr>
                        <th>End Time</th>
                        <td>${variant["End Time"] || 'N/A'}</td>
                    </tr>
                    <tr>
                        <th>Lunch Break</th>
                        <td>${variant["Break Start (Lunch)"] || 'N/A'} - ${variant["Break End (Lunch)"] || 'N/A'}</td>
                    </tr>
                    <tr>
                        <th>Tea Break</th>
                        <td>${variant["Break Start (Tea)"] || 'N/A'} - ${variant["Break End (Tea)"] || 'N/A'}</td>
                    </tr>
                    <tr>
                        <th>OT Tea Break</th>
                        <td>${variant["OT Break Start (Tea)"] || 'N/A'} - ${variant["OT Break End (Tea)"] || 'N/A'}</td>
                    </tr>
                    <tr>
                        <th>Total Break Time</th>
                        <td>${calculateAllocatedBreakTime(variant)} minutes</td>
                    </tr>
                    <tr>
                        <th>Elapsed Break Time</th>
                        <td>${calculateElapsedBreakTime(variant).toFixed(2)} minutes</td>
                    </tr>
                    <tr>
                        <th>Current Total</th>
                        <td>${variant.currentTotal || 0} units</td>
                    </tr>
                </table>
            `;

            // Cumulative Data Table
            popupContent.innerHTML += '<h3>Cumulative Production & Target Data</h3>';
            popupContent.innerHTML += '<table><thead><tr><th>Hour</th><th>Production</th><th>Target</th></tr></thead><tbody>';
            
            // Get sorted production hours
            const sortedHours = getSortedProductionHours(variant);
            
            // Create maps for data
            const cumulativeDataMap = new Map();

            if (variant.cumulativeTargets && Array.isArray(variant.cumulativeTargets)) {
                variant.cumulativeTargets.forEach(item => {
                    cumulativeDataMap.set(item.hour, { hour: item.hour, target: item.target || 0, production: 0 });
                });
            }

            if (variant.cumulativeProduction && Array.isArray(variant.cumulativeProduction)) {
                variant.cumulativeProduction.forEach(item => {
                    if (cumulativeDataMap.has(item.hour)) {
                        cumulativeDataMap.get(item.hour).production = item.production || 0;
                    } else {
                        cumulativeDataMap.set(item.hour, { hour: item.hour, target: 0, production: item.production || 0 });
                    }
                });
            }

            sortedHours.forEach(hour => {
                const data = cumulativeDataMap.get(hour) || { hour, production: 0, target: 0 };
                popupContent.innerHTML += `<tr><td>${data.hour}</td><td>${data.production}</td><td>${data.target}</td></tr>`;
            });
            popupContent.innerHTML += '</tbody></table>';

            // Hourly Data Table
            popupContent.innerHTML += '<h3>Hourly Production & Target Data</h3>';
            popupContent.innerHTML += '<table><thead><tr><th>Hour</th><th>Production</th><th>Target</th></tr></thead><tbody>';
            
            const hourlyDataMap = new Map();

            if (variant.hourlyTargets && Array.isArray(variant.hourlyTargets)) {
                variant.hourlyTargets.forEach(item => {
                    hourlyDataMap.set(item.hour, { hour: item.hour, target: item.target || 0, production: 0 });
                });
            }

            if (variant.hourlyProduction && Array.isArray(variant.hourlyProduction)) {
                variant.hourlyProduction.forEach(item => {
                    if (hourlyDataMap.has(item.hour)) {
                        hourlyDataMap.get(item.hour).production = item.production || 0;
                    } else {
                        hourlyDataMap.set(item.hour, { hour: item.hour, target: 0, production: item.production || 0 });
                    }
                });
            }

            sortedHours.forEach(hour => {
                const data = hourlyDataMap.get(hour) || { hour, production: 0, target: 0 };
                popupContent.innerHTML += `<tr><td>${data.hour}</td><td>${data.production}</td><td>${data.target}</td></tr>`;
            });
            popupContent.innerHTML += '</tbody></table>';

            document.getElementById('debugPopup').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        // Hide debug popup
        function hideDebugPopup() {
            document.getElementById('debugPopup').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        // Cycle to the next variant
        function cycleVariants() {
            if (!filteredVariants || filteredVariants.length === 0 || !isAutocycling) {
                return;
            }

            updateCycleProgress(0);

            currentVariantIndex = (currentVariantIndex + 1) % filteredVariants.length;
            displayVariant(currentVariantIndex);

            animateProgress();
        }

        // Animate the progress bar for timing
        function animateProgress() {
            let progress = 0;
            const interval = 100;
            const steps = CYCLE_INTERVAL / interval;

            const progressInterval = setInterval(() => {
                progress += (100 / steps);
                if (progress > 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                }
                updateCycleProgress(progress);
            }, interval);
        }

        // Update the cycle progress bar
        function updateCycleProgress(percent) {
            document.getElementById('cycle-progress').style.width = `${percent}%`;
        }

        // Toggle auto-cycling
        function toggleAutoCycle() {
            isAutocycling = !isAutocycling;
            const button = document.getElementById('auto-cycle-button');
            if (button) {
                button.textContent = isAutocycling ? 'Stop Auto-Cycle' : 'Start Auto-Cycle';
                button.className = isAutocycling 
                    ? 'auto-cycle-button' 
                    : 'auto-cycle-button start';
            }
        }

        // Initialize the dashboard when the page loads
        window.onload = initDashboard;
    </script>

    <!-- Add the sample data as a hidden element for demo purposes when fetch fails -->
    <script id="local-data" type="application/json">
    {
        "timestamp": "2025-03-03T00:00:00.000Z",
        "variants": [
            {
              "variant": "LEVO XL1150SCi",
              "Start Time": "07:30",
              "End Time": "18:30",
              "Break Start (Lunch)": "13:40",
              "Break End (Lunch)": "14:10",
              "Break Start (Tea)": "10:25",
              "Break End (Tea)": "10:40",
              "OT Break Start (Tea)": "17:45",
              "OT Break End (Tea)": "18:00",
              "totalavailableWorkHours": 10,
              "cycleTime": 99,
              "hourlyTarget": 36,
              "dailyTarget": 363,
              "dailyBoxTarget": 20,
              "currentTotal": 198,
              "currentBoxTotal": 11,
              "progressPercentage": 55,
              "hourlyProduction": [
                {"hour": "08:30", "production": 36},
                {"hour": "09:30", "production": 0},
                {"hour": "10:30", "production": 18},
                {"hour": "11:30", "production": 54},
                {"hour": "12:30", "production": 36},
                {"hour": "13:30", "production": 18},
                {"hour": "14:30", "production": 0},
                {"hour": "15:30", "production": 18},
                {"hour": "16:30", "production": 18},
                {"hour": "17:30", "production": 0},
                {"hour": "18:30", "production": 0}
              ],
              "cumulativeTargets": [
                {"hour": "08:30", "target": 36},
                {"hour": "09:30", "target": 72},
                {"hour": "10:30", "target": 105},
                {"hour": "11:30", "target": 135},
                {"hour": "12:30", "target": 171},
                {"hour": "13:30", "target": 207},
                {"hour": "14:30", "target": 225},
                {"hour": "15:30", "target": 261},
                {"hour": "16:30", "target": 297},
                {"hour": "17:30", "target": 333},
                {"hour": "18:30", "target": 360}
              ],
              "cumulativeProduction": [
                {"hour": "08:30", "production": 36},
                {"hour": "09:30", "production": 36},
                {"hour": "10:30", "production": 54},
                {"hour": "11:30", "production": 108},
                {"hour": "12:30", "production": 144},
                {"hour": "13:30", "production": 162},
                {"hour": "14:30", "production": 162},
                {"hour": "15:30", "production": 180},
                {"hour": "16:30", "production": 198}
              ],
              "hourlyTargets": [
                {"hour": "08:30", "target": 36},
                {"hour": "09:30", "target": 36},
                {"hour": "10:30", "target": 33},
                {"hour": "11:30", "target": 30},
                {"hour": "12:30", "target": 36},
                {"hour": "13:30", "target": 36},
                {"hour": "14:30", "target": 18},
                {"hour": "15:30", "target": 36},
                {"hour": "16:30", "target": 36},
                {"hour": "17:30", "target": 36},
                {"hour": "18:30", "target": 27}
              ]
            }
        ],
        "supervisors": [
            {
              "name": "Siyabonga",
              "variants": {
                "LEVO XL1150SCi": {
                  "variant": "LEVO XL1150SCi",
                  "currentTotal": 198,
                  "dailyTarget": 363,
                  "progressPercentage": 55
                }
              },
              "totalProduction": 198,
              "totalTarget": 363,
              "progressPercentage": 55
            }
        ]
    }
    </script>
</body>
</html>
