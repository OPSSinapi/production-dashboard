<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Secondary Production Dashboard</title>
    <link rel="icon" href="data:,">
    <!-- Add Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        :root {
    --primary-color: #2c3e50;
    --secondary-color: #3B82F6;
    --success-color: #10B981;
    --warning-color: #F59E0B;
    --danger-color: #e74c3c;
    --light-color: #f3f4f6;
    --dark-color: #1e293b;
    --supervisor-luthando: #F9E79F;
    --supervisor-apelele: #e6e6e6; /* Light grey for Apelele */
    --supervisor-siyabonga: #FADBD8;
    --supervisor-nosi: #D6EAF8;
    --supervisor-mvokwe: #D5F5E3;
    --supervisor-michaela: #F9E79F; /* Same as Luthando for Michaela */
    --production-color: #e74c3c; /* Red for production */
    --target-color: #10B981; /* Green for target */
    --current-indicator: #F59E0B; /* Yellow for current time indicator */
    --completed-variant: #D1E7DD; /* Light green for completed variants */
    --current-variant: #FFF3CD; /* Light yellow for current variant */
    --upcoming-variant: #F8D7DA; /* Light red for upcoming variants */
    --legend-bg: #f8fafc; /* Background color for legend section */
    --status-met: #D1E7DD; /* Status indicator - met target */
    --status-missed: #FECDD3; /* Status indicator - missed target */
    --status-current: #FEF9C3; /* Status indicator - current hour */
}

/* CSS Reset for more consistent rendering */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
}

body {
    font-family: Arial, Helvetica, sans-serif; /* More readable font for distance viewing */
    background-color: var(--light-color);
    color: var(--primary-color);
    transition: background-color 0.3s ease;
}

.dashboard-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    padding: clamp(0.5rem, 1vw, 1rem);
    transition: all 0.3s ease;
}

/* ===== IMPROVED FULLSCREEN MODE CSS ===== */
.dashboard-container.fullscreen-mode {
    padding: clamp(0.25rem, 0.5vw, 0.5rem);
}

/* ===== HEADER STYLES ===== */
.supervisor-color-banner {
    width: 100%;
    height: clamp(0.5rem, 1vh, 1.25rem);
    border-radius: 3px;
    margin-bottom: clamp(0.15rem, 0.3vh, 0.3rem);
    transition: height 0.3s ease;
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    padding-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    min-height: fit-content;
    flex-shrink: 0;
}

.title-section {
    display: flex;
    align-items: center;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.title {
    font-size: clamp(1.4rem, 2.2vw, 2.8rem); /* Increased font size */
    font-weight: bold;
    color: var(--primary-color);
    white-space: nowrap;
}

.controls-section {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.filter-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.filter-select {
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    border-radius: 5px;
    border: 1px solid var(--secondary-color);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    min-width: clamp(120px, 10vw, 180px);
    background-color: white;
}

.buttons-container {
    display: flex;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    flex-wrap: wrap;
}

.supervisor-select-btn {
    background-color: var(--secondary-color);
    color: white;
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    min-width: clamp(100px, 8vw, 140px);
    white-space: nowrap;
    transition: all 0.2s ease;
}

.supervisor-select-btn:hover {
    background-color: #2563eb;
}

.fullscreen-button {
    background-color: #e2e8f0;
    color: var(--dark-color);
    padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 0.75vw, 0.75rem);
    font-size: clamp(0.85rem, 1.1vw, 1.2rem); /* Increased font size */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s ease;
}

.fullscreen-button:hover {
    background-color: #cbd5e1;
}

.date-time {
    text-align: right;
    white-space: nowrap;
}

.time {
    font-size: clamp(1.2rem, 1.8vw, 2.2rem); /* Increased font size */
    font-weight: bold;
}

/* ===== LEGEND SECTION ===== */
.legend-section {
    width: 100%;
    background-color: var(--legend-bg);
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.75rem, 1.25vw, 1.25rem);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    border-radius: 0.5rem;
    flex-shrink: 0;
}

.legend-container {
    display: flex;
    flex-wrap: wrap;
    gap: clamp(1rem, 3vw, 3rem);
}

.legend-item {
    display: flex;
    align-items: center;
}

.legend-color {
    width: clamp(1.5rem, 2.2vw, 2.5rem); /* Increased size */
    height: clamp(1.5rem, 2.2vw, 2.5rem); /* Increased size */
    margin-right: clamp(0.25rem, 0.5vw, 0.5rem);
    border-radius: 5px;
}

.legend-label {
    font-size: clamp(1rem, 1.4vw, 1.6rem); /* Increased font size */
    font-weight: 700; /* Made bolder */
    white-space: nowrap;
}

.current-hour-info {
    font-size: clamp(1rem, 1.4vw, 1.6rem); /* Increased font size */
    color: var(--secondary-color);
    font-weight: 700; /* Made bolder */
    white-space: nowrap;
    text-align: right;
}

/* ===== CONTENT CONTAINER ===== */
.content {
    display: flex;
    flex-direction: column; /* Changed to column layout */
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

/* Add a new charts-row class */
.charts-row {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.main-content {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex-shrink: 0; /* Don't shrink the top content */
    overflow: visible;
}

/* ===== TOP ROW WITH SUPERVISOR AND METRICS ===== */
.top-row {
    display: flex;
    gap: clamp(0.5rem, 1vw, 1rem);
    width: 100%;
    flex-shrink: 0;
    overflow: visible;
}

/* ===== SUPERVISOR INFO PANEL ===== */
.supervisor-panel {
    flex: 0 0 clamp(250px, 25vw, 450px);
    background-color: var(--supervisor-mvokwe);
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    display: flex;
    flex-direction: column;
}

.supervisor-name {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    color: var(--dark-color);
}

.product-name {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem); /* Increased font size */
    color: var(--dark-color);
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
}

.variant-sequence {
    display: flex;
    align-items: center;
    font-size: clamp(0.9rem, 1.2vw, 1.4rem); /* Increased font size */
    flex-wrap: wrap;
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
    margin-top: auto;
}

.variant-item {
    padding: clamp(0.35rem, 0.75vh, 0.75rem) clamp(0.5rem, 1vw, 1rem);
    border-radius: 8px;
    white-space: nowrap;
    position: relative;
    text-align: center;
    min-width: clamp(60px, 7vw, 100px);
}

.variant-item.completed {
    background-color: var(--completed-variant);
    color: var(--dark-color);
}

.variant-item.current {
    background-color: var(--current-variant);
    color: var(--dark-color);
    font-weight: bold;
}

.variant-item.upcoming {
    background-color: var(--upcoming-variant);
    color: var(--dark-color);
}

.arrow-right {
    margin: 0 clamp(0.1rem, 0.25vw, 0.25rem);
    font-size: clamp(1.1rem, 1.45vw, 1.7rem); /* Increased font size */
    color: var(--dark-color);
}

/* ===== METRICS CARDS ===== */
.metrics-container {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    gap: clamp(0.5rem, 1vw, 1rem);
}

.metric-card {
    flex: 1 1 clamp(150px, 15vw, 300px);
    min-width: clamp(120px, 15vw, 200px);
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.metric-title {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    color: var(--primary-color);
    text-align: center;
}

.metric-value {
    font-size: clamp(1.8rem, 2.8vw, 3.4rem); /* Increased font size */
    font-weight: bold;
    margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    text-align: center;
}

.metric-subvalue {
    font-size: clamp(0.9rem, 1.3vw, 1.6rem); /* Increased font size */
    text-align: center;
}

.current-value {
    color: var(--production-color);
}

.target-value {
    color: var(--target-color);
}

/* ===== CHARTS SECTION ===== */
.charts-container {
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
    position: relative;
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
}

.chart-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Increased font size */
    font-weight: 600;
    margin-bottom: clamp(0.5rem, 1vh, 1rem);
    color: var(--primary-color);
    flex-shrink: 0;
    text-align: center;
}

.chart-area {
    flex: 1;
    position: relative;
    min-height: 0;
    overflow: hidden;
}

.chart {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 1;
    transition: opacity 0.5s ease;
}

.chart.hidden {
    opacity: 0;
    pointer-events: none;
}

.chart-nav {
    display: flex;
    justify-content: center;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-top: clamp(0.5rem, 1vh, 1rem);
}

.chart-nav-dot {
    width: clamp(0.8rem, 1.3vw, 1.2rem); /* Increased size */
    height: clamp(0.8rem, 1.3vw, 1.2rem); /* Increased size */
    border-radius: 50%;
    background-color: #cbd5e1;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
}

.chart-nav-dot.active {
    background-color: var(--secondary-color);
    transform: scale(1.2);
}

/* ===== BATCH INFO SECTION (NEW) ===== */
.batch-info-section {
    flex: 0 0 clamp(375px, 32vw, 650px); /* Increased width for better display of content */
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    max-height: 100%;
}

.batch-info-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem); /* Large font size */
    font-weight: bold;
    margin-bottom: clamp(0.75rem, 1.5vh, 1.5rem);
    color: var(--primary-color);
    text-align: center;
}

.batch-info-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
}

.batch-info-table th {
    background-color: var(--primary-color);
    color: white;
    font-size: clamp(0.9rem, 1.3vw, 1.6rem); /* Increased font size */
    padding: clamp(0.5rem, 1vh, 1rem) clamp(0.25rem, 0.5vw, 0.5rem);
    text-align: left;
    position: sticky;
    top: 0;
}

.batch-info-table td {
    font-size: clamp(0.85rem, 1.2vw, 1.5rem); /* Increased font size */
    padding: clamp(0.4rem, 0.8vh, 0.8rem) clamp(0.25rem, 0.5vw, 0.5rem);
    border-bottom: 1px solid #e2e8f0;
}

.batch-info-table tr:nth-child(even) {
    background-color: #f8fafc;
}

.batch-info-table tr:hover {
    background-color: #e9f5fd;
}

.batch-info-table tr.current {
    background-color: var(--current-variant);
}

.batch-number {
    font-weight: bold;
}

/* ===== FOOTER ===== */
.footer {
    margin-top: clamp(0.25rem, 0.5vh, 0.5rem);
    font-size: clamp(0.85rem, 1.1vw, 1.3rem); /* Increased font size */
    color: var(--dark-color);
    width: 100%;
    flex-shrink: 0;
}

.update-info {
    text-align: left;
}

/* ===== SUPERVISOR SELECTION MODAL ===== */
.supervisor-select-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(2px);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from {opacity: 0}
    to {opacity: 1}
}

.supervisor-select-content {
    position: relative;
    background-color: #fefefe;
    margin: 10vh auto;
    padding: 0;
    border-radius: 8px;
    width: clamp(300px, 80vw, 600px);
    max-height: 80vh;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    animation: slideIn 0.3s ease;
    display: flex;
    flex-direction: column;
}

@keyframes slideIn {
    from {transform: translateY(-50px); opacity: 0}
    to {transform: translateY(0); opacity: 1}
}

.supervisor-select-header {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.supervisor-select-header h3 {
    margin: 0;
    font-size: clamp(1.3rem, 1.7vw, 1.9rem); /* Increased font size */
    color: var(--dark-color);
}

.supervisor-select-close {
    color: #aaa;
    font-size: clamp(1.8rem, 2.5vw, 2.8rem); /* Increased font size */
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
}

.supervisor-select-close:hover {
    color: var(--dark-color);
}

.supervisor-select-body {
    padding: clamp(1rem, 2vw, 2rem);
    overflow-y: auto;
    flex: 1;
}

.supervisor-checkboxes {
    display: flex;
    flex-direction: column;
    gap: clamp(0.5rem, 1vh, 1rem);
}

.supervisor-checkbox-item {
    display: flex;
    align-items: center;
    padding: clamp(0.5rem, 1vh, 1rem);
    border-radius: 6px;
    transition: background-color 0.2s;
}

.supervisor-checkbox-item:hover {
    background-color: #f8fafc;
}

.supervisor-checkbox-item input[type="checkbox"] {
    width: clamp(18px, 1.7vw, 22px); /* Increased size */
    height: clamp(18px, 1.7vw, 22px); /* Increased size */
    margin-right: clamp(0.5rem, 1vw, 1rem);
    cursor: pointer;
}

.supervisor-checkbox-item label {
    font-size: clamp(1.1rem, 1.4vw, 1.6rem); /* Increased font size */
    font-weight: 500;
    cursor: pointer;
    flex: 1;
}

.supervisor-select-footer {
    padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(1rem, 2vw, 2rem);
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: flex-end;
    gap: clamp(0.5rem, 1vw, 1rem);
    flex-shrink: 0;
}

/* ===== RESPONSIVE DESIGN - ADDITIONAL SCREEN SIZE OPTIMIZATIONS ===== */
/* Special optimization for very large screens (TVs) */
@media screen and (min-width: 2000px) {
    .chart-title {
        font-size: clamp(1.4rem, 2vw, 2.4rem);
    }
    
    .legend-label {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
    
    .current-hour-info {
        font-size: clamp(1.2rem, 1.6vw, 1.8rem);
    }
}

/* For smaller screens */
@media screen and (max-width: 1200px) {
    .charts-row {
        flex-direction: column; /* Stack charts and batch info on smaller screens */
    }
    
    .top-row {
        flex-direction: column;
    }
    
    .supervisor-panel {
        flex: 0 0 auto;
        width: 100%;
    }
    
    .metrics-container {
        width: 100%;
    }
    
    .batch-info-section {
        flex: 0 0 auto;
        width: 100%;
        max-height: 300px; /* Limit height on smaller screens */
    }
}

@media screen and (max-width: 768px) {
    .header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .controls-section {
        width: 100%;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .filter-container {
        width: 100%;
    }
    
    .filter-select {
        flex: 1;
    }
    
    .buttons-container {
        width: 100%;
    }
    
    .date-time {
        align-self: flex-end;
        margin-top: clamp(0.5rem, 1vh, 1rem);
    }
}

/* Special handling for landscape orientation on tablets and phones */
@media screen and (max-height: 768px) and (orientation: landscape) {
    .dashboard-container {
        padding: clamp(0.25rem, 0.5vw, 0.5rem);
    }
    
    .header {
        padding-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
    }
    
    .legend-section {
        margin-bottom: clamp(0.25rem, 0.5vh, 0.5rem);
        padding: clamp(0.25rem, 0.5vh, 0.5rem) clamp(0.5rem, 1vw, 1rem);
    }
}

/* ===== NEW STYLES FOR ELLAVI DRAPE UNIFIED VIEW ===== */
.ellavi-unified-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: auto;
    background-color: white;
    border-radius: 12px;
    padding: clamp(0.75rem, 1.5vh, 1.5rem);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.ellavi-unified-title {
    font-size: clamp(1.2rem, 1.7vw, 2rem);
    font-weight: 600;
    margin-bottom: clamp(1rem, 1.5vh, 1.5rem);
    color: var(--primary-color);
    text-align: center;
}

.ellavi-product-row {
    display: flex;
    flex-direction: column;
    margin-bottom: clamp(1rem, 2vh, 2rem);
    padding: clamp(0.75rem, 1vh, 1rem);
    background-color: #f8fafc;
    border-radius: 8px;
}

.ellavi-product-header {
    font-size: clamp(1.1rem, 1.5vw, 1.8rem);
    font-weight: bold;
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    color: var(--primary-color);
}

.ellavi-progress-container {
    display: flex;
    align-items: center;
    gap: clamp(0.5rem, 1vw, 1rem);
    margin-bottom: clamp(0.5rem, 0.75vh, 0.75rem);
    height: 30px;
}

.ellavi-progress-label {
    width: 180px;
    font-size: clamp(0.9rem, 1.2vw, 1.4rem);
    font-weight: 500;
    text-align: right;
}

.ellavi-progress-bar-bg {
    flex: 1;
    height: 100%;
    background-color: #f3f4f6;
    border-radius: 5px;
    position: relative;
    overflow: hidden;
}

.ellavi-progress-bar {
    height: 100%;
    background-color: var(--production-color);
    border-radius: 5px;
}

.ellavi-progress-target {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background-color: var(--target-color);
}

.ellavi-progress-value {
    margin-left: 10px;
    font-size: clamp(0.9rem, 1.2vw, 1.4rem);
    font-weight: 500;
    white-space: nowrap;
}

.ellavi-timeline-container {
    display: flex;
    margin-top: 5px;
    padding-left: 180px;
    height: 40px;
}

.ellavi-hour-marker {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.ellavi-hour-label {
    font-size: clamp(0.7rem, 0.9vw, 1rem);
    color: #64748b;
}

.ellavi-hour-status {
    font-size: clamp(1rem, 1.5vw, 1.8rem);
    font-weight: bold;
}

.ellavi-hour-status.met {
    color: var(--success-color);
}

.ellavi-hour-status.missed {
    color: var(--danger-color);
}

.ellavi-hour-status.current {
    color: var(--warning-color);
}

.ellavi-hour-status.future {
    color: #94a3b8;
}
    </style>
</head>

    <body>
    <div class="dashboard-container">
        <!-- Supervisor color banner -->
        <div class="supervisor-color-banner"></div>
        
        <!-- Header Section -->
        <div class="header">
            <div class="title-section">
                <div class="title">Sinapi Secondary Production Dashboard</div>
            </div>
            
            <div class="controls-section">
                <div class="filter-container">
                    <select id="filter-type-select" class="filter-select">
                        <option value="supervisor">Filter by Supervisor</option>
                        <option value="product">Filter by Product</option>
                        <option value="variant">Filter by Variant</option>
                    </select>
                    <select id="filter-value-select" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                
                <div class="buttons-container">
                    <button id="supervisor-select-btn" class="supervisor-select-btn">
                        Select Supervisors
                    </button>
                    <button id="fullscreen-button" class="fullscreen-button">Fullscreen</button>
                </div>
            </div>
            
            <div class="date-time">
                <div class="time" id="current-time">Loading...</div>
            </div>
        </div>
        
        <!-- Legend Section -->
        <div class="legend-section">
            <div class="legend-container">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--production-color);"></div>
                    <div class="legend-label">PRODUCTION</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--target-color);"></div>
                    <div class="legend-label">TARGET</div>
                </div>
            </div>
            <div class="current-hour-info" id="current-hour-info">CURRENT HOUR: --:-- (-- MIN LEFT)</div>
        </div>
        
        <!-- Content wrapper for main and batch info -->
<div class="content">
    <!-- Main content area (top row section only) -->
    <div class="main-content">
        <!-- Top Row: Supervisor + Metrics -->
        <div class="top-row">
            <!-- Supervisor Panel -->
            <div class="supervisor-panel">
                <div class="supervisor-name" id="supervisor-name">SUPERVISOR: Loading...</div>
                <div class="product-name" id="product-name">PRODUCT: Loading...</div>
                
                <div class="variant-sequence" id="variant-sequence">
                    <div class="loading">Loading variants...</div>
                </div>
            </div>
            
            <!-- Metrics Container -->
            <div class="metrics-container">
                <!-- Units (renamed from Progress) -->
                <div class="metric-card">
                    <div class="metric-title">UNITS</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-units">0</span>/<span class="target-value" id="target-units">0</span>
                    </div>
                    <div class="metric-subvalue" id="progress-percentage">0%</div>
                </div>
                
                <!-- Boxes - NEXT TO UNITS -->
                <div class="metric-card">
                    <div class="metric-title">BOXES</div>
                    <div class="metric-value">
                        <span class="current-value" id="current-boxes">0</span>/<span class="target-value" id="target-boxes">0</span>
                    </div>
                    <div class="metric-subvalue">completed</div>
                </div>
                
                <!-- Cycle Time -->
                <div class="metric-card">
                    <div class="metric-title">CYCLE TIME</div>
                    <div class="metric-value">
                        <span class="current-value" id="actual-cycle-time">0</span>/<span class="target-value" id="target-cycle-time">0</span>
                    </div>
                    <div class="metric-subvalue">seconds</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Charts Row: Charts + Batch Info -->
    <div class="charts-row">
        <!-- Charts Container - Now moved outside main-content -->
        <div class="charts-container">
            <div class="chart-title" id="chart-title">Production Progress</div>
            <div class="chart-area">
                <div class="chart" id="cumulative-chart"></div>
                <div class="chart hidden" id="hourly-chart"></div>
                <div class="chart hidden" id="ellavi-unified-view"></div>
            </div>
            <div class="chart-nav">
                <div class="chart-nav-dot active" data-chart="cumulative"></div>
                <div class="chart-nav-dot" data-chart="hourly"></div>
            </div>
        </div>
        
        <!-- Batch Information Panel - Now in the charts row -->
        <div class="batch-info-section">
    <div class="batch-info-title">BATCH INFORMATION</div>
    <table class="batch-info-table" id="batch-info-table">
        <thead id="batch-info-thead">
            <!-- Table headers will be dynamically generated -->
        </thead>
        <tbody id="batch-info-tbody">
            <!-- Batch information will be populated dynamically -->
            <tr>
                <td colspan="5">Loading batch information...</td>
            </tr>
        </tbody>
    </table>
</div>
    </div>
</div>
        
        <!-- Footer -->
        <div class="footer">
            <div class="update-info" id="last-update">Last updated: Never</div>
        </div>
        
        <!-- Supervisor Selection Modal -->
        <div id="supervisor-select-modal" class="supervisor-select-modal">
            <div class="supervisor-select-content">
                <div class="supervisor-select-header">
                    <h3>Select Supervisors to Display</h3>
                    <span class="supervisor-select-close">&times;</span>
                </div>
                <div class="supervisor-select-body">
                    <div id="supervisor-checkboxes" class="supervisor-checkboxes">
                        <!-- Checkboxes will be added dynamically -->
                    </div>
                </div>
                <div class="supervisor-select-footer">
                    <button id="select-all-supervisors" class="supervisor-select-btn secondary">Select All</button>
                    <button id="deselect-all-supervisors" class="supervisor-select-btn secondary">Deselect All</button>
                    <button id="apply-supervisor-selection" class="supervisor-select-btn primary">Apply Selection</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://opssinapi.github.io/production-dashboard/data.json';
        const UPDATE_INTERVAL = 30 * 1000; // 30 seconds update interval
        const CYCLE_INTERVAL = 20000; // 20 seconds cycle interval

        // State variables
        let productionData = { variants: [], supervisors: [] };
        let selectedFilterType = 'supervisor';
        let selectedFilterValue = 'all';
        let selectedHour = 'current';
        let lastUpdateTime = null;
        let isLoading = true;
        let countdownInterval = null;
        let commonChartPadding = { top: 20, right: 30, bottom: 50, left: 70 };
        let isFullscreen = false;
        let cycleInterval = null; // For cycling between supervisors
        let cycleIndex = 0; // To track the current supervisor index
        
        // Variables for product-supervisor grouping
        let productSupervisorGroups = {};
        let currentProduct = null;
        let currentSupervisor = null;
        let currentProductVariants = [];
        let currentVariantKey = null;
        let selectedSupervisors = []; // Array to hold selected supervisors    
        let supervisorFilterActive = false; // Track if supervisor filter is active
        
        // Chart rotation variables
        let chartRotationInterval = null;
        let currentChartIndex = 0;
        const CHART_ROTATION_INTERVAL = 10000; // 10 seconds rotation interval

        // Responsive dimensions
        let viewportWidth, viewportHeight, chartWidth, chartHeight;

        // Dashboard element references
        let dashboardContainer, supervisorPanel, chartsRow;
        let fullscreenButton;

        // NEW: Function to detect Ellavi Drape product family
        function isEllaviDrapeProductFamily(groups) {
            // Check if we have multiple Ellavi Drape Lines
            const ellaviDrapeLines = Object.values(groups).filter(group => 
                group.product && group.product.includes("Ellavi Drape Line"));
            
            // Return true if we have 2 or more Ellavi Drape Lines
            return ellaviDrapeLines.length >= 2;
        }
        
        // NEW: Get Ellavi Drape data for unified view
        function getEllaviDrapeData(groups) {
            const ellaviDrapeLines = Object.values(groups).filter(group => 
                group.product && group.product.includes("Ellavi Drape Line"));
            
            if (ellaviDrapeLines.length === 0) return null;
            
            // Sort lines by line number
            ellaviDrapeLines.sort((a, b) => {
                const lineNumberA = parseInt(a.product.match(/\d+/)?.[0] || "0");
                const lineNumberB = parseInt(b.product.match(/\d+/)?.[0] || "0");
                return lineNumberA - lineNumberB;
            });
            
            return {
                supervisor: ellaviDrapeLines[0].supervisor,
                lines: ellaviDrapeLines
            };
        }
        
        // NEW: Render the unified Ellavi Drape view
        function renderEllaviDrapeUnifiedView(ellaviData) {
            // Hide standard charts and show unified view
            document.getElementById('cumulative-chart').classList.add('hidden');
            document.getElementById('hourly-chart').classList.add('hidden');
            
            const unifiedViewContainer = document.getElementById('ellavi-unified-view');
            unifiedViewContainer.classList.remove('hidden');
            unifiedViewContainer.innerHTML = '';
            
            // Update chart title
            document.getElementById('chart-title').textContent = 'ELLAVI DRAPE LINES OVERVIEW';
            
            // Create unified view container
            const container = document.createElement('div');
            container.className = 'ellavi-unified-container';
            
            // Set supervisor info and metrics
            document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${ellaviData.supervisor}`;
            document.getElementById('product-name').textContent = 'ELLAVI DRAPE LINES';
            
            // Hide variant sequence - not needed for unified view
            document.getElementById('variant-sequence').style.display = 'none';
            
            // Calculate aggregated metrics
            let totalProduction = 0;
            let totalTarget = 0;
            let totalBoxesProduction = 0;
            let totalBoxesTarget = 0;
            let weightedCycleTime = 0;
            let cycleTimeWeightTotal = 0;
            
            ellaviData.lines.forEach(line => {
                const variants = line.variants;
                
                variants.forEach(variant => {
                    const supervisorVariant = line.supervisorData.variants[variant.variant];
                    if (supervisorVariant) {
                        const currentTotal = supervisorVariant.currentTotal || 0;
                        const dailyTarget = supervisorVariant.dailyTarget || 0;
                        
                        totalProduction += currentTotal;
                        totalTarget += dailyTarget;
                        
                        // Add boxes
                        if (variant.dailyBoxTarget && variant.currentBoxTotal) {
                            totalBoxesTarget += variant.dailyBoxTarget;
                            totalBoxesProduction += variant.currentBoxTotal;
                        }
                        
                        // Add weighted cycle time
                        if (variant.cycleTime && currentTotal > 0) {
                            weightedCycleTime += variant.cycleTime * currentTotal;
                            cycleTimeWeightTotal += currentTotal;
                        }
                    }
                });
            });
            
            // Update metrics
            document.getElementById('current-units').textContent = totalProduction;
            document.getElementById('target-units').textContent = totalTarget;
            document.getElementById('progress-percentage').textContent = 
                `${totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0}%`;
            
            document.getElementById('current-boxes').textContent = totalBoxesProduction;
            document.getElementById('target-boxes').textContent = totalBoxesTarget;
            
            const avgCycleTime = cycleTimeWeightTotal > 0 ? 
                Math.round(weightedCycleTime / cycleTimeWeightTotal) : 0;
            
            document.getElementById('actual-cycle-time').textContent = avgCycleTime || "N/A";
            document.getElementById('target-cycle-time').textContent = avgCycleTime || "N/A";
            
            // Get hours data for timeline
            const hourLabels = ['10:57', '11:30', '12:30', '13:30', '14:30', '15:30', '16:30'];
            
            // Create chart content for each line
            ellaviData.lines.forEach(line => {
                // Create product row
                const productRow = document.createElement('div');
                productRow.className = 'ellavi-product-row';
                
                // Product header
                const productHeader = document.createElement('div');
                productHeader.className = 'ellavi-product-header';
                productHeader.textContent = line.product;
                productRow.appendChild(productHeader);
                
                // Get production and target data for this line
                let lineProduction = 0;
                let lineTarget = 0;
                
                line.variants.forEach(variant => {
                    const supervisorVariant = line.supervisorData.variants[variant.variant];
                    if (supervisorVariant) {
                        lineProduction += supervisorVariant.currentTotal || 0;
                        lineTarget += supervisorVariant.dailyTarget || 0;
                    }
                });
                
                // Progress container
                const progressContainer = document.createElement('div');
                progressContainer.className = 'ellavi-progress-container';
                
                // Progress label
                const progressLabel = document.createElement('div');
                progressLabel.className = 'ellavi-progress-label';
                progressLabel.textContent = 'Production:';
                progressContainer.appendChild(progressLabel);
                
                // Progress bar background
                const progressBarBg = document.createElement('div');
                progressBarBg.className = 'ellavi-progress-bar-bg';
                
                // Progress bar
                const progressBar = document.createElement('div');
                progressBar.className = 'ellavi-progress-bar';
                const progressPercent = lineTarget > 0 ? (lineProduction / lineTarget) * 100 : 0;
                progressBar.style.width = `${Math.min(100, progressPercent)}%`;
                progressBarBg.appendChild(progressBar);
                
                // Target line
                const targetLine = document.createElement('div');
                targetLine.className = 'ellavi-progress-target';
                progressBarBg.appendChild(targetLine);
                
                progressContainer.appendChild(progressBarBg);
                
                // Progress value
                const progressValue = document.createElement('div');
                progressValue.className = 'ellavi-progress-value';
                progressValue.textContent = `${lineProduction}/${lineTarget} (${Math.round(progressPercent)}%)`;
                progressContainer.appendChild(progressValue);
                
                productRow.appendChild(progressContainer);
                
                // Timeline container
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'ellavi-timeline-container';
                
                // Generate timeline
                hourLabels.forEach((hour, index) => {
                    const hourMarker = document.createElement('div');
                    hourMarker.className = 'ellavi-hour-marker';
                    hourMarker.style.flex = '1';
                    
                    // Hour label
                    const hourLabel = document.createElement('div');
                    hourLabel.className = 'ellavi-hour-label';
                    hourLabel.textContent = hour;
                    hourMarker.appendChild(hourLabel);
                    
                    // Hour status indicator
                    const hourStatus = document.createElement('div');
                    hourStatus.className = 'ellavi-hour-status';
                    
                    // Get random status for demonstration - in real implementation, use actual data
                    let status;
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    const currentTimeInMinutes = currentHour * 60 + currentMinute;
                    
                    const hourParts = hour.split(':').map(Number);
                    const hourTimeInMinutes = hourParts[0] * 60 + (hourParts[1] || 0);
                    
                    // Time periods are past/current/future
                    if (hourTimeInMinutes + 30 < currentTimeInMinutes) {
                        // This is a past hour - randomly determine if target was met
                        // In a real implementation, you would get this from actual data
                        const targetMet = Math.random() > 0.4; // 60% chance of meeting target for demo
                        status = targetMet ? 'met' : 'missed';
                        hourStatus.textContent = targetMet ? '✓' : '✗';
                    } else if (Math.abs(hourTimeInMinutes - currentTimeInMinutes) < 30) {
                        // Current hour
                        status = 'current';
                        hourStatus.textContent = '●';
                    } else {
                        // Future hour
                        status = 'future';
                        hourStatus.textContent = '-';
                    }
                    
                    hourStatus.classList.add(status);
                    hourMarker.appendChild(hourStatus);
                    
                    timelineContainer.appendChild(hourMarker);
                });
                
                productRow.appendChild(timelineContainer);
                container.appendChild(productRow);
            });
            
            unifiedViewContainer.appendChild(container);
            
            // Update batch info table
            updateBatchInfoTableForEllaviUnified(ellaviData.lines);
        }
        
        // NEW: Update batch info table for Ellavi unified view
        function updateBatchInfoTableForEllaviUnified(ellaviLines) {
            const batchInfoTableBody = document.getElementById('batch-info-tbody');
            const batchInfoTableHead = document.getElementById('batch-info-thead');
            
            if (!batchInfoTableBody || !batchInfoTableHead) return;
            
            // Clear existing content
            batchInfoTableBody.innerHTML = '';
            batchInfoTableHead.innerHTML = '';
            
            // If no original data, show message
            if (!productionData.originalData || !productionData.originalData.production) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
                return;
            }
            
            // Get current time to determine current variant
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Create the table header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `
                <th>Product</th>
                <th>Variant</th>
                <th>Batch</th>
                <th>Units</th>
                <th>Boxes</th>
            `;
            batchInfoTableHead.appendChild(headerRow);
            
            // Create a Map to store the unique batches by ID
            const uniqueBatchesMap = new Map();
            
            // Process each Ellavi line's variants
            ellaviLines.forEach(line => {
                // Get the product name
                const productName = line.product;
                
                // Add product header row
                const productRow = document.createElement('tr');
                productRow.style.backgroundColor = '#edf2f7';
                
                const productCell = document.createElement('td');
                productCell.colSpan = 5;
                productCell.style.fontWeight = 'bold';
                productCell.textContent = productName;
                
                productRow.appendChild(productCell);
                batchInfoTableBody.appendChild(productRow);
                
                // Get the supervisor's variants
                const supervisorName = line.supervisor;
                const supervisor = productionData.supervisors.find(s => s.name === supervisorName);
                
                if (!supervisor || !supervisor.variants) return;
                
                // For each variant assigned to this supervisor and this product
                const productVariants = line.variants;
                productVariants.forEach(variant => {
                    const variantKey = variant.variant;
                    
                    // Find the original production data
                    const productionItem = productionData.originalData.production.find(p => p.id === variantKey);
                    
                    if (!productionItem || !productionItem.batches) return;
                    
                    // Get variant details
                    const variantName = productionItem.variant?.name || variantKey.split('-').pop();
                    
                    // Check if this variant is currently active
                    const supervisorVariant = supervisor.variants[variantKey];
                    let isCurrentVariant = false;
                    
                    if (supervisorVariant) {
                        const startTimeStr = supervisorVariant.variantStartTime || productionItem.supervisors[0]?.startTime;
                        const endTimeStr = supervisorVariant.variantEndTime || productionItem.supervisors[0]?.endTime;
                        
                        if (startTimeStr && endTimeStr) {
                            const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                            const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                            
                            const startTimeMinutes = startHour * 60 + startMinute;
                            const endTimeMinutes = endHour * 60 + endMinute;
                            
                            // Check if current time is within this variant's window
                            isCurrentVariant = (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
                        }
                    }
                    
                    // Process each batch
                    productionItem.batches.forEach(batch => {
                        // Create batch row
                        const row = document.createElement('tr');
                        if (isCurrentVariant) {
                            row.className = 'current';
                        }
                        
                        // Product cell
                        const productCell = document.createElement('td');
                        productCell.style.opacity = '0.5'; // Make less prominent
                        productCell.textContent = productName;
                        row.appendChild(productCell);
                        
                        // Variant cell
                        const variantCell = document.createElement('td');
                        variantCell.textContent = variantName;
                        row.appendChild(variantCell);
                        
                        // Batch ID cell
                        const batchCell = document.createElement('td');
                        batchCell.className = 'batch-number';
                        batchCell.textContent = batch.id;
                        row.appendChild(batchCell);
                        
                        // Units cell
                        const unitsCell = document.createElement('td');
                        unitsCell.textContent = batch.quantity;
                        row.appendChild(unitsCell);
                        
                        // Boxes/Bags cell
                        const containerCell = document.createElement('td');
                        containerCell.textContent = batch.boxes;
                        row.appendChild(containerCell);
                        
                        batchInfoTableBody.appendChild(row);
                    });
                });
            });
        }

        // Initialize dashboard
        function initDashboard() {
            // Cache DOM references for better performance
            dashboardContainer = document.querySelector('.dashboard-container');
            supervisorPanel = document.querySelector('.supervisor-panel');
            fullscreenButton = document.getElementById('fullscreen-button');

            // Set up initial state
            updateDateTime();
            updateViewportDimensions();
            setInterval(updateDateTime, 1000);

            // Event listeners
            document.getElementById('filter-type-select').addEventListener('change', function() {
                selectedFilterType = this.value;
                updateFilterValueDropdown();
            });

            document.getElementById('filter-value-select').addEventListener('change', function() {
                selectedFilterValue = this.value;
                updateDashboard();
            });

            // Initialize supervisor selection
            initSupervisorSelection();
            
            // Chart rotation navigation setup
            setupChartNavigation();
            
            // Initialize data
            fetchProductionData();
            setInterval(fetchProductionData, UPDATE_INTERVAL);

            // Fullscreen event listeners
            fullscreenButton.addEventListener('click', toggleFullscreen);
            window.addEventListener('resize', handleResize);
            
            // Fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        // Setup chart navigation
        function setupChartNavigation() {
            const navDots = document.querySelectorAll('.chart-nav-dot');
            navDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    const chartType = this.getAttribute('data-chart');
                    showChart(chartType);
                    
                    // Reset rotation interval when manually clicked
                    if (chartRotationInterval) {
                        clearInterval(chartRotationInterval);
                        startChartRotation();
                    }
                });
            });
            
            // Start automatic rotation
            startChartRotation();
        }
        
        // Start chart rotation
        function startChartRotation() {
            if (chartRotationInterval) {
                clearInterval(chartRotationInterval);
            }
            
            chartRotationInterval = setInterval(() => {
                currentChartIndex = (currentChartIndex + 1) % 2;
                const chartType = currentChartIndex === 0 ? 'cumulative' : 'hourly';
                showChart(chartType);
            }, CHART_ROTATION_INTERVAL);
        }
        
       // Show specific chart
        function showChart(chartType) {
            const cumulativeChart = document.getElementById('cumulative-chart');
            const hourlyChart = document.getElementById('hourly-chart');
            const unifiedView = document.getElementById('ellavi-unified-view');
            const chartTitle = document.getElementById('chart-title');
            const navDots = document.querySelectorAll('.chart-nav-dot');
            
            // If we're in Ellavi unified view mode, don't switch charts
            if (!unifiedView.classList.contains('hidden')) {
                return;
            }
            
            // Update nav dots
            navDots.forEach(dot => {
                if (dot.getAttribute('data-chart') === chartType) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
            
            if (chartType === 'cumulative') {
                currentChartIndex = 0;
                cumulativeChart.classList.remove('hidden');
                hourlyChart.classList.add('hidden');
                unifiedView.classList.add('hidden');
                chartTitle.textContent = "TODAY'S PRODUCTION PROGRESS";
            } else {
                currentChartIndex = 1;
                cumulativeChart.classList.add('hidden');
                hourlyChart.classList.remove('hidden');
                unifiedView.classList.add('hidden');
                
                // Get current hour for hourly chart title
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const displayHour = currentMinute < 30 ? currentHour : currentHour + 1;
                const hourStr = `${displayHour.toString().padStart(2, '0')}:30`;
                
                chartTitle.textContent = `CURRENT HOUR: ${hourStr} PRODUCTION`;
            }
        }

        // Function to update the dashboard
        function updateDashboard() {
            // Filter groups based on selection and selected supervisors
            let filteredGroups = {};
            
            // Start with selected filter type/value
            if (selectedFilterValue === 'all') {
                // When "all" is selected, still respect supervisor selection
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'supervisor') {
                // When filtering by specific supervisor, also check if it's in selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].supervisor === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'product') {
                // Filter by product but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    if (productSupervisorGroups[key].product === selectedFilterValue &&
                        selectedSupervisors.includes(productSupervisorGroups[key].supervisor)) {
                        filteredGroups[key] = productSupervisorGroups[key];
                    }
                });
            } else if (selectedFilterType === 'variant') {
                // Filter by variant but only for selected supervisors
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    if (group.variants.some(v => v.variant === selectedFilterValue) &&
                        selectedSupervisors.includes(group.supervisor)) {
                        filteredGroups[key] = group;
                    }
                });
            }
            
            // If no groups after filtering, show error and return
            if (Object.keys(filteredGroups).length === 0) {
                showLoadingOrError('No data available for this filter or selected supervisors.');
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
                return;
            }
            
            // NEW: Check if we have multiple Ellavi Drape Lines and should show the unified view
            if (isEllaviDrapeProductFamily(filteredGroups)) {
                const ellaviData = getEllaviDrapeData(filteredGroups);
                if (ellaviData) {
                    // Clear existing cycling
                    if (cycleInterval) clearInterval(cycleInterval);
                    cycleInterval = null;
                    
                    // Render unified view for Ellavi Drape lines
                    renderEllaviDrapeUnifiedView(ellaviData);
                    return;
                }
            }
            
            // For other products, use the original cycling logic
            // Multiple groups - setup cycling between supervisors
            const groupKeys = Object.keys(filteredGroups);
            if (groupKeys.length > 1) {
                // Clear existing interval
                if (cycleInterval) clearInterval(cycleInterval);
                
                // Set cycling logic
                cycleIndex = 0;
                cycleInterval = setInterval(() => {
                    cycleIndex = (cycleIndex + 1) % groupKeys.length;
                    displayGroup(filteredGroups[groupKeys[cycleIndex]]);
                }, CYCLE_INTERVAL);
            } else {
                // Single group - clear cycling
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
            }
            
            // Make sure any Ellavi unified view is hidden
            document.getElementById('ellavi-unified-view').classList.add('hidden');
            
            // Display the first group initially
            displayGroup(filteredGroups[groupKeys[0]]);
            
            // Update batch information table for all selected supervisors
            updateBatchInfoTable(filteredGroups);
        }

        // Function to update viewport dimensions
        function updateViewportDimensions() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;
        }

        // Improved resize handler
        function handleResize() {
            updateViewportDimensions();
            
            // Only redraw if the change is significant
            if (Math.abs(window.innerWidth - viewportWidth) > 20 || 
                Math.abs(window.innerHeight - viewportHeight) > 20) {
                
                // Debounce the update for better performance
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(function() {
                    redrawDashboard();
                }, 250);
            }
        }

        // Redraw dashboard after layout changes
        function redrawDashboard() {
            // Force layout recalculation
            dashboardContainer.style.display = 'none';
            void dashboardContainer.offsetHeight; // Force reflow
            dashboardContainer.style.display = 'flex';
            
            // Update dashboard content
            updateDashboard();
        }

        // Completely redesigned fullscreen handling
        function toggleFullscreen() {
            if (!document.fullscreenElement && 
                !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && 
                !document.msFullscreenElement) {
                
                // Request fullscreen - try the standard way first
                try {
                    // First mark as fullscreen in our UI (before actual fullscreen request)
                    dashboardContainer.classList.add('fullscreen-mode');
                    isFullscreen = true;
                    fullscreenButton.textContent = 'Exit Fullscreen';
                    
                    // Then request actual browser fullscreen
                    if (dashboardContainer.requestFullscreen) {
                        dashboardContainer.requestFullscreen();
                    } else if (dashboardContainer.msRequestFullscreen) {
                        dashboardContainer.msRequestFullscreen();
                    } else if (dashboardContainer.mozRequestFullScreen) {
                        dashboardContainer.mozRequestFullScreen();
                    } else if (dashboardContainer.webkitRequestFullscreen) {
                        // Safari/Chrome specific handling
                        dashboardContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                    } else {
                        // Fallback for browsers without fullscreen API
                        simulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Fullscreen API error:', error);
                    // Fallback to simulated fullscreen
                    simulatedFullscreen();
                }
            } else {
                try {
                    // Exit browser fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else {
                        // Manual exit if no API support
                        exitSimulatedFullscreen();
                    }
                } catch (error) {
                    console.error('Exiting fullscreen error:', error);
                    // Fallback
                    exitSimulatedFullscreen();
                }
            }
        }

        // Improved fullscreen change handler
        function handleFullscreenChange() {
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && 
                !document.msFullscreenElement) {
                
                // Only if we're currently in our fullscreen mode
                if (isFullscreen) {
                    exitFullscreenMode();
                }
            } else {
                // Browser entered fullscreen
                enterFullscreenMode();
            }
        }

        // Enter fullscreen mode - separated function for clarity
        function enterFullscreenMode() {
            if (!isFullscreen) {
                dashboardContainer.classList.add('fullscreen-mode');
                isFullscreen = true;
                fullscreenButton.textContent = 'Exit Fullscreen';
                
                // Force layout recalculation before chart updates
                setTimeout(function() {
                    updateViewportDimensions();
                    updateDashboard();
                }, 100);
            }
        }

        // Exit fullscreen mode - separated function
        function exitFullscreenMode() {
            dashboardContainer.classList.remove('fullscreen-mode');
            dashboardContainer.classList.remove('simulated-fullscreen');
            isFullscreen = false;
            fullscreenButton.textContent = 'Fullscreen';
            
            // Reset any inline styles from simulated fullscreen
            dashboardContainer.style.position = '';
            dashboardContainer.style.top = '';
            dashboardContainer.style.left = '';
            dashboardContainer.style.width = '';
            dashboardContainer.style.height = '';
            dashboardContainer.style.zIndex = '';
            document.body.style.overflow = '';
            
            // Force layout recalculation before chart updates
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        // Simulated fullscreen (fallback)
        function simulatedFullscreen() {
            dashboardContainer.classList.add('fullscreen-mode');
            dashboardContainer.classList.add('simulated-fullscreen');
            isFullscreen = true;
            fullscreenButton.textContent = 'Exit Fullscreen';
            
            // Apply styles directly for better fallback compatibility
            dashboardContainer.style.position = 'fixed';
            dashboardContainer.style.top = '0';
            dashboardContainer.style.left = '0';
            dashboardContainer.style.width = '100vw';
            dashboardContainer.style.height = '100vh';
            dashboardContainer.style.zIndex = '9999';
            document.body.style.overflow = 'hidden';
            
            // Force layout recalculation before chart updates
            setTimeout(function() {
                updateViewportDimensions();
                updateDashboard();
            }, 100);
        }

        // Exit simulated fullscreen
        function exitSimulatedFullscreen() {
            exitFullscreenMode();
        }

        // Function to initialize the supervisor selection UI
        function initSupervisorSelection() {
            const selectBtn = document.getElementById('supervisor-select-btn');
            const modal = document.getElementById('supervisor-select-modal');
            const closeBtn = document.querySelector('.supervisor-select-close');
            const applyBtn = document.getElementById('apply-supervisor-selection');
            const selectAllBtn = document.getElementById('select-all-supervisors');
            const deselectAllBtn = document.getElementById('deselect-all-supervisors');
            
            // Open modal when button is clicked
            selectBtn.addEventListener('click', function() {
                updateSupervisorCheckboxes();
                modal.style.display = 'block';
            });
            
            // Close modal when X is clicked
            closeBtn.addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            // Close modal when clicking outside of it
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // Apply selection and close modal
            applyBtn.addEventListener('click', function() {
                applySupervisorSelection();
                modal.style.display = 'none';
            });
            
            // Select all supervisors
            selectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            });
            
            // Deselect all supervisors
            deselectAllBtn.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('.supervisor-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            });
            
            // Initialize with all supervisors selected
            if (productionData && productionData.supervisors) {
                selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
            }
        }

        // Function to update the supervisor checkboxes
        function updateSupervisorCheckboxes() {
            const checkboxContainer = document.getElementById('supervisor-checkboxes');
            checkboxContainer.innerHTML = '';
            
            if (!productionData || !productionData.supervisors || productionData.supervisors.length === 0) {
                checkboxContainer.innerHTML = '<p>No supervisors available</p>';
                return;
            }
            
            // Create a checkbox for each supervisor
            productionData.supervisors.forEach(supervisor => {
                const item = document.createElement('div');
                item.className = 'supervisor-checkbox-item';
                
                // Create color indicator
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = getSupervisorColor(supervisor.name);
                colorDiv.style.width = '16px';
                colorDiv.style.height = '16px';
                item.appendChild(colorDiv);
                
                // Create checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'supervisor-checkbox';
                checkbox.id = `supervisor-${supervisor.name.toLowerCase().replace(/\s+/g, '-')}`;
                checkbox.value = supervisor.name;
                checkbox.checked = selectedSupervisors.includes(supervisor.name);
                
                // Create label
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = supervisor.name;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                checkboxContainer.appendChild(item);
            });
        }

        // Function to apply supervisor selection
        function applySupervisorSelection() {
            const checkboxes = document.querySelectorAll('.supervisor-checkbox');
            selectedSupervisors = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedSupervisors.push(checkbox.value);
                }
            });
            
            // Store selection in localStorage for persistence
            localStorage.setItem('selectedSupervisors', JSON.stringify(selectedSupervisors));
            
            // Update the selection button style based on whether filtering is active
            supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
            const selectBtn = document.getElementById('supervisor-select-btn');
            
            if (supervisorFilterActive) {
                selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                selectBtn.classList.add('filtered');
            } else {
                selectBtn.textContent = 'Select Supervisors';
                selectBtn.classList.remove('filtered');
            }
            
            // Update the dashboard with the new selection
            updateDashboard();
        }

        // Function to get the supervisor color
        function getSupervisorColor(supervisorName) {
            const colorMap = {
                'Luthando': 'var(--supervisor-luthando)',
                'Apelele': 'var(--supervisor-apelele)',
                'Siyabonga': 'var(--supervisor-siyabonga)',
                'Nosi': 'var(--supervisor-nosi)',
                'Mvokwe': 'var(--supervisor-mvokwe)',
                'Michaela': 'var(--supervisor-michaela)'
            };
            
            return colorMap[supervisorName] || '#e2e8f0'; // Default color if not found
        }

        // Function to load selected supervisors from localStorage
        function loadSelectedSupervisors() {
            const stored = localStorage.getItem('selectedSupervisors');
            if (stored) {
                try {
                    selectedSupervisors = JSON.parse(stored);
                    
                    // Validate against current supervisors
                    if (productionData && productionData.supervisors) {
                        const validSupervisors = productionData.supervisors.map(s => s.name);
                        selectedSupervisors = selectedSupervisors.filter(s => validSupervisors.includes(s));
                        
                        // If none valid, select all
                        if (selectedSupervisors.length === 0) {
                            selectedSupervisors = validSupervisors;
                        }
                    }
                    
                    // Update UI
                    supervisorFilterActive = selectedSupervisors.length < productionData.supervisors.length;
                    const selectBtn = document.getElementById('supervisor-select-btn');
                    
                    if (supervisorFilterActive) {
                        selectBtn.textContent = `Supervisors (${selectedSupervisors.length}/${productionData.supervisors.length})`;
                        selectBtn.classList.add('filtered');
                    }
                } catch (e) {
                    console.error('Error parsing stored supervisors:', e);
                    if (productionData && productionData.supervisors) {
                        selectedSupervisors = productionData.supervisors.map(s => s.name);
                    }
                }
            }
        }

        // Function to fetch production data
        async function fetchProductionData() {
            try {
                const cacheBuster = '?_=' + new Date().getTime();
                const response = await fetch(DATA_URL + cacheBuster);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                // Check if data has the expected structure
                if (!data) {
                    throw new Error('Empty data received from data.json');
                }
                
                // Transform data regardless of structure
                const transformedData = transformDataFormat(data);
                
                // Validate transformed data has the required structure for the dashboard
                if (!transformedData.variants || !Array.isArray(transformedData.variants) || 
                    !transformedData.supervisors || !Array.isArray(transformedData.supervisors)) {
                    throw new Error('Failed to transform data into the required format');
                }
                
                if (!lastUpdateTime || lastUpdateTime !== transformedData.timestamp) {
                    productionData = transformedData;
                    lastUpdateTime = transformedData.timestamp;
                    
                    // Store the original data for batch information
                    productionData.originalData = data;
                    
                    // Update only the footer timestamp
                    document.getElementById('last-update').textContent = 'Last updated: ' + transformedData.timestamp;
                    
                    // Process product-supervisor groups from the transformed data
                    processProductSupervisorGroups();
                    
                    // Load saved supervisor selections or initialize all selected
                    if (selectedSupervisors.length === 0) {
                        selectedSupervisors = productionData.supervisors.map(supervisor => supervisor.name);
                        loadSelectedSupervisors(); // Load any saved preferences
                    }
                    
                    updateFilterValueDropdown();
                    updateDashboard();
                }
                
                isLoading = false;
            } catch (error) {
                console.error(`Fetch failed:`, error);
                isLoading = false;
                showLoadingOrError(`Failed to load data: ${error.message}`);
            }
        }

        // Function to transform data format
        function transformDataFormat(newData) {
            // This is the existing function, no changes needed
            const transformedData = {
                variants: [],
                supervisors: [],
                timestamp: newData.metadata.timestamp || new Date().toISOString()
            };
            
            // Check which structure we're working with and handle accordingly
            if (newData.production && Array.isArray(newData.production)) {
                // New structure with production array and summary
                
                // Transform production items to variants
                newData.production.forEach(item => {
                    const transformedVariant = {
                        variant: item.id,
                        "Product Name": item.variant.fullName || `${item.product.name} ${item.variant.name}`,
                        cycleTime: item.variant.cycleTime,
                        actualCycleTime: item.variant.actualCycleTime,
                        "Start Time": item.shiftId === "overtime" ? "07:30" : "07:30",
                        "End Time": item.shiftId === "overtime" ? "18:30" : "16:30",
                        dailyBoxTarget: item.targets.boxes,
                        currentBoxTotal: item.actual.boxes,
                        hourlyTargets: [],
                        hourlyProduction: []
                    };
                    
                    // Add hourly targets and production data
                    if (item.timeline && Array.isArray(item.timeline)) {
                        item.timeline.forEach(hour => {
                            // Add hourly target
                            transformedVariant.hourlyTargets.push({
                                hour: hour.hour,
                                target: hour.target
                            });
                            
                            // Add hourly production
                            transformedVariant.hourlyProduction.push({
                                hour: hour.hour,
                                production: hour.actual
                            });
                        });
                    }
                    
                    transformedData.variants.push(transformedVariant);
                });
                
                // Process supervisors from the summary section
                if (newData.summary && newData.summary.supervisors && Array.isArray(newData.summary.supervisors)) {
                    newData.summary.supervisors.forEach(supervisor => {
                        const transformedSupervisor = {
                            name: supervisor.name,
                            variants: {}
                        };
                        
                        // Find all production items assigned to this supervisor
                        if (supervisor.variants && Array.isArray(supervisor.variants)) {
                            supervisor.variants.forEach(variantId => {
                                // Find the production item for this variant
                                const prodItem = newData.production.find(p => p.id === variantId);
                                
                                if (prodItem) {
                                    // Find the supervisor assignment within the production item
                                    const assignment = prodItem.supervisors.find(s => s.id === supervisor.id);
                                    
                                    if (assignment) {
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: assignment.startTime,
                                            variantEndTime: assignment.endTime,
                                            dailyTarget: assignment.target,
                                            currentTotal: assignment.production,
                                            variance: assignment.production - assignment.target,
                                            percentage: assignment.progress
                                        };
                                    } else {
                                        // Fallback to using summary data if detailed assignment not found
                                        transformedSupervisor.variants[variantId] = {
                                            variantStartTime: prodItem.supervisors[0]?.startTime || "07:30",
                                            variantEndTime: prodItem.supervisors[0]?.endTime || "18:30",
                                            dailyTarget: prodItem.targets.daily,
                                            currentTotal: prodItem.actual.total,
                                            variance: prodItem.actual.total - prodItem.targets.daily,
                                            percentage: prodItem.actual.progress
                                        };
                                    }
                                }
                            });
                        }
                        
                        transformedData.supervisors.push(transformedSupervisor);
                    });
                }
            } else if (newData.variants && Array.isArray(newData.variants)) {
                // Previous structure with variants array
                transformedData.variants = newData.variants;
                transformedData.supervisors = newData.supervisors;
            }
            
            return transformedData;
        }
        
        // Function to process product-supervisor groups
        function processProductSupervisorGroups() {
            // Reset groups
            productSupervisorGroups = {};
            
            // First, create supervisor-product mapping
            productionData.supervisors.forEach(supervisor => {
                if (!supervisor.variants) return;
                
                // Create a temporary map of product -> variants
                const productVariants = {};
                
                // Process each variant
                Object.keys(supervisor.variants).forEach(variantKey => {
                    const product = extractProductFromVariant(variantKey);
                    
                    if (!productVariants[product]) {
                        productVariants[product] = [];
                    }
                    
                    // Find the variant in the variants array
                    const variantData = productionData.variants.find(v => v.variant === variantKey);
                    
                    if (variantData) {
                        productVariants[product].push({
                            variantKey,
                            variantData,
                            supervisorVariant: supervisor.variants[variantKey]
                        });
                    }
                });
                
                // Sort variants by start time and add to groups
                Object.keys(productVariants).forEach(product => {
                    const group = `${supervisor.name}:${product}`;
                    
                    // Sort variants by start time
                    const sortedVariants = productVariants[product].sort((a, b) => {
                        const timeA = a.supervisorVariant.variantStartTime || a.variantData["Start Time"] || "00:00";
                        const timeB = b.supervisorVariant.variantStartTime || b.variantData["Start Time"] || "00:00";
                        
                        const [hoursA, minutesA] = timeA.split(':').map(Number);
                        const [hoursB, minutesB] = timeB.split(':').map(Number);
                        
                        const totalMinutesA = hoursA * 60 + minutesA;
                        const totalMinutesB = hoursB * 60 + minutesB;
                        
                        return totalMinutesA - totalMinutesB;
                    });
                    
                    // Store in groups
                    productSupervisorGroups[group] = {
                        supervisor: supervisor.name,
                        product,
                        variants: sortedVariants.map(v => v.variantData),
                        supervisorData: supervisor
                    };
                });
            });
        }

        // Helper function to extract product from variant ID
        function extractProductFromVariant(variantId) {
            // For the new structure format with product-variant IDs like "Scalpel-Assembly-PARC11NS"
            if (variantId.includes('-')) {
                // Try splitting by dash and look for known product patterns
                const parts = variantId.split('-');
                
                // Handle case where product name contains a dash (like Scalpel-Assembly)
                if (parts.length > 2) {
                    // If we have more than one dash, the product likely contains a dash
                    // Extract everything except the last part (which is the variant)
                    return parts.slice(0, -1).join('-');
                } else if (parts.length === 2) {
                    // Simple product-variant format
                    return parts[0];
                }
            }

            // Fallback to original method for older formats
            const parts = variantId.split(' ');
            
            // Handle different formats
            if (parts.length === 1) return variantId; // No space, use as is
            if (parts.length === 2) return parts[0]; // Simple "Product Variant"
            
            // For more complex formats, try to find a pattern
            // Example: "LEVO XL1150SCi" -> "LEVO XL"
            const match = variantId.match(/^([A-Za-z\s]+)[\d]/);
            if (match && match[1]) {
                return match[1].trim();
            }
            
            // Fallback: use first word
            return parts[0];
        }

        // Function to update filter value dropdown
        function updateFilterValueDropdown() {
            const filterValueSelect = document.getElementById('filter-value-select');
            const currentValue = filterValueSelect.value;
            
            // Clear existing options (except 'all')
            while (filterValueSelect.options.length > 1) {
                filterValueSelect.remove(1);
            }
            
            if (selectedFilterType === 'supervisor' && productionData.supervisors?.length > 0) {
                // Add all supervisors
                productionData.supervisors.forEach(supervisor => {
                    const option = document.createElement('option');
                    option.value = supervisor.name;
                    option.textContent = supervisor.name;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'product') {
                // Add all unique products
                const uniqueProducts = new Set();
                
                // Extract products from all variants
                Object.keys(productSupervisorGroups).forEach(key => {
                    const group = productSupervisorGroups[key];
                    uniqueProducts.add(group.product);
                });
                
                // Add options
                uniqueProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    filterValueSelect.appendChild(option);
                });
            } else if (selectedFilterType === 'variant' && productionData.variants?.length > 0) {
                // Add all unique variants
                const uniqueVariants = new Set(productionData.variants.map(v => v.variant));
                uniqueVariants.forEach(variantName => {
                    const option = document.createElement('option');
                    option.value = variantName;
                    option.textContent = variantName;
                    filterValueSelect.appendChild(option);
                });
            }
            
            // Restore previous selection if available, otherwise use 'all'
            filterValueSelect.value = Array.from(filterValueSelect.options).some(opt => opt.value === currentValue) 
                ? currentValue 
                : 'all';
                
            selectedFilterValue = filterValueSelect.value;
        }

        // Function to show loading or error message
function showLoadingOrError(message) {
    const supervisorName = document.getElementById('supervisor-name');
    const productName = document.getElementById('product-name');
    const variantSequence = document.getElementById('variant-sequence');
    
    if (supervisorName) supervisorName.textContent = 'SUPERVISOR: Loading...';
    if (productName) productName.textContent = 'PRODUCT: Loading...';
    if (variantSequence) variantSequence.innerHTML = '<div class="loading">Loading variants...</div>';
    
    // Clear the metrics - add null checks for all elements
    const elementIds = [
        'current-units', 'target-units', 'progress-percentage', 
        'current-boxes', 'target-boxes', 'actual-cycle-time', 'target-cycle-time'
    ];
    
    elementIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.textContent = '0';
    });
    
    // Set progress percentage specifically
    const progressElement = document.getElementById('progress-percentage');
    if (progressElement) progressElement.textContent = '0%';
    
    // Clear the charts
    const cumulativeChart = document.getElementById('cumulative-chart');
    const hourlyChart = document.getElementById('hourly-chart');
    const unifiedView = document.getElementById('ellavi-unified-view');
    
    if (cumulativeChart) {
        cumulativeChart.innerHTML = 
            `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
    }
    
    if (hourlyChart) {
        hourlyChart.innerHTML = 
            `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
    }
    
    if (unifiedView) {
        unifiedView.innerHTML = 
            `<div style="display:flex;align-items:center;justify-content:center;height:100%;text-align:center;padding:20px;">${message}</div>`;
    }
    
    // Clear batch info table
    const batchInfoTable = document.getElementById('batch-info-tbody');
    if (batchInfoTable) {
        batchInfoTable.innerHTML = `<tr><td colspan="5">${message}</td></tr>`;
    }
}

        // Function to update date and time
        function updateDateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            
            document.getElementById('current-time').textContent = timeString;
            
            // Update current hour info in the legend
            updateCurrentHourInfo();
            
            // Check if we need to update dashboard based on time changes (variant transitions)
            if (currentProductVariants && currentProductVariants.length > 1) {
                const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
                let needsUpdate = false;
                
                // Check if we crossed a variant boundary
                currentProductVariants.forEach(variant => {
                    const supervisorVariant = currentSupervisor ? 
                        productionData.supervisors.find(s => s.name === currentSupervisor)?.variants[variant.variant] : null;
                    
                    if (!supervisorVariant) return;
                    
                    const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                    const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                    
                    if (!startTimeStr || !endTimeStr) return;
                    
                    const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                    const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                    
                    const startTimeMinutes = startHour * 60 + startMinute;
                    const endTimeMinutes = endHour * 60 + endMinute;
                    
                    // Check if we just crossed this boundary
                    if (currentTimeMinutes === startTimeMinutes || currentTimeMinutes === endTimeMinutes) {
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    updateDashboard();
                }
            }
        }

        // Function to update the current hour info in the legend
        function updateCurrentHourInfo() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Find next hour boundary (formatted as "HH:30")
            const nextHourMinute = 30;
            const nextHour = currentMinute < nextHourMinute ? currentHour : currentHour + 1;
            
            // Calculate minutes remaining
            let minutesRemaining;
            if (currentMinute < nextHourMinute) {
                minutesRemaining = nextHourMinute - currentMinute;
            } else {
                minutesRemaining = (60 - currentMinute) + nextHourMinute;
            }
            
            // Format the current hour string
            const hourStr = currentMinute < 30 ? 
                `${currentHour.toString().padStart(2, '0')}:30` : 
                `${(currentHour + 1).toString().padStart(2, '0')}:30`;
            
            document.getElementById('current-hour-info').textContent = 
                `CURRENT HOUR: ${hourStr} (${minutesRemaining} MIN LEFT)`;
        }

        // Updated dashboard rendering
        function displayGroup(group) {
            // Set current product and supervisor
            currentProduct = group.product;
            currentSupervisor = group.supervisor;
            currentProductVariants = group.variants;
            
            // Find current variant
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Sort variants by start time
            const sortedVariants = [...currentProductVariants].sort((a, b) => {
                const supervisorA = group.supervisorData.variants[a.variant];
                const supervisorB = group.supervisorData.variants[b.variant];
                
                const timeA = supervisorA.variantStartTime || a["Start Time"] || "00:00";
                const timeB = supervisorB.variantStartTime || b["Start Time"] || "00:00";
                
                const [hoursA, minutesA] = timeA.split(':').map(Number);
                const [hoursB, minutesB] = timeB.split(':').map(Number);
                
                return (hoursA * 60 + minutesA) - (hoursB * 60 + minutesB);
            });
            
            // Find the current active variant
            let currentVariantIndex = -1;
            
            for (let i = 0; i < sortedVariants.length; i++) {
                const variant = sortedVariants[i];
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) continue;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Check if current time is within this variant's window
                if (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes) {
                    currentVariantIndex = i;
                    break;
                }
            }
            
            // If no current variant found, use last variant
            if (currentVariantIndex === -1 && sortedVariants.length > 0) {
                currentVariantIndex = sortedVariants.length - 1;
            }
            
            // Set current variant
            currentVariantKey = currentVariantIndex >= 0 ? sortedVariants[currentVariantIndex].variant : null;
            
            // Apply styling based on supervisor
            applySupervisorStyling(currentSupervisor);
            
            // Update UI
            updateSupervisorInfo(group);
            updateMetrics(group);
            
            // Make sure variant sequence is displayed (might be hidden by Ellavi view)
            document.getElementById('variant-sequence').style.display = 'flex';
            
            // Set standard chart display
            document.getElementById('cumulative-chart').classList.remove('hidden');
            document.getElementById('ellavi-unified-view').classList.add('hidden');
            
            // Small delay to ensure UI updates before redrawing charts
            setTimeout(() => {
                renderCumulativeChart(group);
                renderHourlyChart(group);
            }, 50);
        }
        
        // FIXED FUNCTION: Update batch information table
        function updateBatchInfoTable(filteredGroups) {
            const batchInfoTableBody = document.getElementById('batch-info-tbody');
            const batchInfoTableHead = document.getElementById('batch-info-thead');
            
            if (!batchInfoTableBody || !batchInfoTableHead) return;
            
            // Clear existing content
            batchInfoTableBody.innerHTML = '';
            batchInfoTableHead.innerHTML = '';
            
            // If no original data, show message
            if (!productionData.originalData || !productionData.originalData.production) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
                return;
            }
            
            // Get current time to determine current variant - MOVED TO TOP
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Create the table header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = `
                <th>Product</th>
                <th>Variant</th>
                <th>Batch</th>
                <th>Units</th>
                <th>Boxes</th>
            `;
            batchInfoTableHead.appendChild(headerRow);
            
            // Create a Map to store the unique batches by ID
            // This ensures we don't count the same batch multiple times
            const uniqueBatchesMap = new Map();
            
            // Process each group's variants
            Object.values(filteredGroups).forEach(group => {
                // Get the supervisor's variants
                const supervisorName = group.supervisor;
                const supervisor = productionData.supervisors.find(s => s.name === supervisorName);
                
                if (!supervisor || !supervisor.variants) return;
                
                // For each variant assigned to this supervisor
                Object.keys(supervisor.variants).forEach(variantKey => {
                    // Find the original production data
                    const productionItem = productionData.originalData.production.find(p => p.id === variantKey);
                    
                    if (!productionItem || !productionItem.batches) return;
                    
                    // Get variant details
                    const productName = productionItem.product?.name || extractProductFromVariant(variantKey);
                    const variantName = productionItem.variant?.name || variantKey.split('-').pop();
                    
                    // Check if this variant is currently active
                    const supervisorVariant = supervisor.variants[variantKey];
                    let isCurrentVariant = false;
                    
                    if (supervisorVariant) {
                        const startTimeStr = supervisorVariant.variantStartTime || productionItem.supervisors[0]?.startTime;
                        const endTimeStr = supervisorVariant.variantEndTime || productionItem.supervisors[0]?.endTime;
                        
                        if (startTimeStr && endTimeStr) {
                            const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                            const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                            
                            const startTimeMinutes = startHour * 60 + startMinute;
                            const endTimeMinutes = endHour * 60 + endMinute;
                            
                            // Check if current time is within this variant's window
                            isCurrentVariant = (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
                        }
                    }
                    
                    // Process each batch - USE THE ORIGINAL QUANTITIES
                    productionItem.batches.forEach(batch => {
                        const batchKey = `${productName}-${variantName}-${batch.id}`;
                        
                        // Only add the batch if we haven't seen it before
                        if (!uniqueBatchesMap.has(batchKey)) {
                            uniqueBatchesMap.set(batchKey, {
                                product: productName,
                                variant: variantName,
                                batchId: batch.id,
                                units: batch.quantity,  // Use original quantity
                                boxes: batch.boxes,     // Use original boxes count
                                supervisor: supervisorName,
                                isCurrent: isCurrentVariant,
                                isAssembly: productName.toLowerCase().includes('assembly')
                            });
                        } else {
                            // If we do have the batch, just update the isCurrent flag if needed
                            if (isCurrentVariant) {
                                uniqueBatchesMap.get(batchKey).isCurrent = true;
                            }
                        }
                    });
                });
            });
            
            // Convert map to array for display
            const batchData = Array.from(uniqueBatchesMap.values());
            
            // Sort batches by product, then by variant
            batchData.sort((a, b) => {
                // First by product
                if (a.product !== b.product) {
                    return a.product.localeCompare(b.product);
                }
                
                // Then by variant
                if (a.variant !== b.variant) {
                    return a.variant.localeCompare(b.variant);
                }
                
                // Then by batch ID
                return a.batchId - b.batchId;
            });
            
            // Create table rows for each batch
            if (batchData.length === 0) {
                batchInfoTableBody.innerHTML = '<tr><td colspan="5">No batch information available</td></tr>';
                return;
            }
            
            let currentProduct = null;
            
            batchData.forEach(batch => {
                // Add product header if changed
                if (batch.product !== currentProduct) {
                    currentProduct = batch.product;
                    
                    const productRow = document.createElement('tr');
                    productRow.style.backgroundColor = '#f0f9ff'; // Light blue background
                    
                    const productCell = document.createElement('td');
                    productCell.colSpan = 5;
                    productCell.style.fontWeight = 'bold';
                    productCell.style.fontSize = 'larger';
                    productCell.textContent = batch.product;
                    
                    productRow.appendChild(productCell);
                    batchInfoTableBody.appendChild(productRow);
                }
                
                // Create batch row
                const row = document.createElement('tr');
                if (batch.isCurrent) {
                    row.className = 'current';
                }
                
                // Product cell - Now less prominent since we have product headers
                const productCell = document.createElement('td');
                productCell.style.opacity = '0.5'; // Make less prominent
                productCell.textContent = batch.product;
                row.appendChild(productCell);
                
                // Variant cell
                const variantCell = document.createElement('td');
                variantCell.textContent = batch.variant;
                row.appendChild(variantCell);
                
                // Batch ID cell
                const batchCell = document.createElement('td');
                batchCell.className = 'batch-number';
                batchCell.textContent = batch.batchId;
                row.appendChild(batchCell);
                
                // Units cell
                const unitsCell = document.createElement('td');
                unitsCell.textContent = batch.units;
                row.appendChild(unitsCell);
                
                // Boxes/Bags cell - Display appropriate container type
                const containerCell = document.createElement('td');
                if (batch.isAssembly) {
                    containerCell.textContent = `${batch.boxes} Bags`;
                } else {
                    containerCell.textContent = batch.boxes;
                }
                row.appendChild(containerCell);
                
                batchInfoTableBody.appendChild(row);
            });
        }

        // Function to apply supervisor styling
        function applySupervisorStyling(supervisorName) {
            const supervisorColorBanner = document.querySelector('.supervisor-color-banner');
            supervisorPanel = document.querySelector('.supervisor-panel');
            
            // Apply supervisor-specific color
            if (supervisorName) {
                const color = getSupervisorColor(supervisorName);
                supervisorColorBanner.style.backgroundColor = color;
                supervisorPanel.style.backgroundColor = color;
            }
        }

        // Function to update supervisor info
        function updateSupervisorInfo(group) {
            document.getElementById('supervisor-name').textContent = `SUPERVISOR: ${group.supervisor}`;
            document.getElementById('product-name').textContent = `PRODUCT: ${group.product}`;
            
            // Update variant sequence
            const sequenceContainer = document.getElementById('variant-sequence');
            sequenceContainer.innerHTML = '';
            
            if (group.variants.length === 0) {
                sequenceContainer.innerHTML = '<div>No variants available</div>';
                return;
            }
            
            // Get current time to determine variant status
            const now = new Date();
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
            
            // Add each variant to the sequence
            group.variants.forEach((variant, index) => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (!supervisorVariant) return;
                
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                const endTimeStr = supervisorVariant.variantEndTime || variant["End Time"];
                
                if (!startTimeStr || !endTimeStr) return;
                
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                
                const startTimeMinutes = startHour * 60 + startMinute;
                const endTimeMinutes = endHour * 60 + endMinute;
                
                // Determine variant status
                let status = '';
                if (currentTimeMinutes < startTimeMinutes) {
                    status = 'upcoming';
                } else if (currentTimeMinutes > endTimeMinutes) {
                    status = 'completed';
                } else {
                    status = 'current';
                }
                
                // Extract variant name from full variant string
                let displayName = variant.variant;
                
                // Try to extract just the variant part
                if (variant.variant.includes('-')) {
                    displayName = variant.variant.split('-').pop();
                } else if (variant.variant.startsWith(group.product + ' ')) {
                    displayName = variant.variant.substring(group.product.length + 1);
                }
                
                // Create variant element
                const variantElement = document.createElement('div');
                variantElement.className = `variant-item ${status}`;
                variantElement.textContent = displayName;
                
                sequenceContainer.appendChild(variantElement);
                
                // Add arrow if not the last variant
                if (index < group.variants.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-right';
                    arrow.textContent = '→';
                    sequenceContainer.appendChild(arrow);
                }
            });
        }

        // Function to update metrics
        function updateMetrics(group) {
            // Initialize aggregated values
            let totalTarget = 0;
            let totalProduction = 0;
            let totalBoxTarget = 0;
            let totalBoxProduction = 0;
            let weightedCycleTime = 0;
            let totalCycleTimeWeight = 0;
            
            // Calculate aggregated values
            group.variants.forEach(variant => {
                const supervisorVariant = group.supervisorData.variants[variant.variant];
                
                if (supervisorVariant) {
                    totalTarget += (supervisorVariant.dailyTarget || 0);
                    totalProduction += (supervisorVariant.currentTotal || 0);
                    
                    // Add box totals consistently for all variants
                    totalBoxTarget += (variant.dailyBoxTarget || 0);
                    totalBoxProduction += (variant.currentBoxTotal || 0);
                    
                    // Add cycle time weighted by target
                    const cycleTime = variant.cycleTime || 0;
                    const target = supervisorVariant.dailyTarget || 0;
                    
                    if (cycleTime > 0 && target > 0) {
                        weightedCycleTime += cycleTime * target;
                        totalCycleTimeWeight += target;
                    }
                }
            });
            
            // Calculate overall progress percentage
            const progressPercentage = totalTarget > 0 ? Math.round((totalProduction / totalTarget) * 100) : 0;
            
            // Calculate average cycle time
            const avgCycleTime = totalCycleTimeWeight > 0 ? Math.round(weightedCycleTime / totalCycleTimeWeight) : 0;
            
            // Calculate actual cycle time across all variants
            const actualCycleTime = calculateActualCycleTime(group.variants);
            
            // Update metrics display
            document.getElementById('current-units').textContent = totalProduction;
            document.getElementById('target-units').textContent = totalTarget;
            document.getElementById('progress-percentage').textContent = `${progressPercentage}%`;
            
            document.getElementById('current-boxes').textContent = totalBoxProduction;
            document.getElementById('target-boxes').textContent = totalBoxTarget;
            
            document.getElementById('actual-cycle-time').textContent = actualCycleTime === "N/A" ? "N/A" : actualCycleTime;
            document.getElementById('target-cycle-time').textContent = avgCycleTime;
        }

       function calculateActualCycleTime(variants) {
    // Check if any variant has actualCycleTime - if so, use weighted average of those values
    const variantsWithActualCycleTime = variants.filter(v => v.actualCycleTime !== undefined && v.actualCycleTime !== null);
    
    if (variantsWithActualCycleTime.length > 0) {
        // Calculate weighted average of actualCycleTime if multiple variants
        if (variantsWithActualCycleTime.length > 1) {
            let totalWeight = 0;
            let weightedSum = 0;
            
            // Weight by production quantities
            variantsWithActualCycleTime.forEach(variant => {
                const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
                if (supervisor && supervisor.variants[variant.variant]) {
                    const supervisorVariant = supervisor.variants[variant.variant];
                    if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                        totalWeight += supervisorVariant.currentTotal;
                        weightedSum += variant.actualCycleTime * supervisorVariant.currentTotal;
                    }
                }
            });
            
            if (totalWeight > 0) {
                return Math.round(weightedSum / totalWeight);
            } else {
                // If no weights, use simple average
                const sum = variantsWithActualCycleTime.reduce((acc, v) => acc + v.actualCycleTime, 0);
                return Math.round(sum / variantsWithActualCycleTime.length);
            }
        } else {
            // If only one variant, just return its actualCycleTime
            return variantsWithActualCycleTime[0].actualCycleTime;
        }
    }
    
    // Fall back to original calculation if no actualCycleTime is available
    let totalProduction = 0;
    let totalElapsedWorkingTime = 0;
    
    variants.forEach(variant => {
        const supervisor = productionData.supervisors.find(s => s.name === currentSupervisor);
        if (supervisor && supervisor.variants[variant.variant]) {
            const supervisorVariant = supervisor.variants[variant.variant];
            
            if (supervisorVariant.currentTotal && supervisorVariant.currentTotal > 0) {
                const startTimeStr = supervisorVariant.variantStartTime || variant["Start Time"];
                
                if (startTimeStr && variant.hourlyProduction) {
                    // Find the last hour with non-zero production
                    const hoursWithProduction = variant.hourlyProduction
                        .filter(h => h.production > 0)
                        .sort((a, b) => {
                            const [hourA, minuteA] = a.hour.split(':').map(Number);
                            const [hourB, minuteB] = b.hour.split(':').map(Number);
                            return (hourB * 60 + minuteB) - (hourA * 60 + minuteA); // Sort descending
                        });
                    
                    if (hoursWithProduction.length > 0) {
                        // Get the latest hour with non-zero production
                        const lastProductionHourData = hoursWithProduction[0];
                        const [lastHours, lastMinutes] = lastProductionHourData.hour.split(':').map(Number);
                        const lastTotalMinutes = lastHours * 60 + lastMinutes;
                        
                        const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
                        const startTotalMinutes = startHours * 60 + startMinutes;
                        
                        // Calculate elapsed time in minutes (from start until last production hour)
                        let elapsedMinutes = lastTotalMinutes - startTotalMinutes;
                        if (elapsedMinutes < 0) {
                            elapsedMinutes += 24 * 60; // Handle case where start was yesterday
                        }
                        
                        // Create a date object for the last production hour to calculate break times
                        const now = new Date();
                        const lastProductionTime = new Date(now);
                        lastProductionTime.setHours(lastHours);
                        lastProductionTime.setMinutes(lastMinutes);
                        
                        // Calculate elapsed break time
                        const elapsedBreakMinutes = calculateElapsedBreakMinutes(variant, startTimeStr, lastProductionTime);
                        
                        // Calculate actual working time
                        const workingMinutes = elapsedMinutes - elapsedBreakMinutes;
                        
                        // Add to totals
                        totalProduction += supervisorVariant.currentTotal;
                        totalElapsedWorkingTime += workingMinutes * 60; // Convert to seconds
                    }
                }
            }
        }
    });
    
    if (totalProduction <= 0 || totalElapsedWorkingTime <= 0) return "N/A";
    
    // Calculate overall cycle time
    return Math.round(totalElapsedWorkingTime / totalProduction);
}
        
// Helper function to calculate elapsed break minutes
function calculateElapsedBreakMinutes(variant, startTimeStr, now) {
    let totalElapsedBreakMinutes = 0;
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    // Function to check if a break has already occurred or is occurring
    const getElapsedBreakMinutes = (breakStartStr, breakEndStr) => {
        if (!breakStartStr || !breakEndStr) return 0;
        if (breakStartStr === "-" || breakEndStr === "-") return 0;
        
        const [breakStartHour, breakStartMinute] = breakStartStr.split(':').map(Number);
        const [breakEndHour, breakEndMinute] = breakEndStr.split(':').map(Number);
        
        const breakStartMinutes = breakStartHour * 60 + breakStartMinute;
        const breakEndMinutes = breakEndHour * 60 + breakEndMinute;
        
        // If break hasn't started yet, return 0
        if (currentTime < breakStartMinutes) return 0;
        
        // If break is in progress, return elapsed portion
        if (currentTime < breakEndMinutes) return currentTime - breakStartMinutes;
        
        // If break is complete, return full duration
        return breakEndMinutes - breakStartMinutes;
    };
    
    // Check each break
    if (variant["Break Start (Lunch)"] && variant["Break End (Lunch)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Lunch)"], variant["Break End (Lunch)"]);
    }
    
    if (variant["Break Start (Tea)"] && variant["Break End (Tea)"]) {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["Break Start (Tea)"], variant["Break End (Tea)"]);
    }
    
    if (variant["OT Break Start (Tea)"] && variant["OT Break End (Tea)"] && 
        variant["OT Break Start (Tea)"] !== "-" && variant["OT Break End (Tea)"] !== "-") {
        totalElapsedBreakMinutes += getElapsedBreakMinutes(variant["OT Break Start (Tea)"], variant["OT Break End (Tea)"]);
    }
    
    return totalElapsedBreakMinutes;
}

// Initialize the dashboard when DOM is fully loaded
document.addEventListener('DOMContentLoaded', initDashboard);

// Make sure we cleanup on page unload
window.addEventListener('beforeunload', function() {
    // Clear all intervals to prevent memory leaks
    if (cycleInterval) clearInterval(cycleInterval);
    if (chartRotationInterval) clearInterval(chartRotationInterval);
    if (countdownInterval) clearInterval(countdownInterval);
});
    </script>
</body>
</html>
                        
